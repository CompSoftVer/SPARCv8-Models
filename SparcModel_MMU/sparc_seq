module Sparc_seq : sig
  type num
  type int
  type nat
  type 'a word
  type word_length5
  type word_length32
  type cPU_register
  type 'a sparc_state_var_ext
  type ('a, 'b) sparc_state_ext
  val state_undef : ('a, unit) sparc_state_ext -> bool
  val reset_mode_mod :
    bool -> ('a, unit) sparc_state_ext -> ('a, unit) sparc_state_ext
  val reset_mode_val : ('a, unit) sparc_state_ext -> bool
  val init_state0 : (word_length5, unit) sparc_state_ext
  val seq_exec_leon3 :
    nat ->
      (word_length5, unit) sparc_state_ext ->
        (unit * (word_length5, unit) sparc_state_ext) * bool
end = struct

type num = One | Bit0 of num | Bit1 of num;;

let rec equal_num x0 x1 = match x0, x1 with Bit0 x2, Bit1 x3 -> false
                    | Bit1 x3, Bit0 x2 -> false
                    | One, Bit1 x3 -> false
                    | Bit1 x3, One -> false
                    | One, Bit0 x2 -> false
                    | Bit0 x2, One -> false
                    | Bit1 x3, Bit1 y3 -> equal_num x3 y3
                    | Bit0 x2, Bit0 y2 -> equal_num x2 y2
                    | One, One -> true;;

type int = Zero_int | Pos of num | Neg of num;;

let rec equal_inta x0 x1 = match x0, x1 with Neg k, Neg l -> equal_num k l
                     | Neg k, Pos l -> false
                     | Neg k, Zero_int -> false
                     | Pos k, Neg l -> false
                     | Pos k, Pos l -> equal_num k l
                     | Pos k, Zero_int -> false
                     | Zero_int, Neg l -> false
                     | Zero_int, Pos l -> false
                     | Zero_int, Zero_int -> true;;

type 'a equal = {equal : 'a -> 'a -> bool};;
let equal _A = _A.equal;;

let equal_int = ({equal = equal_inta} : int equal);;

let one_inta : int = Pos One;;

type 'a one = {one : 'a};;
let one _A = _A.one;;

let one_int = ({one = one_inta} : int one);;

let rec plus_num
  x0 x1 = match x0, x1 with Bit1 m, Bit1 n -> Bit0 (plus_num (plus_num m n) One)
    | Bit1 m, Bit0 n -> Bit1 (plus_num m n)
    | Bit1 m, One -> Bit0 (plus_num m One)
    | Bit0 m, Bit1 n -> Bit1 (plus_num m n)
    | Bit0 m, Bit0 n -> Bit0 (plus_num m n)
    | Bit0 m, One -> Bit1 m
    | One, Bit1 n -> Bit0 (plus_num n One)
    | One, Bit0 n -> Bit1 n
    | One, One -> Bit0 One;;

let rec uminus_int = function Neg m -> Pos m
                     | Pos m -> Neg m
                     | Zero_int -> Zero_int;;

let rec bitM = function One -> One
               | Bit0 n -> Bit1 (bitM n)
               | Bit1 n -> Bit1 (Bit0 n);;

let rec dup = function Neg n -> Neg (Bit0 n)
              | Pos n -> Pos (Bit0 n)
              | Zero_int -> Zero_int;;

let rec plus_inta k l = match k, l with Neg m, Neg n -> Neg (plus_num m n)
                    | Neg m, Pos n -> sub n m
                    | Pos m, Neg n -> sub m n
                    | Pos m, Pos n -> Pos (plus_num m n)
                    | Zero_int, l -> l
                    | k, Zero_int -> k
and sub
  x0 x1 = match x0, x1 with Bit0 m, Bit1 n -> minus_int (dup (sub m n)) one_inta
    | Bit1 m, Bit0 n -> plus_inta (dup (sub m n)) one_inta
    | Bit1 m, Bit1 n -> dup (sub m n)
    | Bit0 m, Bit0 n -> dup (sub m n)
    | One, Bit1 n -> Neg (Bit0 n)
    | One, Bit0 n -> Neg (bitM n)
    | Bit1 m, One -> Pos (Bit0 m)
    | Bit0 m, One -> Pos (bitM m)
    | One, One -> Zero_int
and minus_int k l = match k, l with Neg m, Neg n -> sub n m
                | Neg m, Pos n -> Neg (plus_num m n)
                | Pos m, Neg n -> Pos (plus_num m n)
                | Pos m, Pos n -> sub m n
                | Zero_int, l -> uminus_int l
                | k, Zero_int -> k;;

type 'a plus = {plus : 'a -> 'a -> 'a};;
let plus _A = _A.plus;;

let plus_int = ({plus = plus_inta} : int plus);;

type 'a zero = {zero : 'a};;
let zero _A = _A.zero;;

let zero_int = ({zero = Zero_int} : int zero);;

type 'a semigroup_add = {plus_semigroup_add : 'a plus};;

type 'a numeral =
  {one_numeral : 'a one; semigroup_add_numeral : 'a semigroup_add};;

let semigroup_add_int = ({plus_semigroup_add = plus_int} : int semigroup_add);;

let numeral_int =
  ({one_numeral = one_int; semigroup_add_numeral = semigroup_add_int} :
    int numeral);;

let rec times_num
  m n = match m, n with
    Bit1 m, Bit1 n -> Bit1 (plus_num (plus_num m n) (Bit0 (times_num m n)))
    | Bit1 m, Bit0 n -> Bit0 (times_num (Bit1 m) n)
    | Bit0 m, Bit1 n -> Bit0 (times_num m (Bit1 n))
    | Bit0 m, Bit0 n -> Bit0 (Bit0 (times_num m n))
    | One, n -> n
    | m, One -> m;;

let rec times_inta k l = match k, l with Neg m, Neg n -> Pos (times_num m n)
                     | Neg m, Pos n -> Neg (times_num m n)
                     | Pos m, Neg n -> Neg (times_num m n)
                     | Pos m, Pos n -> Pos (times_num m n)
                     | Zero_int, l -> Zero_int
                     | k, Zero_int -> Zero_int;;

type 'a times = {times : 'a -> 'a -> 'a};;
let times _A = _A.times;;

type 'a power = {one_power : 'a one; times_power : 'a times};;

let times_int = ({times = times_inta} : int times);;

let power_int = ({one_power = one_int; times_power = times_int} : int power);;

type 'a ab_semigroup_add = {semigroup_add_ab_semigroup_add : 'a semigroup_add};;

type 'a semigroup_mult = {times_semigroup_mult : 'a times};;

type 'a semiring =
  {ab_semigroup_add_semiring : 'a ab_semigroup_add;
    semigroup_mult_semiring : 'a semigroup_mult};;

let ab_semigroup_add_int =
  ({semigroup_add_ab_semigroup_add = semigroup_add_int} :
    int ab_semigroup_add);;

let semigroup_mult_int =
  ({times_semigroup_mult = times_int} : int semigroup_mult);;

let semiring_int =
  ({ab_semigroup_add_semiring = ab_semigroup_add_int;
     semigroup_mult_semiring = semigroup_mult_int}
    : int semiring);;

type 'a mult_zero = {times_mult_zero : 'a times; zero_mult_zero : 'a zero};;

let mult_zero_int =
  ({times_mult_zero = times_int; zero_mult_zero = zero_int} : int mult_zero);;

type 'a monoid_add =
  {semigroup_add_monoid_add : 'a semigroup_add; zero_monoid_add : 'a zero};;

type 'a comm_monoid_add =
  {ab_semigroup_add_comm_monoid_add : 'a ab_semigroup_add;
    monoid_add_comm_monoid_add : 'a monoid_add};;

type 'a semiring_0 =
  {comm_monoid_add_semiring_0 : 'a comm_monoid_add;
    mult_zero_semiring_0 : 'a mult_zero; semiring_semiring_0 : 'a semiring};;

let monoid_add_int =
  ({semigroup_add_monoid_add = semigroup_add_int; zero_monoid_add = zero_int} :
    int monoid_add);;

let comm_monoid_add_int =
  ({ab_semigroup_add_comm_monoid_add = ab_semigroup_add_int;
     monoid_add_comm_monoid_add = monoid_add_int}
    : int comm_monoid_add);;

let semiring_0_int =
  ({comm_monoid_add_semiring_0 = comm_monoid_add_int;
     mult_zero_semiring_0 = mult_zero_int; semiring_semiring_0 = semiring_int}
    : int semiring_0);;

type 'a monoid_mult =
  {semigroup_mult_monoid_mult : 'a semigroup_mult;
    power_monoid_mult : 'a power};;

type 'a semiring_numeral =
  {monoid_mult_semiring_numeral : 'a monoid_mult;
    numeral_semiring_numeral : 'a numeral;
    semiring_semiring_numeral : 'a semiring};;

type 'a zero_neq_one =
  {one_zero_neq_one : 'a one; zero_zero_neq_one : 'a zero};;

type 'a semiring_1 =
  {semiring_numeral_semiring_1 : 'a semiring_numeral;
    semiring_0_semiring_1 : 'a semiring_0;
    zero_neq_one_semiring_1 : 'a zero_neq_one};;

let monoid_mult_int =
  ({semigroup_mult_monoid_mult = semigroup_mult_int;
     power_monoid_mult = power_int}
    : int monoid_mult);;

let semiring_numeral_int =
  ({monoid_mult_semiring_numeral = monoid_mult_int;
     numeral_semiring_numeral = numeral_int;
     semiring_semiring_numeral = semiring_int}
    : int semiring_numeral);;

let zero_neq_one_int =
  ({one_zero_neq_one = one_int; zero_zero_neq_one = zero_int} :
    int zero_neq_one);;

let semiring_1_int =
  ({semiring_numeral_semiring_1 = semiring_numeral_int;
     semiring_0_semiring_1 = semiring_0_int;
     zero_neq_one_semiring_1 = zero_neq_one_int}
    : int semiring_1);;

type nat = Zero_nat | Suc of nat;;

type 'a itself = Type;;

type 'a len0 = {len_of : 'a itself -> nat};;
let len_of _A = _A.len_of;;

type 'a word = Word of int;;

let rec uint _A (Word x) = x;;

let rec equal_worda _A k l = equal_inta (uint _A k) (uint _A l);;

let rec equal_word _A = ({equal = equal_worda _A} : 'a word equal);;

type trap = Reset | Data_store_error | Instruction_access_MMU_miss |
  Instruction_access_error | R_register_access_error |
  Instruction_access_exception | Privileged_instruction | Illegal_instruction |
  Unimplemented_FLUSH | Watchpoint_detected | Fp_disabled | Cp_disabled |
  Window_overflow | Window_underflow | Mem_address_not_aligned | Fp_exception |
  Cp_exception | Data_access_error | Data_access_MMU_miss |
  Data_access_exception | Tag_overflow | Division_by_zero | Trap_instruction |
  Interrupt_level_n;;

let rec equal_Trapa
  x0 x1 = match x0, x1 with Trap_instruction, Interrupt_level_n -> false
    | Interrupt_level_n, Trap_instruction -> false
    | Division_by_zero, Interrupt_level_n -> false
    | Interrupt_level_n, Division_by_zero -> false
    | Division_by_zero, Trap_instruction -> false
    | Trap_instruction, Division_by_zero -> false
    | Tag_overflow, Interrupt_level_n -> false
    | Interrupt_level_n, Tag_overflow -> false
    | Tag_overflow, Trap_instruction -> false
    | Trap_instruction, Tag_overflow -> false
    | Tag_overflow, Division_by_zero -> false
    | Division_by_zero, Tag_overflow -> false
    | Data_access_exception, Interrupt_level_n -> false
    | Interrupt_level_n, Data_access_exception -> false
    | Data_access_exception, Trap_instruction -> false
    | Trap_instruction, Data_access_exception -> false
    | Data_access_exception, Division_by_zero -> false
    | Division_by_zero, Data_access_exception -> false
    | Data_access_exception, Tag_overflow -> false
    | Tag_overflow, Data_access_exception -> false
    | Data_access_MMU_miss, Interrupt_level_n -> false
    | Interrupt_level_n, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Trap_instruction -> false
    | Trap_instruction, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Division_by_zero -> false
    | Division_by_zero, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Tag_overflow -> false
    | Tag_overflow, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Data_access_exception -> false
    | Data_access_exception, Data_access_MMU_miss -> false
    | Data_access_error, Interrupt_level_n -> false
    | Interrupt_level_n, Data_access_error -> false
    | Data_access_error, Trap_instruction -> false
    | Trap_instruction, Data_access_error -> false
    | Data_access_error, Division_by_zero -> false
    | Division_by_zero, Data_access_error -> false
    | Data_access_error, Tag_overflow -> false
    | Tag_overflow, Data_access_error -> false
    | Data_access_error, Data_access_exception -> false
    | Data_access_exception, Data_access_error -> false
    | Data_access_error, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Data_access_error -> false
    | Cp_exception, Interrupt_level_n -> false
    | Interrupt_level_n, Cp_exception -> false
    | Cp_exception, Trap_instruction -> false
    | Trap_instruction, Cp_exception -> false
    | Cp_exception, Division_by_zero -> false
    | Division_by_zero, Cp_exception -> false
    | Cp_exception, Tag_overflow -> false
    | Tag_overflow, Cp_exception -> false
    | Cp_exception, Data_access_exception -> false
    | Data_access_exception, Cp_exception -> false
    | Cp_exception, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Cp_exception -> false
    | Cp_exception, Data_access_error -> false
    | Data_access_error, Cp_exception -> false
    | Fp_exception, Interrupt_level_n -> false
    | Interrupt_level_n, Fp_exception -> false
    | Fp_exception, Trap_instruction -> false
    | Trap_instruction, Fp_exception -> false
    | Fp_exception, Division_by_zero -> false
    | Division_by_zero, Fp_exception -> false
    | Fp_exception, Tag_overflow -> false
    | Tag_overflow, Fp_exception -> false
    | Fp_exception, Data_access_exception -> false
    | Data_access_exception, Fp_exception -> false
    | Fp_exception, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Fp_exception -> false
    | Fp_exception, Data_access_error -> false
    | Data_access_error, Fp_exception -> false
    | Fp_exception, Cp_exception -> false
    | Cp_exception, Fp_exception -> false
    | Mem_address_not_aligned, Interrupt_level_n -> false
    | Interrupt_level_n, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Trap_instruction -> false
    | Trap_instruction, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Division_by_zero -> false
    | Division_by_zero, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Tag_overflow -> false
    | Tag_overflow, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Data_access_exception -> false
    | Data_access_exception, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Data_access_error -> false
    | Data_access_error, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Cp_exception -> false
    | Cp_exception, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Fp_exception -> false
    | Fp_exception, Mem_address_not_aligned -> false
    | Window_underflow, Interrupt_level_n -> false
    | Interrupt_level_n, Window_underflow -> false
    | Window_underflow, Trap_instruction -> false
    | Trap_instruction, Window_underflow -> false
    | Window_underflow, Division_by_zero -> false
    | Division_by_zero, Window_underflow -> false
    | Window_underflow, Tag_overflow -> false
    | Tag_overflow, Window_underflow -> false
    | Window_underflow, Data_access_exception -> false
    | Data_access_exception, Window_underflow -> false
    | Window_underflow, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Window_underflow -> false
    | Window_underflow, Data_access_error -> false
    | Data_access_error, Window_underflow -> false
    | Window_underflow, Cp_exception -> false
    | Cp_exception, Window_underflow -> false
    | Window_underflow, Fp_exception -> false
    | Fp_exception, Window_underflow -> false
    | Window_underflow, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Window_underflow -> false
    | Window_overflow, Interrupt_level_n -> false
    | Interrupt_level_n, Window_overflow -> false
    | Window_overflow, Trap_instruction -> false
    | Trap_instruction, Window_overflow -> false
    | Window_overflow, Division_by_zero -> false
    | Division_by_zero, Window_overflow -> false
    | Window_overflow, Tag_overflow -> false
    | Tag_overflow, Window_overflow -> false
    | Window_overflow, Data_access_exception -> false
    | Data_access_exception, Window_overflow -> false
    | Window_overflow, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Window_overflow -> false
    | Window_overflow, Data_access_error -> false
    | Data_access_error, Window_overflow -> false
    | Window_overflow, Cp_exception -> false
    | Cp_exception, Window_overflow -> false
    | Window_overflow, Fp_exception -> false
    | Fp_exception, Window_overflow -> false
    | Window_overflow, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Window_overflow -> false
    | Window_overflow, Window_underflow -> false
    | Window_underflow, Window_overflow -> false
    | Cp_disabled, Interrupt_level_n -> false
    | Interrupt_level_n, Cp_disabled -> false
    | Cp_disabled, Trap_instruction -> false
    | Trap_instruction, Cp_disabled -> false
    | Cp_disabled, Division_by_zero -> false
    | Division_by_zero, Cp_disabled -> false
    | Cp_disabled, Tag_overflow -> false
    | Tag_overflow, Cp_disabled -> false
    | Cp_disabled, Data_access_exception -> false
    | Data_access_exception, Cp_disabled -> false
    | Cp_disabled, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Cp_disabled -> false
    | Cp_disabled, Data_access_error -> false
    | Data_access_error, Cp_disabled -> false
    | Cp_disabled, Cp_exception -> false
    | Cp_exception, Cp_disabled -> false
    | Cp_disabled, Fp_exception -> false
    | Fp_exception, Cp_disabled -> false
    | Cp_disabled, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Cp_disabled -> false
    | Cp_disabled, Window_underflow -> false
    | Window_underflow, Cp_disabled -> false
    | Cp_disabled, Window_overflow -> false
    | Window_overflow, Cp_disabled -> false
    | Fp_disabled, Interrupt_level_n -> false
    | Interrupt_level_n, Fp_disabled -> false
    | Fp_disabled, Trap_instruction -> false
    | Trap_instruction, Fp_disabled -> false
    | Fp_disabled, Division_by_zero -> false
    | Division_by_zero, Fp_disabled -> false
    | Fp_disabled, Tag_overflow -> false
    | Tag_overflow, Fp_disabled -> false
    | Fp_disabled, Data_access_exception -> false
    | Data_access_exception, Fp_disabled -> false
    | Fp_disabled, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Fp_disabled -> false
    | Fp_disabled, Data_access_error -> false
    | Data_access_error, Fp_disabled -> false
    | Fp_disabled, Cp_exception -> false
    | Cp_exception, Fp_disabled -> false
    | Fp_disabled, Fp_exception -> false
    | Fp_exception, Fp_disabled -> false
    | Fp_disabled, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Fp_disabled -> false
    | Fp_disabled, Window_underflow -> false
    | Window_underflow, Fp_disabled -> false
    | Fp_disabled, Window_overflow -> false
    | Window_overflow, Fp_disabled -> false
    | Fp_disabled, Cp_disabled -> false
    | Cp_disabled, Fp_disabled -> false
    | Watchpoint_detected, Interrupt_level_n -> false
    | Interrupt_level_n, Watchpoint_detected -> false
    | Watchpoint_detected, Trap_instruction -> false
    | Trap_instruction, Watchpoint_detected -> false
    | Watchpoint_detected, Division_by_zero -> false
    | Division_by_zero, Watchpoint_detected -> false
    | Watchpoint_detected, Tag_overflow -> false
    | Tag_overflow, Watchpoint_detected -> false
    | Watchpoint_detected, Data_access_exception -> false
    | Data_access_exception, Watchpoint_detected -> false
    | Watchpoint_detected, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Watchpoint_detected -> false
    | Watchpoint_detected, Data_access_error -> false
    | Data_access_error, Watchpoint_detected -> false
    | Watchpoint_detected, Cp_exception -> false
    | Cp_exception, Watchpoint_detected -> false
    | Watchpoint_detected, Fp_exception -> false
    | Fp_exception, Watchpoint_detected -> false
    | Watchpoint_detected, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Watchpoint_detected -> false
    | Watchpoint_detected, Window_underflow -> false
    | Window_underflow, Watchpoint_detected -> false
    | Watchpoint_detected, Window_overflow -> false
    | Window_overflow, Watchpoint_detected -> false
    | Watchpoint_detected, Cp_disabled -> false
    | Cp_disabled, Watchpoint_detected -> false
    | Watchpoint_detected, Fp_disabled -> false
    | Fp_disabled, Watchpoint_detected -> false
    | Unimplemented_FLUSH, Interrupt_level_n -> false
    | Interrupt_level_n, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Trap_instruction -> false
    | Trap_instruction, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Division_by_zero -> false
    | Division_by_zero, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Tag_overflow -> false
    | Tag_overflow, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Data_access_exception -> false
    | Data_access_exception, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Data_access_error -> false
    | Data_access_error, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Cp_exception -> false
    | Cp_exception, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Fp_exception -> false
    | Fp_exception, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Window_underflow -> false
    | Window_underflow, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Window_overflow -> false
    | Window_overflow, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Cp_disabled -> false
    | Cp_disabled, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Fp_disabled -> false
    | Fp_disabled, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Watchpoint_detected -> false
    | Watchpoint_detected, Unimplemented_FLUSH -> false
    | Illegal_instruction, Interrupt_level_n -> false
    | Interrupt_level_n, Illegal_instruction -> false
    | Illegal_instruction, Trap_instruction -> false
    | Trap_instruction, Illegal_instruction -> false
    | Illegal_instruction, Division_by_zero -> false
    | Division_by_zero, Illegal_instruction -> false
    | Illegal_instruction, Tag_overflow -> false
    | Tag_overflow, Illegal_instruction -> false
    | Illegal_instruction, Data_access_exception -> false
    | Data_access_exception, Illegal_instruction -> false
    | Illegal_instruction, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Illegal_instruction -> false
    | Illegal_instruction, Data_access_error -> false
    | Data_access_error, Illegal_instruction -> false
    | Illegal_instruction, Cp_exception -> false
    | Cp_exception, Illegal_instruction -> false
    | Illegal_instruction, Fp_exception -> false
    | Fp_exception, Illegal_instruction -> false
    | Illegal_instruction, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Illegal_instruction -> false
    | Illegal_instruction, Window_underflow -> false
    | Window_underflow, Illegal_instruction -> false
    | Illegal_instruction, Window_overflow -> false
    | Window_overflow, Illegal_instruction -> false
    | Illegal_instruction, Cp_disabled -> false
    | Cp_disabled, Illegal_instruction -> false
    | Illegal_instruction, Fp_disabled -> false
    | Fp_disabled, Illegal_instruction -> false
    | Illegal_instruction, Watchpoint_detected -> false
    | Watchpoint_detected, Illegal_instruction -> false
    | Illegal_instruction, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Illegal_instruction -> false
    | Privileged_instruction, Interrupt_level_n -> false
    | Interrupt_level_n, Privileged_instruction -> false
    | Privileged_instruction, Trap_instruction -> false
    | Trap_instruction, Privileged_instruction -> false
    | Privileged_instruction, Division_by_zero -> false
    | Division_by_zero, Privileged_instruction -> false
    | Privileged_instruction, Tag_overflow -> false
    | Tag_overflow, Privileged_instruction -> false
    | Privileged_instruction, Data_access_exception -> false
    | Data_access_exception, Privileged_instruction -> false
    | Privileged_instruction, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Privileged_instruction -> false
    | Privileged_instruction, Data_access_error -> false
    | Data_access_error, Privileged_instruction -> false
    | Privileged_instruction, Cp_exception -> false
    | Cp_exception, Privileged_instruction -> false
    | Privileged_instruction, Fp_exception -> false
    | Fp_exception, Privileged_instruction -> false
    | Privileged_instruction, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Privileged_instruction -> false
    | Privileged_instruction, Window_underflow -> false
    | Window_underflow, Privileged_instruction -> false
    | Privileged_instruction, Window_overflow -> false
    | Window_overflow, Privileged_instruction -> false
    | Privileged_instruction, Cp_disabled -> false
    | Cp_disabled, Privileged_instruction -> false
    | Privileged_instruction, Fp_disabled -> false
    | Fp_disabled, Privileged_instruction -> false
    | Privileged_instruction, Watchpoint_detected -> false
    | Watchpoint_detected, Privileged_instruction -> false
    | Privileged_instruction, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Privileged_instruction -> false
    | Privileged_instruction, Illegal_instruction -> false
    | Illegal_instruction, Privileged_instruction -> false
    | Instruction_access_exception, Interrupt_level_n -> false
    | Interrupt_level_n, Instruction_access_exception -> false
    | Instruction_access_exception, Trap_instruction -> false
    | Trap_instruction, Instruction_access_exception -> false
    | Instruction_access_exception, Division_by_zero -> false
    | Division_by_zero, Instruction_access_exception -> false
    | Instruction_access_exception, Tag_overflow -> false
    | Tag_overflow, Instruction_access_exception -> false
    | Instruction_access_exception, Data_access_exception -> false
    | Data_access_exception, Instruction_access_exception -> false
    | Instruction_access_exception, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Instruction_access_exception -> false
    | Instruction_access_exception, Data_access_error -> false
    | Data_access_error, Instruction_access_exception -> false
    | Instruction_access_exception, Cp_exception -> false
    | Cp_exception, Instruction_access_exception -> false
    | Instruction_access_exception, Fp_exception -> false
    | Fp_exception, Instruction_access_exception -> false
    | Instruction_access_exception, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Instruction_access_exception -> false
    | Instruction_access_exception, Window_underflow -> false
    | Window_underflow, Instruction_access_exception -> false
    | Instruction_access_exception, Window_overflow -> false
    | Window_overflow, Instruction_access_exception -> false
    | Instruction_access_exception, Cp_disabled -> false
    | Cp_disabled, Instruction_access_exception -> false
    | Instruction_access_exception, Fp_disabled -> false
    | Fp_disabled, Instruction_access_exception -> false
    | Instruction_access_exception, Watchpoint_detected -> false
    | Watchpoint_detected, Instruction_access_exception -> false
    | Instruction_access_exception, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Instruction_access_exception -> false
    | Instruction_access_exception, Illegal_instruction -> false
    | Illegal_instruction, Instruction_access_exception -> false
    | Instruction_access_exception, Privileged_instruction -> false
    | Privileged_instruction, Instruction_access_exception -> false
    | R_register_access_error, Interrupt_level_n -> false
    | Interrupt_level_n, R_register_access_error -> false
    | R_register_access_error, Trap_instruction -> false
    | Trap_instruction, R_register_access_error -> false
    | R_register_access_error, Division_by_zero -> false
    | Division_by_zero, R_register_access_error -> false
    | R_register_access_error, Tag_overflow -> false
    | Tag_overflow, R_register_access_error -> false
    | R_register_access_error, Data_access_exception -> false
    | Data_access_exception, R_register_access_error -> false
    | R_register_access_error, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, R_register_access_error -> false
    | R_register_access_error, Data_access_error -> false
    | Data_access_error, R_register_access_error -> false
    | R_register_access_error, Cp_exception -> false
    | Cp_exception, R_register_access_error -> false
    | R_register_access_error, Fp_exception -> false
    | Fp_exception, R_register_access_error -> false
    | R_register_access_error, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, R_register_access_error -> false
    | R_register_access_error, Window_underflow -> false
    | Window_underflow, R_register_access_error -> false
    | R_register_access_error, Window_overflow -> false
    | Window_overflow, R_register_access_error -> false
    | R_register_access_error, Cp_disabled -> false
    | Cp_disabled, R_register_access_error -> false
    | R_register_access_error, Fp_disabled -> false
    | Fp_disabled, R_register_access_error -> false
    | R_register_access_error, Watchpoint_detected -> false
    | Watchpoint_detected, R_register_access_error -> false
    | R_register_access_error, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, R_register_access_error -> false
    | R_register_access_error, Illegal_instruction -> false
    | Illegal_instruction, R_register_access_error -> false
    | R_register_access_error, Privileged_instruction -> false
    | Privileged_instruction, R_register_access_error -> false
    | R_register_access_error, Instruction_access_exception -> false
    | Instruction_access_exception, R_register_access_error -> false
    | Instruction_access_error, Interrupt_level_n -> false
    | Interrupt_level_n, Instruction_access_error -> false
    | Instruction_access_error, Trap_instruction -> false
    | Trap_instruction, Instruction_access_error -> false
    | Instruction_access_error, Division_by_zero -> false
    | Division_by_zero, Instruction_access_error -> false
    | Instruction_access_error, Tag_overflow -> false
    | Tag_overflow, Instruction_access_error -> false
    | Instruction_access_error, Data_access_exception -> false
    | Data_access_exception, Instruction_access_error -> false
    | Instruction_access_error, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Instruction_access_error -> false
    | Instruction_access_error, Data_access_error -> false
    | Data_access_error, Instruction_access_error -> false
    | Instruction_access_error, Cp_exception -> false
    | Cp_exception, Instruction_access_error -> false
    | Instruction_access_error, Fp_exception -> false
    | Fp_exception, Instruction_access_error -> false
    | Instruction_access_error, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Instruction_access_error -> false
    | Instruction_access_error, Window_underflow -> false
    | Window_underflow, Instruction_access_error -> false
    | Instruction_access_error, Window_overflow -> false
    | Window_overflow, Instruction_access_error -> false
    | Instruction_access_error, Cp_disabled -> false
    | Cp_disabled, Instruction_access_error -> false
    | Instruction_access_error, Fp_disabled -> false
    | Fp_disabled, Instruction_access_error -> false
    | Instruction_access_error, Watchpoint_detected -> false
    | Watchpoint_detected, Instruction_access_error -> false
    | Instruction_access_error, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Instruction_access_error -> false
    | Instruction_access_error, Illegal_instruction -> false
    | Illegal_instruction, Instruction_access_error -> false
    | Instruction_access_error, Privileged_instruction -> false
    | Privileged_instruction, Instruction_access_error -> false
    | Instruction_access_error, Instruction_access_exception -> false
    | Instruction_access_exception, Instruction_access_error -> false
    | Instruction_access_error, R_register_access_error -> false
    | R_register_access_error, Instruction_access_error -> false
    | Instruction_access_MMU_miss, Interrupt_level_n -> false
    | Interrupt_level_n, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Trap_instruction -> false
    | Trap_instruction, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Division_by_zero -> false
    | Division_by_zero, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Tag_overflow -> false
    | Tag_overflow, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Data_access_exception -> false
    | Data_access_exception, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Data_access_error -> false
    | Data_access_error, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Cp_exception -> false
    | Cp_exception, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Fp_exception -> false
    | Fp_exception, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Window_underflow -> false
    | Window_underflow, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Window_overflow -> false
    | Window_overflow, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Cp_disabled -> false
    | Cp_disabled, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Fp_disabled -> false
    | Fp_disabled, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Watchpoint_detected -> false
    | Watchpoint_detected, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Illegal_instruction -> false
    | Illegal_instruction, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Privileged_instruction -> false
    | Privileged_instruction, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Instruction_access_exception -> false
    | Instruction_access_exception, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, R_register_access_error -> false
    | R_register_access_error, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Instruction_access_error -> false
    | Instruction_access_error, Instruction_access_MMU_miss -> false
    | Data_store_error, Interrupt_level_n -> false
    | Interrupt_level_n, Data_store_error -> false
    | Data_store_error, Trap_instruction -> false
    | Trap_instruction, Data_store_error -> false
    | Data_store_error, Division_by_zero -> false
    | Division_by_zero, Data_store_error -> false
    | Data_store_error, Tag_overflow -> false
    | Tag_overflow, Data_store_error -> false
    | Data_store_error, Data_access_exception -> false
    | Data_access_exception, Data_store_error -> false
    | Data_store_error, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Data_store_error -> false
    | Data_store_error, Data_access_error -> false
    | Data_access_error, Data_store_error -> false
    | Data_store_error, Cp_exception -> false
    | Cp_exception, Data_store_error -> false
    | Data_store_error, Fp_exception -> false
    | Fp_exception, Data_store_error -> false
    | Data_store_error, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Data_store_error -> false
    | Data_store_error, Window_underflow -> false
    | Window_underflow, Data_store_error -> false
    | Data_store_error, Window_overflow -> false
    | Window_overflow, Data_store_error -> false
    | Data_store_error, Cp_disabled -> false
    | Cp_disabled, Data_store_error -> false
    | Data_store_error, Fp_disabled -> false
    | Fp_disabled, Data_store_error -> false
    | Data_store_error, Watchpoint_detected -> false
    | Watchpoint_detected, Data_store_error -> false
    | Data_store_error, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Data_store_error -> false
    | Data_store_error, Illegal_instruction -> false
    | Illegal_instruction, Data_store_error -> false
    | Data_store_error, Privileged_instruction -> false
    | Privileged_instruction, Data_store_error -> false
    | Data_store_error, Instruction_access_exception -> false
    | Instruction_access_exception, Data_store_error -> false
    | Data_store_error, R_register_access_error -> false
    | R_register_access_error, Data_store_error -> false
    | Data_store_error, Instruction_access_error -> false
    | Instruction_access_error, Data_store_error -> false
    | Data_store_error, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Data_store_error -> false
    | Reset, Interrupt_level_n -> false
    | Interrupt_level_n, Reset -> false
    | Reset, Trap_instruction -> false
    | Trap_instruction, Reset -> false
    | Reset, Division_by_zero -> false
    | Division_by_zero, Reset -> false
    | Reset, Tag_overflow -> false
    | Tag_overflow, Reset -> false
    | Reset, Data_access_exception -> false
    | Data_access_exception, Reset -> false
    | Reset, Data_access_MMU_miss -> false
    | Data_access_MMU_miss, Reset -> false
    | Reset, Data_access_error -> false
    | Data_access_error, Reset -> false
    | Reset, Cp_exception -> false
    | Cp_exception, Reset -> false
    | Reset, Fp_exception -> false
    | Fp_exception, Reset -> false
    | Reset, Mem_address_not_aligned -> false
    | Mem_address_not_aligned, Reset -> false
    | Reset, Window_underflow -> false
    | Window_underflow, Reset -> false
    | Reset, Window_overflow -> false
    | Window_overflow, Reset -> false
    | Reset, Cp_disabled -> false
    | Cp_disabled, Reset -> false
    | Reset, Fp_disabled -> false
    | Fp_disabled, Reset -> false
    | Reset, Watchpoint_detected -> false
    | Watchpoint_detected, Reset -> false
    | Reset, Unimplemented_FLUSH -> false
    | Unimplemented_FLUSH, Reset -> false
    | Reset, Illegal_instruction -> false
    | Illegal_instruction, Reset -> false
    | Reset, Privileged_instruction -> false
    | Privileged_instruction, Reset -> false
    | Reset, Instruction_access_exception -> false
    | Instruction_access_exception, Reset -> false
    | Reset, R_register_access_error -> false
    | R_register_access_error, Reset -> false
    | Reset, Instruction_access_error -> false
    | Instruction_access_error, Reset -> false
    | Reset, Instruction_access_MMU_miss -> false
    | Instruction_access_MMU_miss, Reset -> false
    | Reset, Data_store_error -> false
    | Data_store_error, Reset -> false
    | Interrupt_level_n, Interrupt_level_n -> true
    | Trap_instruction, Trap_instruction -> true
    | Division_by_zero, Division_by_zero -> true
    | Tag_overflow, Tag_overflow -> true
    | Data_access_exception, Data_access_exception -> true
    | Data_access_MMU_miss, Data_access_MMU_miss -> true
    | Data_access_error, Data_access_error -> true
    | Cp_exception, Cp_exception -> true
    | Fp_exception, Fp_exception -> true
    | Mem_address_not_aligned, Mem_address_not_aligned -> true
    | Window_underflow, Window_underflow -> true
    | Window_overflow, Window_overflow -> true
    | Cp_disabled, Cp_disabled -> true
    | Fp_disabled, Fp_disabled -> true
    | Watchpoint_detected, Watchpoint_detected -> true
    | Unimplemented_FLUSH, Unimplemented_FLUSH -> true
    | Illegal_instruction, Illegal_instruction -> true
    | Privileged_instruction, Privileged_instruction -> true
    | Instruction_access_exception, Instruction_access_exception -> true
    | R_register_access_error, R_register_access_error -> true
    | Instruction_access_error, Instruction_access_error -> true
    | Instruction_access_MMU_miss, Instruction_access_MMU_miss -> true
    | Data_store_error, Data_store_error -> true
    | Reset, Reset -> true;;

let equal_Trap = ({equal = equal_Trapa} : trap equal);;

let rec eq _A a b = equal _A a b;;

let rec equal_proda _A _B (x1, x2) (y1, y2) = eq _A x1 y1 && eq _B x2 y2;;

let rec equal_prod _A _B = ({equal = equal_proda _A _B} : ('a * 'b) equal);;

type sys_reg = CCR | ICCR | DCCR;;

let rec equal_sys_rega x0 x1 = match x0, x1 with ICCR, DCCR -> false
                         | DCCR, ICCR -> false
                         | CCR, DCCR -> false
                         | DCCR, CCR -> false
                         | CCR, ICCR -> false
                         | ICCR, CCR -> false
                         | DCCR, DCCR -> true
                         | ICCR, ICCR -> true
                         | CCR, CCR -> true;;

let equal_sys_reg = ({equal = equal_sys_rega} : sys_reg equal);;

let one_nat : nat = Suc Zero_nat;;

type word_length1 = EMPTY__;;

let rec len_of_word_length1 x = one_nat;;

let len0_word_length1 = ({len_of = len_of_word_length1} : word_length1 len0);;

let rec plus_nat x0 n = match x0, n with Suc m, n -> plus_nat m (Suc n)
                   | Zero_nat, n -> n;;

let rec nat_of_num
  = function Bit1 n -> (let m = nat_of_num n in Suc (plus_nat m m))
    | Bit0 n -> (let m = nat_of_num n in plus_nat m m)
    | One -> one_nat;;

type word_length2 = EMPTY__;;

let rec len_of_word_length2 x = nat_of_num (Bit0 One);;

let len0_word_length2 = ({len_of = len_of_word_length2} : word_length2 len0);;

type word_length3 = EMPTY__;;

let rec len_of_word_length3 x = nat_of_num (Bit1 One);;

let len0_word_length3 = ({len_of = len_of_word_length3} : word_length3 len0);;

type word_length4 = EMPTY__;;

let rec len_of_word_length4 x = nat_of_num (Bit0 (Bit0 One));;

let len0_word_length4 = ({len_of = len_of_word_length4} : word_length4 len0);;

type word_length5 = EMPTY__;;

let rec len_of_word_length5 x = nat_of_num (Bit1 (Bit0 One));;

let len0_word_length5 = ({len_of = len_of_word_length5} : word_length5 len0);;

type word_length6 = EMPTY__;;

let rec len_of_word_length6 x = nat_of_num (Bit0 (Bit1 One));;

let len0_word_length6 = ({len_of = len_of_word_length6} : word_length6 len0);;

type word_length7 = EMPTY__;;

let rec len_of_word_length7 x = nat_of_num (Bit1 (Bit1 One));;

let len0_word_length7 = ({len_of = len_of_word_length7} : word_length7 len0);;

type word_length8 = EMPTY__;;

let rec len_of_word_length8 x = nat_of_num (Bit0 (Bit0 (Bit0 One)));;

let len0_word_length8 = ({len_of = len_of_word_length8} : word_length8 len0);;

type word_length12 = EMPTY__;;

let rec len_of_word_length12 x = nat_of_num (Bit0 (Bit0 (Bit1 One)));;

let len0_word_length12 =
  ({len_of = len_of_word_length12} : word_length12 len0);;

type word_length13 = EMPTY__;;

let rec len_of_word_length13 x = nat_of_num (Bit1 (Bit0 (Bit1 One)));;

let len0_word_length13 =
  ({len_of = len_of_word_length13} : word_length13 len0);;

type word_length16 = EMPTY__;;

let rec len_of_word_length16 x = nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One))));;

let len0_word_length16 =
  ({len_of = len_of_word_length16} : word_length16 len0);;

type word_length20 = EMPTY__;;

let rec len_of_word_length20 x = nat_of_num (Bit0 (Bit0 (Bit1 (Bit0 One))));;

let len0_word_length20 =
  ({len_of = len_of_word_length20} : word_length20 len0);;

type word_length22 = EMPTY__;;

let rec len_of_word_length22 x = nat_of_num (Bit0 (Bit1 (Bit1 (Bit0 One))));;

let len0_word_length22 =
  ({len_of = len_of_word_length22} : word_length22 len0);;

type word_length24 = EMPTY__;;

let rec len_of_word_length24 x = nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))));;

let len0_word_length24 =
  ({len_of = len_of_word_length24} : word_length24 len0);;

type word_length30 = EMPTY__;;

let rec len_of_word_length30 x = nat_of_num (Bit0 (Bit1 (Bit1 (Bit1 One))));;

let len0_word_length30 =
  ({len_of = len_of_word_length30} : word_length30 len0);;

type word_length32 = EMPTY__;;

let rec len_of_word_length32
  x = nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))));;

type 'a len = {len0_len : 'a len0};;

let len0_word_length32 =
  ({len_of = len_of_word_length32} : word_length32 len0);;

let len_word_length32 = ({len0_len = len0_word_length32} : word_length32 len);;

type word_length33 = EMPTY__;;

let rec len_of_word_length33
  x = nat_of_num (Bit1 (Bit0 (Bit0 (Bit0 (Bit0 One)))));;

let len0_word_length33 =
  ({len_of = len_of_word_length33} : word_length33 len0);;

type word_length36 = EMPTY__;;

let rec len_of_word_length36
  x = nat_of_num (Bit0 (Bit0 (Bit1 (Bit0 (Bit0 One)))));;

let len0_word_length36 =
  ({len_of = len_of_word_length36} : word_length36 len0);;

type word_length64 = EMPTY__;;

let rec len_of_word_length64
  x = nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))));;

let len0_word_length64 =
  ({len_of = len_of_word_length64} : word_length64 len0);;

let len_word_length64 = ({len0_len = len0_word_length64} : word_length64 len);;

type cPU_register = PSR | WIM | TBR | Y | PC | NPC | DTQ | FSR | FQ | CSR | CQ |
  ASR of word_length5 word;;

let rec equal_CPU_registera
  x0 x1 = match x0, x1 with CQ, ASR x12 -> false
    | ASR x12, CQ -> false
    | CSR, ASR x12 -> false
    | ASR x12, CSR -> false
    | CSR, CQ -> false
    | CQ, CSR -> false
    | FQ, ASR x12 -> false
    | ASR x12, FQ -> false
    | FQ, CQ -> false
    | CQ, FQ -> false
    | FQ, CSR -> false
    | CSR, FQ -> false
    | FSR, ASR x12 -> false
    | ASR x12, FSR -> false
    | FSR, CQ -> false
    | CQ, FSR -> false
    | FSR, CSR -> false
    | CSR, FSR -> false
    | FSR, FQ -> false
    | FQ, FSR -> false
    | DTQ, ASR x12 -> false
    | ASR x12, DTQ -> false
    | DTQ, CQ -> false
    | CQ, DTQ -> false
    | DTQ, CSR -> false
    | CSR, DTQ -> false
    | DTQ, FQ -> false
    | FQ, DTQ -> false
    | DTQ, FSR -> false
    | FSR, DTQ -> false
    | NPC, ASR x12 -> false
    | ASR x12, NPC -> false
    | NPC, CQ -> false
    | CQ, NPC -> false
    | NPC, CSR -> false
    | CSR, NPC -> false
    | NPC, FQ -> false
    | FQ, NPC -> false
    | NPC, FSR -> false
    | FSR, NPC -> false
    | NPC, DTQ -> false
    | DTQ, NPC -> false
    | PC, ASR x12 -> false
    | ASR x12, PC -> false
    | PC, CQ -> false
    | CQ, PC -> false
    | PC, CSR -> false
    | CSR, PC -> false
    | PC, FQ -> false
    | FQ, PC -> false
    | PC, FSR -> false
    | FSR, PC -> false
    | PC, DTQ -> false
    | DTQ, PC -> false
    | PC, NPC -> false
    | NPC, PC -> false
    | Y, ASR x12 -> false
    | ASR x12, Y -> false
    | Y, CQ -> false
    | CQ, Y -> false
    | Y, CSR -> false
    | CSR, Y -> false
    | Y, FQ -> false
    | FQ, Y -> false
    | Y, FSR -> false
    | FSR, Y -> false
    | Y, DTQ -> false
    | DTQ, Y -> false
    | Y, NPC -> false
    | NPC, Y -> false
    | Y, PC -> false
    | PC, Y -> false
    | TBR, ASR x12 -> false
    | ASR x12, TBR -> false
    | TBR, CQ -> false
    | CQ, TBR -> false
    | TBR, CSR -> false
    | CSR, TBR -> false
    | TBR, FQ -> false
    | FQ, TBR -> false
    | TBR, FSR -> false
    | FSR, TBR -> false
    | TBR, DTQ -> false
    | DTQ, TBR -> false
    | TBR, NPC -> false
    | NPC, TBR -> false
    | TBR, PC -> false
    | PC, TBR -> false
    | TBR, Y -> false
    | Y, TBR -> false
    | WIM, ASR x12 -> false
    | ASR x12, WIM -> false
    | WIM, CQ -> false
    | CQ, WIM -> false
    | WIM, CSR -> false
    | CSR, WIM -> false
    | WIM, FQ -> false
    | FQ, WIM -> false
    | WIM, FSR -> false
    | FSR, WIM -> false
    | WIM, DTQ -> false
    | DTQ, WIM -> false
    | WIM, NPC -> false
    | NPC, WIM -> false
    | WIM, PC -> false
    | PC, WIM -> false
    | WIM, Y -> false
    | Y, WIM -> false
    | WIM, TBR -> false
    | TBR, WIM -> false
    | PSR, ASR x12 -> false
    | ASR x12, PSR -> false
    | PSR, CQ -> false
    | CQ, PSR -> false
    | PSR, CSR -> false
    | CSR, PSR -> false
    | PSR, FQ -> false
    | FQ, PSR -> false
    | PSR, FSR -> false
    | FSR, PSR -> false
    | PSR, DTQ -> false
    | DTQ, PSR -> false
    | PSR, NPC -> false
    | NPC, PSR -> false
    | PSR, PC -> false
    | PC, PSR -> false
    | PSR, Y -> false
    | Y, PSR -> false
    | PSR, TBR -> false
    | TBR, PSR -> false
    | PSR, WIM -> false
    | WIM, PSR -> false
    | ASR x12, ASR y12 -> equal_worda len0_word_length5 x12 y12
    | CQ, CQ -> true
    | CSR, CSR -> true
    | FQ, FQ -> true
    | FSR, FSR -> true
    | DTQ, DTQ -> true
    | NPC, NPC -> true
    | PC, PC -> true
    | Y, Y -> true
    | TBR, TBR -> true
    | WIM, WIM -> true
    | PSR, PSR -> true;;

let equal_CPU_register = ({equal = equal_CPU_registera} : cPU_register equal);;

type mMU_register = CR | CTP | CNR | FTSR | FAR;;

let rec equal_MMU_registera x0 x1 = match x0, x1 with FTSR, FAR -> false
                              | FAR, FTSR -> false
                              | CNR, FAR -> false
                              | FAR, CNR -> false
                              | CNR, FTSR -> false
                              | FTSR, CNR -> false
                              | CTP, FAR -> false
                              | FAR, CTP -> false
                              | CTP, FTSR -> false
                              | FTSR, CTP -> false
                              | CTP, CNR -> false
                              | CNR, CTP -> false
                              | CR, FAR -> false
                              | FAR, CR -> false
                              | CR, FTSR -> false
                              | FTSR, CR -> false
                              | CR, CNR -> false
                              | CNR, CR -> false
                              | CR, CTP -> false
                              | CTP, CR -> false
                              | FAR, FAR -> true
                              | FTSR, FTSR -> true
                              | CNR, CNR -> true
                              | CTP, CTP -> true
                              | CR, CR -> true;;

let equal_MMU_register = ({equal = equal_MMU_registera} : mMU_register equal);;

type load_store_type = LDSB | LDUB | LDUBA | LDUH | LD | LDA | LDD | STB | STH |
  ST | STA | STD | LDSBA | LDSH | LDSHA | LDUHA | LDDA | STBA | STHA | STDA |
  LDSTUB | LDSTUBA | SWAP | SWAPA | FLUSH | STBAR | CASA | CASXA;;

let rec equal_load_store_type x0 x1 = match x0, x1 with CASA, CASXA -> false
                                | CASXA, CASA -> false
                                | STBAR, CASXA -> false
                                | CASXA, STBAR -> false
                                | STBAR, CASA -> false
                                | CASA, STBAR -> false
                                | FLUSH, CASXA -> false
                                | CASXA, FLUSH -> false
                                | FLUSH, CASA -> false
                                | CASA, FLUSH -> false
                                | FLUSH, STBAR -> false
                                | STBAR, FLUSH -> false
                                | SWAPA, CASXA -> false
                                | CASXA, SWAPA -> false
                                | SWAPA, CASA -> false
                                | CASA, SWAPA -> false
                                | SWAPA, STBAR -> false
                                | STBAR, SWAPA -> false
                                | SWAPA, FLUSH -> false
                                | FLUSH, SWAPA -> false
                                | SWAP, CASXA -> false
                                | CASXA, SWAP -> false
                                | SWAP, CASA -> false
                                | CASA, SWAP -> false
                                | SWAP, STBAR -> false
                                | STBAR, SWAP -> false
                                | SWAP, FLUSH -> false
                                | FLUSH, SWAP -> false
                                | SWAP, SWAPA -> false
                                | SWAPA, SWAP -> false
                                | LDSTUBA, CASXA -> false
                                | CASXA, LDSTUBA -> false
                                | LDSTUBA, CASA -> false
                                | CASA, LDSTUBA -> false
                                | LDSTUBA, STBAR -> false
                                | STBAR, LDSTUBA -> false
                                | LDSTUBA, FLUSH -> false
                                | FLUSH, LDSTUBA -> false
                                | LDSTUBA, SWAPA -> false
                                | SWAPA, LDSTUBA -> false
                                | LDSTUBA, SWAP -> false
                                | SWAP, LDSTUBA -> false
                                | LDSTUB, CASXA -> false
                                | CASXA, LDSTUB -> false
                                | LDSTUB, CASA -> false
                                | CASA, LDSTUB -> false
                                | LDSTUB, STBAR -> false
                                | STBAR, LDSTUB -> false
                                | LDSTUB, FLUSH -> false
                                | FLUSH, LDSTUB -> false
                                | LDSTUB, SWAPA -> false
                                | SWAPA, LDSTUB -> false
                                | LDSTUB, SWAP -> false
                                | SWAP, LDSTUB -> false
                                | LDSTUB, LDSTUBA -> false
                                | LDSTUBA, LDSTUB -> false
                                | STDA, CASXA -> false
                                | CASXA, STDA -> false
                                | STDA, CASA -> false
                                | CASA, STDA -> false
                                | STDA, STBAR -> false
                                | STBAR, STDA -> false
                                | STDA, FLUSH -> false
                                | FLUSH, STDA -> false
                                | STDA, SWAPA -> false
                                | SWAPA, STDA -> false
                                | STDA, SWAP -> false
                                | SWAP, STDA -> false
                                | STDA, LDSTUBA -> false
                                | LDSTUBA, STDA -> false
                                | STDA, LDSTUB -> false
                                | LDSTUB, STDA -> false
                                | STHA, CASXA -> false
                                | CASXA, STHA -> false
                                | STHA, CASA -> false
                                | CASA, STHA -> false
                                | STHA, STBAR -> false
                                | STBAR, STHA -> false
                                | STHA, FLUSH -> false
                                | FLUSH, STHA -> false
                                | STHA, SWAPA -> false
                                | SWAPA, STHA -> false
                                | STHA, SWAP -> false
                                | SWAP, STHA -> false
                                | STHA, LDSTUBA -> false
                                | LDSTUBA, STHA -> false
                                | STHA, LDSTUB -> false
                                | LDSTUB, STHA -> false
                                | STHA, STDA -> false
                                | STDA, STHA -> false
                                | STBA, CASXA -> false
                                | CASXA, STBA -> false
                                | STBA, CASA -> false
                                | CASA, STBA -> false
                                | STBA, STBAR -> false
                                | STBAR, STBA -> false
                                | STBA, FLUSH -> false
                                | FLUSH, STBA -> false
                                | STBA, SWAPA -> false
                                | SWAPA, STBA -> false
                                | STBA, SWAP -> false
                                | SWAP, STBA -> false
                                | STBA, LDSTUBA -> false
                                | LDSTUBA, STBA -> false
                                | STBA, LDSTUB -> false
                                | LDSTUB, STBA -> false
                                | STBA, STDA -> false
                                | STDA, STBA -> false
                                | STBA, STHA -> false
                                | STHA, STBA -> false
                                | LDDA, CASXA -> false
                                | CASXA, LDDA -> false
                                | LDDA, CASA -> false
                                | CASA, LDDA -> false
                                | LDDA, STBAR -> false
                                | STBAR, LDDA -> false
                                | LDDA, FLUSH -> false
                                | FLUSH, LDDA -> false
                                | LDDA, SWAPA -> false
                                | SWAPA, LDDA -> false
                                | LDDA, SWAP -> false
                                | SWAP, LDDA -> false
                                | LDDA, LDSTUBA -> false
                                | LDSTUBA, LDDA -> false
                                | LDDA, LDSTUB -> false
                                | LDSTUB, LDDA -> false
                                | LDDA, STDA -> false
                                | STDA, LDDA -> false
                                | LDDA, STHA -> false
                                | STHA, LDDA -> false
                                | LDDA, STBA -> false
                                | STBA, LDDA -> false
                                | LDUHA, CASXA -> false
                                | CASXA, LDUHA -> false
                                | LDUHA, CASA -> false
                                | CASA, LDUHA -> false
                                | LDUHA, STBAR -> false
                                | STBAR, LDUHA -> false
                                | LDUHA, FLUSH -> false
                                | FLUSH, LDUHA -> false
                                | LDUHA, SWAPA -> false
                                | SWAPA, LDUHA -> false
                                | LDUHA, SWAP -> false
                                | SWAP, LDUHA -> false
                                | LDUHA, LDSTUBA -> false
                                | LDSTUBA, LDUHA -> false
                                | LDUHA, LDSTUB -> false
                                | LDSTUB, LDUHA -> false
                                | LDUHA, STDA -> false
                                | STDA, LDUHA -> false
                                | LDUHA, STHA -> false
                                | STHA, LDUHA -> false
                                | LDUHA, STBA -> false
                                | STBA, LDUHA -> false
                                | LDUHA, LDDA -> false
                                | LDDA, LDUHA -> false
                                | LDSHA, CASXA -> false
                                | CASXA, LDSHA -> false
                                | LDSHA, CASA -> false
                                | CASA, LDSHA -> false
                                | LDSHA, STBAR -> false
                                | STBAR, LDSHA -> false
                                | LDSHA, FLUSH -> false
                                | FLUSH, LDSHA -> false
                                | LDSHA, SWAPA -> false
                                | SWAPA, LDSHA -> false
                                | LDSHA, SWAP -> false
                                | SWAP, LDSHA -> false
                                | LDSHA, LDSTUBA -> false
                                | LDSTUBA, LDSHA -> false
                                | LDSHA, LDSTUB -> false
                                | LDSTUB, LDSHA -> false
                                | LDSHA, STDA -> false
                                | STDA, LDSHA -> false
                                | LDSHA, STHA -> false
                                | STHA, LDSHA -> false
                                | LDSHA, STBA -> false
                                | STBA, LDSHA -> false
                                | LDSHA, LDDA -> false
                                | LDDA, LDSHA -> false
                                | LDSHA, LDUHA -> false
                                | LDUHA, LDSHA -> false
                                | LDSH, CASXA -> false
                                | CASXA, LDSH -> false
                                | LDSH, CASA -> false
                                | CASA, LDSH -> false
                                | LDSH, STBAR -> false
                                | STBAR, LDSH -> false
                                | LDSH, FLUSH -> false
                                | FLUSH, LDSH -> false
                                | LDSH, SWAPA -> false
                                | SWAPA, LDSH -> false
                                | LDSH, SWAP -> false
                                | SWAP, LDSH -> false
                                | LDSH, LDSTUBA -> false
                                | LDSTUBA, LDSH -> false
                                | LDSH, LDSTUB -> false
                                | LDSTUB, LDSH -> false
                                | LDSH, STDA -> false
                                | STDA, LDSH -> false
                                | LDSH, STHA -> false
                                | STHA, LDSH -> false
                                | LDSH, STBA -> false
                                | STBA, LDSH -> false
                                | LDSH, LDDA -> false
                                | LDDA, LDSH -> false
                                | LDSH, LDUHA -> false
                                | LDUHA, LDSH -> false
                                | LDSH, LDSHA -> false
                                | LDSHA, LDSH -> false
                                | LDSBA, CASXA -> false
                                | CASXA, LDSBA -> false
                                | LDSBA, CASA -> false
                                | CASA, LDSBA -> false
                                | LDSBA, STBAR -> false
                                | STBAR, LDSBA -> false
                                | LDSBA, FLUSH -> false
                                | FLUSH, LDSBA -> false
                                | LDSBA, SWAPA -> false
                                | SWAPA, LDSBA -> false
                                | LDSBA, SWAP -> false
                                | SWAP, LDSBA -> false
                                | LDSBA, LDSTUBA -> false
                                | LDSTUBA, LDSBA -> false
                                | LDSBA, LDSTUB -> false
                                | LDSTUB, LDSBA -> false
                                | LDSBA, STDA -> false
                                | STDA, LDSBA -> false
                                | LDSBA, STHA -> false
                                | STHA, LDSBA -> false
                                | LDSBA, STBA -> false
                                | STBA, LDSBA -> false
                                | LDSBA, LDDA -> false
                                | LDDA, LDSBA -> false
                                | LDSBA, LDUHA -> false
                                | LDUHA, LDSBA -> false
                                | LDSBA, LDSHA -> false
                                | LDSHA, LDSBA -> false
                                | LDSBA, LDSH -> false
                                | LDSH, LDSBA -> false
                                | STD, CASXA -> false
                                | CASXA, STD -> false
                                | STD, CASA -> false
                                | CASA, STD -> false
                                | STD, STBAR -> false
                                | STBAR, STD -> false
                                | STD, FLUSH -> false
                                | FLUSH, STD -> false
                                | STD, SWAPA -> false
                                | SWAPA, STD -> false
                                | STD, SWAP -> false
                                | SWAP, STD -> false
                                | STD, LDSTUBA -> false
                                | LDSTUBA, STD -> false
                                | STD, LDSTUB -> false
                                | LDSTUB, STD -> false
                                | STD, STDA -> false
                                | STDA, STD -> false
                                | STD, STHA -> false
                                | STHA, STD -> false
                                | STD, STBA -> false
                                | STBA, STD -> false
                                | STD, LDDA -> false
                                | LDDA, STD -> false
                                | STD, LDUHA -> false
                                | LDUHA, STD -> false
                                | STD, LDSHA -> false
                                | LDSHA, STD -> false
                                | STD, LDSH -> false
                                | LDSH, STD -> false
                                | STD, LDSBA -> false
                                | LDSBA, STD -> false
                                | STA, CASXA -> false
                                | CASXA, STA -> false
                                | STA, CASA -> false
                                | CASA, STA -> false
                                | STA, STBAR -> false
                                | STBAR, STA -> false
                                | STA, FLUSH -> false
                                | FLUSH, STA -> false
                                | STA, SWAPA -> false
                                | SWAPA, STA -> false
                                | STA, SWAP -> false
                                | SWAP, STA -> false
                                | STA, LDSTUBA -> false
                                | LDSTUBA, STA -> false
                                | STA, LDSTUB -> false
                                | LDSTUB, STA -> false
                                | STA, STDA -> false
                                | STDA, STA -> false
                                | STA, STHA -> false
                                | STHA, STA -> false
                                | STA, STBA -> false
                                | STBA, STA -> false
                                | STA, LDDA -> false
                                | LDDA, STA -> false
                                | STA, LDUHA -> false
                                | LDUHA, STA -> false
                                | STA, LDSHA -> false
                                | LDSHA, STA -> false
                                | STA, LDSH -> false
                                | LDSH, STA -> false
                                | STA, LDSBA -> false
                                | LDSBA, STA -> false
                                | STA, STD -> false
                                | STD, STA -> false
                                | ST, CASXA -> false
                                | CASXA, ST -> false
                                | ST, CASA -> false
                                | CASA, ST -> false
                                | ST, STBAR -> false
                                | STBAR, ST -> false
                                | ST, FLUSH -> false
                                | FLUSH, ST -> false
                                | ST, SWAPA -> false
                                | SWAPA, ST -> false
                                | ST, SWAP -> false
                                | SWAP, ST -> false
                                | ST, LDSTUBA -> false
                                | LDSTUBA, ST -> false
                                | ST, LDSTUB -> false
                                | LDSTUB, ST -> false
                                | ST, STDA -> false
                                | STDA, ST -> false
                                | ST, STHA -> false
                                | STHA, ST -> false
                                | ST, STBA -> false
                                | STBA, ST -> false
                                | ST, LDDA -> false
                                | LDDA, ST -> false
                                | ST, LDUHA -> false
                                | LDUHA, ST -> false
                                | ST, LDSHA -> false
                                | LDSHA, ST -> false
                                | ST, LDSH -> false
                                | LDSH, ST -> false
                                | ST, LDSBA -> false
                                | LDSBA, ST -> false
                                | ST, STD -> false
                                | STD, ST -> false
                                | ST, STA -> false
                                | STA, ST -> false
                                | STH, CASXA -> false
                                | CASXA, STH -> false
                                | STH, CASA -> false
                                | CASA, STH -> false
                                | STH, STBAR -> false
                                | STBAR, STH -> false
                                | STH, FLUSH -> false
                                | FLUSH, STH -> false
                                | STH, SWAPA -> false
                                | SWAPA, STH -> false
                                | STH, SWAP -> false
                                | SWAP, STH -> false
                                | STH, LDSTUBA -> false
                                | LDSTUBA, STH -> false
                                | STH, LDSTUB -> false
                                | LDSTUB, STH -> false
                                | STH, STDA -> false
                                | STDA, STH -> false
                                | STH, STHA -> false
                                | STHA, STH -> false
                                | STH, STBA -> false
                                | STBA, STH -> false
                                | STH, LDDA -> false
                                | LDDA, STH -> false
                                | STH, LDUHA -> false
                                | LDUHA, STH -> false
                                | STH, LDSHA -> false
                                | LDSHA, STH -> false
                                | STH, LDSH -> false
                                | LDSH, STH -> false
                                | STH, LDSBA -> false
                                | LDSBA, STH -> false
                                | STH, STD -> false
                                | STD, STH -> false
                                | STH, STA -> false
                                | STA, STH -> false
                                | STH, ST -> false
                                | ST, STH -> false
                                | STB, CASXA -> false
                                | CASXA, STB -> false
                                | STB, CASA -> false
                                | CASA, STB -> false
                                | STB, STBAR -> false
                                | STBAR, STB -> false
                                | STB, FLUSH -> false
                                | FLUSH, STB -> false
                                | STB, SWAPA -> false
                                | SWAPA, STB -> false
                                | STB, SWAP -> false
                                | SWAP, STB -> false
                                | STB, LDSTUBA -> false
                                | LDSTUBA, STB -> false
                                | STB, LDSTUB -> false
                                | LDSTUB, STB -> false
                                | STB, STDA -> false
                                | STDA, STB -> false
                                | STB, STHA -> false
                                | STHA, STB -> false
                                | STB, STBA -> false
                                | STBA, STB -> false
                                | STB, LDDA -> false
                                | LDDA, STB -> false
                                | STB, LDUHA -> false
                                | LDUHA, STB -> false
                                | STB, LDSHA -> false
                                | LDSHA, STB -> false
                                | STB, LDSH -> false
                                | LDSH, STB -> false
                                | STB, LDSBA -> false
                                | LDSBA, STB -> false
                                | STB, STD -> false
                                | STD, STB -> false
                                | STB, STA -> false
                                | STA, STB -> false
                                | STB, ST -> false
                                | ST, STB -> false
                                | STB, STH -> false
                                | STH, STB -> false
                                | LDD, CASXA -> false
                                | CASXA, LDD -> false
                                | LDD, CASA -> false
                                | CASA, LDD -> false
                                | LDD, STBAR -> false
                                | STBAR, LDD -> false
                                | LDD, FLUSH -> false
                                | FLUSH, LDD -> false
                                | LDD, SWAPA -> false
                                | SWAPA, LDD -> false
                                | LDD, SWAP -> false
                                | SWAP, LDD -> false
                                | LDD, LDSTUBA -> false
                                | LDSTUBA, LDD -> false
                                | LDD, LDSTUB -> false
                                | LDSTUB, LDD -> false
                                | LDD, STDA -> false
                                | STDA, LDD -> false
                                | LDD, STHA -> false
                                | STHA, LDD -> false
                                | LDD, STBA -> false
                                | STBA, LDD -> false
                                | LDD, LDDA -> false
                                | LDDA, LDD -> false
                                | LDD, LDUHA -> false
                                | LDUHA, LDD -> false
                                | LDD, LDSHA -> false
                                | LDSHA, LDD -> false
                                | LDD, LDSH -> false
                                | LDSH, LDD -> false
                                | LDD, LDSBA -> false
                                | LDSBA, LDD -> false
                                | LDD, STD -> false
                                | STD, LDD -> false
                                | LDD, STA -> false
                                | STA, LDD -> false
                                | LDD, ST -> false
                                | ST, LDD -> false
                                | LDD, STH -> false
                                | STH, LDD -> false
                                | LDD, STB -> false
                                | STB, LDD -> false
                                | LDA, CASXA -> false
                                | CASXA, LDA -> false
                                | LDA, CASA -> false
                                | CASA, LDA -> false
                                | LDA, STBAR -> false
                                | STBAR, LDA -> false
                                | LDA, FLUSH -> false
                                | FLUSH, LDA -> false
                                | LDA, SWAPA -> false
                                | SWAPA, LDA -> false
                                | LDA, SWAP -> false
                                | SWAP, LDA -> false
                                | LDA, LDSTUBA -> false
                                | LDSTUBA, LDA -> false
                                | LDA, LDSTUB -> false
                                | LDSTUB, LDA -> false
                                | LDA, STDA -> false
                                | STDA, LDA -> false
                                | LDA, STHA -> false
                                | STHA, LDA -> false
                                | LDA, STBA -> false
                                | STBA, LDA -> false
                                | LDA, LDDA -> false
                                | LDDA, LDA -> false
                                | LDA, LDUHA -> false
                                | LDUHA, LDA -> false
                                | LDA, LDSHA -> false
                                | LDSHA, LDA -> false
                                | LDA, LDSH -> false
                                | LDSH, LDA -> false
                                | LDA, LDSBA -> false
                                | LDSBA, LDA -> false
                                | LDA, STD -> false
                                | STD, LDA -> false
                                | LDA, STA -> false
                                | STA, LDA -> false
                                | LDA, ST -> false
                                | ST, LDA -> false
                                | LDA, STH -> false
                                | STH, LDA -> false
                                | LDA, STB -> false
                                | STB, LDA -> false
                                | LDA, LDD -> false
                                | LDD, LDA -> false
                                | LD, CASXA -> false
                                | CASXA, LD -> false
                                | LD, CASA -> false
                                | CASA, LD -> false
                                | LD, STBAR -> false
                                | STBAR, LD -> false
                                | LD, FLUSH -> false
                                | FLUSH, LD -> false
                                | LD, SWAPA -> false
                                | SWAPA, LD -> false
                                | LD, SWAP -> false
                                | SWAP, LD -> false
                                | LD, LDSTUBA -> false
                                | LDSTUBA, LD -> false
                                | LD, LDSTUB -> false
                                | LDSTUB, LD -> false
                                | LD, STDA -> false
                                | STDA, LD -> false
                                | LD, STHA -> false
                                | STHA, LD -> false
                                | LD, STBA -> false
                                | STBA, LD -> false
                                | LD, LDDA -> false
                                | LDDA, LD -> false
                                | LD, LDUHA -> false
                                | LDUHA, LD -> false
                                | LD, LDSHA -> false
                                | LDSHA, LD -> false
                                | LD, LDSH -> false
                                | LDSH, LD -> false
                                | LD, LDSBA -> false
                                | LDSBA, LD -> false
                                | LD, STD -> false
                                | STD, LD -> false
                                | LD, STA -> false
                                | STA, LD -> false
                                | LD, ST -> false
                                | ST, LD -> false
                                | LD, STH -> false
                                | STH, LD -> false
                                | LD, STB -> false
                                | STB, LD -> false
                                | LD, LDD -> false
                                | LDD, LD -> false
                                | LD, LDA -> false
                                | LDA, LD -> false
                                | LDUH, CASXA -> false
                                | CASXA, LDUH -> false
                                | LDUH, CASA -> false
                                | CASA, LDUH -> false
                                | LDUH, STBAR -> false
                                | STBAR, LDUH -> false
                                | LDUH, FLUSH -> false
                                | FLUSH, LDUH -> false
                                | LDUH, SWAPA -> false
                                | SWAPA, LDUH -> false
                                | LDUH, SWAP -> false
                                | SWAP, LDUH -> false
                                | LDUH, LDSTUBA -> false
                                | LDSTUBA, LDUH -> false
                                | LDUH, LDSTUB -> false
                                | LDSTUB, LDUH -> false
                                | LDUH, STDA -> false
                                | STDA, LDUH -> false
                                | LDUH, STHA -> false
                                | STHA, LDUH -> false
                                | LDUH, STBA -> false
                                | STBA, LDUH -> false
                                | LDUH, LDDA -> false
                                | LDDA, LDUH -> false
                                | LDUH, LDUHA -> false
                                | LDUHA, LDUH -> false
                                | LDUH, LDSHA -> false
                                | LDSHA, LDUH -> false
                                | LDUH, LDSH -> false
                                | LDSH, LDUH -> false
                                | LDUH, LDSBA -> false
                                | LDSBA, LDUH -> false
                                | LDUH, STD -> false
                                | STD, LDUH -> false
                                | LDUH, STA -> false
                                | STA, LDUH -> false
                                | LDUH, ST -> false
                                | ST, LDUH -> false
                                | LDUH, STH -> false
                                | STH, LDUH -> false
                                | LDUH, STB -> false
                                | STB, LDUH -> false
                                | LDUH, LDD -> false
                                | LDD, LDUH -> false
                                | LDUH, LDA -> false
                                | LDA, LDUH -> false
                                | LDUH, LD -> false
                                | LD, LDUH -> false
                                | LDUBA, CASXA -> false
                                | CASXA, LDUBA -> false
                                | LDUBA, CASA -> false
                                | CASA, LDUBA -> false
                                | LDUBA, STBAR -> false
                                | STBAR, LDUBA -> false
                                | LDUBA, FLUSH -> false
                                | FLUSH, LDUBA -> false
                                | LDUBA, SWAPA -> false
                                | SWAPA, LDUBA -> false
                                | LDUBA, SWAP -> false
                                | SWAP, LDUBA -> false
                                | LDUBA, LDSTUBA -> false
                                | LDSTUBA, LDUBA -> false
                                | LDUBA, LDSTUB -> false
                                | LDSTUB, LDUBA -> false
                                | LDUBA, STDA -> false
                                | STDA, LDUBA -> false
                                | LDUBA, STHA -> false
                                | STHA, LDUBA -> false
                                | LDUBA, STBA -> false
                                | STBA, LDUBA -> false
                                | LDUBA, LDDA -> false
                                | LDDA, LDUBA -> false
                                | LDUBA, LDUHA -> false
                                | LDUHA, LDUBA -> false
                                | LDUBA, LDSHA -> false
                                | LDSHA, LDUBA -> false
                                | LDUBA, LDSH -> false
                                | LDSH, LDUBA -> false
                                | LDUBA, LDSBA -> false
                                | LDSBA, LDUBA -> false
                                | LDUBA, STD -> false
                                | STD, LDUBA -> false
                                | LDUBA, STA -> false
                                | STA, LDUBA -> false
                                | LDUBA, ST -> false
                                | ST, LDUBA -> false
                                | LDUBA, STH -> false
                                | STH, LDUBA -> false
                                | LDUBA, STB -> false
                                | STB, LDUBA -> false
                                | LDUBA, LDD -> false
                                | LDD, LDUBA -> false
                                | LDUBA, LDA -> false
                                | LDA, LDUBA -> false
                                | LDUBA, LD -> false
                                | LD, LDUBA -> false
                                | LDUBA, LDUH -> false
                                | LDUH, LDUBA -> false
                                | LDUB, CASXA -> false
                                | CASXA, LDUB -> false
                                | LDUB, CASA -> false
                                | CASA, LDUB -> false
                                | LDUB, STBAR -> false
                                | STBAR, LDUB -> false
                                | LDUB, FLUSH -> false
                                | FLUSH, LDUB -> false
                                | LDUB, SWAPA -> false
                                | SWAPA, LDUB -> false
                                | LDUB, SWAP -> false
                                | SWAP, LDUB -> false
                                | LDUB, LDSTUBA -> false
                                | LDSTUBA, LDUB -> false
                                | LDUB, LDSTUB -> false
                                | LDSTUB, LDUB -> false
                                | LDUB, STDA -> false
                                | STDA, LDUB -> false
                                | LDUB, STHA -> false
                                | STHA, LDUB -> false
                                | LDUB, STBA -> false
                                | STBA, LDUB -> false
                                | LDUB, LDDA -> false
                                | LDDA, LDUB -> false
                                | LDUB, LDUHA -> false
                                | LDUHA, LDUB -> false
                                | LDUB, LDSHA -> false
                                | LDSHA, LDUB -> false
                                | LDUB, LDSH -> false
                                | LDSH, LDUB -> false
                                | LDUB, LDSBA -> false
                                | LDSBA, LDUB -> false
                                | LDUB, STD -> false
                                | STD, LDUB -> false
                                | LDUB, STA -> false
                                | STA, LDUB -> false
                                | LDUB, ST -> false
                                | ST, LDUB -> false
                                | LDUB, STH -> false
                                | STH, LDUB -> false
                                | LDUB, STB -> false
                                | STB, LDUB -> false
                                | LDUB, LDD -> false
                                | LDD, LDUB -> false
                                | LDUB, LDA -> false
                                | LDA, LDUB -> false
                                | LDUB, LD -> false
                                | LD, LDUB -> false
                                | LDUB, LDUH -> false
                                | LDUH, LDUB -> false
                                | LDUB, LDUBA -> false
                                | LDUBA, LDUB -> false
                                | LDSB, CASXA -> false
                                | CASXA, LDSB -> false
                                | LDSB, CASA -> false
                                | CASA, LDSB -> false
                                | LDSB, STBAR -> false
                                | STBAR, LDSB -> false
                                | LDSB, FLUSH -> false
                                | FLUSH, LDSB -> false
                                | LDSB, SWAPA -> false
                                | SWAPA, LDSB -> false
                                | LDSB, SWAP -> false
                                | SWAP, LDSB -> false
                                | LDSB, LDSTUBA -> false
                                | LDSTUBA, LDSB -> false
                                | LDSB, LDSTUB -> false
                                | LDSTUB, LDSB -> false
                                | LDSB, STDA -> false
                                | STDA, LDSB -> false
                                | LDSB, STHA -> false
                                | STHA, LDSB -> false
                                | LDSB, STBA -> false
                                | STBA, LDSB -> false
                                | LDSB, LDDA -> false
                                | LDDA, LDSB -> false
                                | LDSB, LDUHA -> false
                                | LDUHA, LDSB -> false
                                | LDSB, LDSHA -> false
                                | LDSHA, LDSB -> false
                                | LDSB, LDSH -> false
                                | LDSH, LDSB -> false
                                | LDSB, LDSBA -> false
                                | LDSBA, LDSB -> false
                                | LDSB, STD -> false
                                | STD, LDSB -> false
                                | LDSB, STA -> false
                                | STA, LDSB -> false
                                | LDSB, ST -> false
                                | ST, LDSB -> false
                                | LDSB, STH -> false
                                | STH, LDSB -> false
                                | LDSB, STB -> false
                                | STB, LDSB -> false
                                | LDSB, LDD -> false
                                | LDD, LDSB -> false
                                | LDSB, LDA -> false
                                | LDA, LDSB -> false
                                | LDSB, LD -> false
                                | LD, LDSB -> false
                                | LDSB, LDUH -> false
                                | LDUH, LDSB -> false
                                | LDSB, LDUBA -> false
                                | LDUBA, LDSB -> false
                                | LDSB, LDUB -> false
                                | LDUB, LDSB -> false
                                | CASXA, CASXA -> true
                                | CASA, CASA -> true
                                | STBAR, STBAR -> true
                                | FLUSH, FLUSH -> true
                                | SWAPA, SWAPA -> true
                                | SWAP, SWAP -> true
                                | LDSTUBA, LDSTUBA -> true
                                | LDSTUB, LDSTUB -> true
                                | STDA, STDA -> true
                                | STHA, STHA -> true
                                | STBA, STBA -> true
                                | LDDA, LDDA -> true
                                | LDUHA, LDUHA -> true
                                | LDSHA, LDSHA -> true
                                | LDSH, LDSH -> true
                                | LDSBA, LDSBA -> true
                                | STD, STD -> true
                                | STA, STA -> true
                                | ST, ST -> true
                                | STH, STH -> true
                                | STB, STB -> true
                                | LDD, LDD -> true
                                | LDA, LDA -> true
                                | LD, LD -> true
                                | LDUH, LDUH -> true
                                | LDUBA, LDUBA -> true
                                | LDUB, LDUB -> true
                                | LDSB, LDSB -> true;;

type shift_type = SLL | SRL | SRA;;

let rec equal_shift_type x0 x1 = match x0, x1 with SRL, SRA -> false
                           | SRA, SRL -> false
                           | SLL, SRA -> false
                           | SRA, SLL -> false
                           | SLL, SRL -> false
                           | SRL, SLL -> false
                           | SRA, SRA -> true
                           | SRL, SRL -> true
                           | SLL, SLL -> true;;

type sethi_type = SETHI;;

let rec equal_sethi_type SETHI SETHI = true;;

type logic_type = ANDs | ANDcc | ANDN | ANDNcc | ORs | ORcc | ORN | XORs | XNOR
  | ORNcc | XORcc | XNORcc;;

let rec equal_logic_type x0 x1 = match x0, x1 with XORcc, XNORcc -> false
                           | XNORcc, XORcc -> false
                           | ORNcc, XNORcc -> false
                           | XNORcc, ORNcc -> false
                           | ORNcc, XORcc -> false
                           | XORcc, ORNcc -> false
                           | XNOR, XNORcc -> false
                           | XNORcc, XNOR -> false
                           | XNOR, XORcc -> false
                           | XORcc, XNOR -> false
                           | XNOR, ORNcc -> false
                           | ORNcc, XNOR -> false
                           | XORs, XNORcc -> false
                           | XNORcc, XORs -> false
                           | XORs, XORcc -> false
                           | XORcc, XORs -> false
                           | XORs, ORNcc -> false
                           | ORNcc, XORs -> false
                           | XORs, XNOR -> false
                           | XNOR, XORs -> false
                           | ORN, XNORcc -> false
                           | XNORcc, ORN -> false
                           | ORN, XORcc -> false
                           | XORcc, ORN -> false
                           | ORN, ORNcc -> false
                           | ORNcc, ORN -> false
                           | ORN, XNOR -> false
                           | XNOR, ORN -> false
                           | ORN, XORs -> false
                           | XORs, ORN -> false
                           | ORcc, XNORcc -> false
                           | XNORcc, ORcc -> false
                           | ORcc, XORcc -> false
                           | XORcc, ORcc -> false
                           | ORcc, ORNcc -> false
                           | ORNcc, ORcc -> false
                           | ORcc, XNOR -> false
                           | XNOR, ORcc -> false
                           | ORcc, XORs -> false
                           | XORs, ORcc -> false
                           | ORcc, ORN -> false
                           | ORN, ORcc -> false
                           | ORs, XNORcc -> false
                           | XNORcc, ORs -> false
                           | ORs, XORcc -> false
                           | XORcc, ORs -> false
                           | ORs, ORNcc -> false
                           | ORNcc, ORs -> false
                           | ORs, XNOR -> false
                           | XNOR, ORs -> false
                           | ORs, XORs -> false
                           | XORs, ORs -> false
                           | ORs, ORN -> false
                           | ORN, ORs -> false
                           | ORs, ORcc -> false
                           | ORcc, ORs -> false
                           | ANDNcc, XNORcc -> false
                           | XNORcc, ANDNcc -> false
                           | ANDNcc, XORcc -> false
                           | XORcc, ANDNcc -> false
                           | ANDNcc, ORNcc -> false
                           | ORNcc, ANDNcc -> false
                           | ANDNcc, XNOR -> false
                           | XNOR, ANDNcc -> false
                           | ANDNcc, XORs -> false
                           | XORs, ANDNcc -> false
                           | ANDNcc, ORN -> false
                           | ORN, ANDNcc -> false
                           | ANDNcc, ORcc -> false
                           | ORcc, ANDNcc -> false
                           | ANDNcc, ORs -> false
                           | ORs, ANDNcc -> false
                           | ANDN, XNORcc -> false
                           | XNORcc, ANDN -> false
                           | ANDN, XORcc -> false
                           | XORcc, ANDN -> false
                           | ANDN, ORNcc -> false
                           | ORNcc, ANDN -> false
                           | ANDN, XNOR -> false
                           | XNOR, ANDN -> false
                           | ANDN, XORs -> false
                           | XORs, ANDN -> false
                           | ANDN, ORN -> false
                           | ORN, ANDN -> false
                           | ANDN, ORcc -> false
                           | ORcc, ANDN -> false
                           | ANDN, ORs -> false
                           | ORs, ANDN -> false
                           | ANDN, ANDNcc -> false
                           | ANDNcc, ANDN -> false
                           | ANDcc, XNORcc -> false
                           | XNORcc, ANDcc -> false
                           | ANDcc, XORcc -> false
                           | XORcc, ANDcc -> false
                           | ANDcc, ORNcc -> false
                           | ORNcc, ANDcc -> false
                           | ANDcc, XNOR -> false
                           | XNOR, ANDcc -> false
                           | ANDcc, XORs -> false
                           | XORs, ANDcc -> false
                           | ANDcc, ORN -> false
                           | ORN, ANDcc -> false
                           | ANDcc, ORcc -> false
                           | ORcc, ANDcc -> false
                           | ANDcc, ORs -> false
                           | ORs, ANDcc -> false
                           | ANDcc, ANDNcc -> false
                           | ANDNcc, ANDcc -> false
                           | ANDcc, ANDN -> false
                           | ANDN, ANDcc -> false
                           | ANDs, XNORcc -> false
                           | XNORcc, ANDs -> false
                           | ANDs, XORcc -> false
                           | XORcc, ANDs -> false
                           | ANDs, ORNcc -> false
                           | ORNcc, ANDs -> false
                           | ANDs, XNOR -> false
                           | XNOR, ANDs -> false
                           | ANDs, XORs -> false
                           | XORs, ANDs -> false
                           | ANDs, ORN -> false
                           | ORN, ANDs -> false
                           | ANDs, ORcc -> false
                           | ORcc, ANDs -> false
                           | ANDs, ORs -> false
                           | ORs, ANDs -> false
                           | ANDs, ANDNcc -> false
                           | ANDNcc, ANDs -> false
                           | ANDs, ANDN -> false
                           | ANDN, ANDs -> false
                           | ANDs, ANDcc -> false
                           | ANDcc, ANDs -> false
                           | XNORcc, XNORcc -> true
                           | XORcc, XORcc -> true
                           | ORNcc, ORNcc -> true
                           | XNOR, XNOR -> true
                           | XORs, XORs -> true
                           | ORN, ORN -> true
                           | ORcc, ORcc -> true
                           | ORs, ORs -> true
                           | ANDNcc, ANDNcc -> true
                           | ANDN, ANDN -> true
                           | ANDcc, ANDcc -> true
                           | ANDs, ANDs -> true;;

type arith_type = ADD | ADDcc | ADDX | SUB | SUBcc | SUBX | UMUL | SMUL | SMULcc
  | UDIV | UDIVcc | SDIV | ADDXcc | TADDcc | TADDccTV | SUBXcc | TSUBcc |
  TSUBccTV | MULScc | UMULcc | SDIVcc;;

let rec equal_arith_type x0 x1 = match x0, x1 with UMULcc, SDIVcc -> false
                           | SDIVcc, UMULcc -> false
                           | MULScc, SDIVcc -> false
                           | SDIVcc, MULScc -> false
                           | MULScc, UMULcc -> false
                           | UMULcc, MULScc -> false
                           | TSUBccTV, SDIVcc -> false
                           | SDIVcc, TSUBccTV -> false
                           | TSUBccTV, UMULcc -> false
                           | UMULcc, TSUBccTV -> false
                           | TSUBccTV, MULScc -> false
                           | MULScc, TSUBccTV -> false
                           | TSUBcc, SDIVcc -> false
                           | SDIVcc, TSUBcc -> false
                           | TSUBcc, UMULcc -> false
                           | UMULcc, TSUBcc -> false
                           | TSUBcc, MULScc -> false
                           | MULScc, TSUBcc -> false
                           | TSUBcc, TSUBccTV -> false
                           | TSUBccTV, TSUBcc -> false
                           | SUBXcc, SDIVcc -> false
                           | SDIVcc, SUBXcc -> false
                           | SUBXcc, UMULcc -> false
                           | UMULcc, SUBXcc -> false
                           | SUBXcc, MULScc -> false
                           | MULScc, SUBXcc -> false
                           | SUBXcc, TSUBccTV -> false
                           | TSUBccTV, SUBXcc -> false
                           | SUBXcc, TSUBcc -> false
                           | TSUBcc, SUBXcc -> false
                           | TADDccTV, SDIVcc -> false
                           | SDIVcc, TADDccTV -> false
                           | TADDccTV, UMULcc -> false
                           | UMULcc, TADDccTV -> false
                           | TADDccTV, MULScc -> false
                           | MULScc, TADDccTV -> false
                           | TADDccTV, TSUBccTV -> false
                           | TSUBccTV, TADDccTV -> false
                           | TADDccTV, TSUBcc -> false
                           | TSUBcc, TADDccTV -> false
                           | TADDccTV, SUBXcc -> false
                           | SUBXcc, TADDccTV -> false
                           | TADDcc, SDIVcc -> false
                           | SDIVcc, TADDcc -> false
                           | TADDcc, UMULcc -> false
                           | UMULcc, TADDcc -> false
                           | TADDcc, MULScc -> false
                           | MULScc, TADDcc -> false
                           | TADDcc, TSUBccTV -> false
                           | TSUBccTV, TADDcc -> false
                           | TADDcc, TSUBcc -> false
                           | TSUBcc, TADDcc -> false
                           | TADDcc, SUBXcc -> false
                           | SUBXcc, TADDcc -> false
                           | TADDcc, TADDccTV -> false
                           | TADDccTV, TADDcc -> false
                           | ADDXcc, SDIVcc -> false
                           | SDIVcc, ADDXcc -> false
                           | ADDXcc, UMULcc -> false
                           | UMULcc, ADDXcc -> false
                           | ADDXcc, MULScc -> false
                           | MULScc, ADDXcc -> false
                           | ADDXcc, TSUBccTV -> false
                           | TSUBccTV, ADDXcc -> false
                           | ADDXcc, TSUBcc -> false
                           | TSUBcc, ADDXcc -> false
                           | ADDXcc, SUBXcc -> false
                           | SUBXcc, ADDXcc -> false
                           | ADDXcc, TADDccTV -> false
                           | TADDccTV, ADDXcc -> false
                           | ADDXcc, TADDcc -> false
                           | TADDcc, ADDXcc -> false
                           | SDIV, SDIVcc -> false
                           | SDIVcc, SDIV -> false
                           | SDIV, UMULcc -> false
                           | UMULcc, SDIV -> false
                           | SDIV, MULScc -> false
                           | MULScc, SDIV -> false
                           | SDIV, TSUBccTV -> false
                           | TSUBccTV, SDIV -> false
                           | SDIV, TSUBcc -> false
                           | TSUBcc, SDIV -> false
                           | SDIV, SUBXcc -> false
                           | SUBXcc, SDIV -> false
                           | SDIV, TADDccTV -> false
                           | TADDccTV, SDIV -> false
                           | SDIV, TADDcc -> false
                           | TADDcc, SDIV -> false
                           | SDIV, ADDXcc -> false
                           | ADDXcc, SDIV -> false
                           | UDIVcc, SDIVcc -> false
                           | SDIVcc, UDIVcc -> false
                           | UDIVcc, UMULcc -> false
                           | UMULcc, UDIVcc -> false
                           | UDIVcc, MULScc -> false
                           | MULScc, UDIVcc -> false
                           | UDIVcc, TSUBccTV -> false
                           | TSUBccTV, UDIVcc -> false
                           | UDIVcc, TSUBcc -> false
                           | TSUBcc, UDIVcc -> false
                           | UDIVcc, SUBXcc -> false
                           | SUBXcc, UDIVcc -> false
                           | UDIVcc, TADDccTV -> false
                           | TADDccTV, UDIVcc -> false
                           | UDIVcc, TADDcc -> false
                           | TADDcc, UDIVcc -> false
                           | UDIVcc, ADDXcc -> false
                           | ADDXcc, UDIVcc -> false
                           | UDIVcc, SDIV -> false
                           | SDIV, UDIVcc -> false
                           | UDIV, SDIVcc -> false
                           | SDIVcc, UDIV -> false
                           | UDIV, UMULcc -> false
                           | UMULcc, UDIV -> false
                           | UDIV, MULScc -> false
                           | MULScc, UDIV -> false
                           | UDIV, TSUBccTV -> false
                           | TSUBccTV, UDIV -> false
                           | UDIV, TSUBcc -> false
                           | TSUBcc, UDIV -> false
                           | UDIV, SUBXcc -> false
                           | SUBXcc, UDIV -> false
                           | UDIV, TADDccTV -> false
                           | TADDccTV, UDIV -> false
                           | UDIV, TADDcc -> false
                           | TADDcc, UDIV -> false
                           | UDIV, ADDXcc -> false
                           | ADDXcc, UDIV -> false
                           | UDIV, SDIV -> false
                           | SDIV, UDIV -> false
                           | UDIV, UDIVcc -> false
                           | UDIVcc, UDIV -> false
                           | SMULcc, SDIVcc -> false
                           | SDIVcc, SMULcc -> false
                           | SMULcc, UMULcc -> false
                           | UMULcc, SMULcc -> false
                           | SMULcc, MULScc -> false
                           | MULScc, SMULcc -> false
                           | SMULcc, TSUBccTV -> false
                           | TSUBccTV, SMULcc -> false
                           | SMULcc, TSUBcc -> false
                           | TSUBcc, SMULcc -> false
                           | SMULcc, SUBXcc -> false
                           | SUBXcc, SMULcc -> false
                           | SMULcc, TADDccTV -> false
                           | TADDccTV, SMULcc -> false
                           | SMULcc, TADDcc -> false
                           | TADDcc, SMULcc -> false
                           | SMULcc, ADDXcc -> false
                           | ADDXcc, SMULcc -> false
                           | SMULcc, SDIV -> false
                           | SDIV, SMULcc -> false
                           | SMULcc, UDIVcc -> false
                           | UDIVcc, SMULcc -> false
                           | SMULcc, UDIV -> false
                           | UDIV, SMULcc -> false
                           | SMUL, SDIVcc -> false
                           | SDIVcc, SMUL -> false
                           | SMUL, UMULcc -> false
                           | UMULcc, SMUL -> false
                           | SMUL, MULScc -> false
                           | MULScc, SMUL -> false
                           | SMUL, TSUBccTV -> false
                           | TSUBccTV, SMUL -> false
                           | SMUL, TSUBcc -> false
                           | TSUBcc, SMUL -> false
                           | SMUL, SUBXcc -> false
                           | SUBXcc, SMUL -> false
                           | SMUL, TADDccTV -> false
                           | TADDccTV, SMUL -> false
                           | SMUL, TADDcc -> false
                           | TADDcc, SMUL -> false
                           | SMUL, ADDXcc -> false
                           | ADDXcc, SMUL -> false
                           | SMUL, SDIV -> false
                           | SDIV, SMUL -> false
                           | SMUL, UDIVcc -> false
                           | UDIVcc, SMUL -> false
                           | SMUL, UDIV -> false
                           | UDIV, SMUL -> false
                           | SMUL, SMULcc -> false
                           | SMULcc, SMUL -> false
                           | UMUL, SDIVcc -> false
                           | SDIVcc, UMUL -> false
                           | UMUL, UMULcc -> false
                           | UMULcc, UMUL -> false
                           | UMUL, MULScc -> false
                           | MULScc, UMUL -> false
                           | UMUL, TSUBccTV -> false
                           | TSUBccTV, UMUL -> false
                           | UMUL, TSUBcc -> false
                           | TSUBcc, UMUL -> false
                           | UMUL, SUBXcc -> false
                           | SUBXcc, UMUL -> false
                           | UMUL, TADDccTV -> false
                           | TADDccTV, UMUL -> false
                           | UMUL, TADDcc -> false
                           | TADDcc, UMUL -> false
                           | UMUL, ADDXcc -> false
                           | ADDXcc, UMUL -> false
                           | UMUL, SDIV -> false
                           | SDIV, UMUL -> false
                           | UMUL, UDIVcc -> false
                           | UDIVcc, UMUL -> false
                           | UMUL, UDIV -> false
                           | UDIV, UMUL -> false
                           | UMUL, SMULcc -> false
                           | SMULcc, UMUL -> false
                           | UMUL, SMUL -> false
                           | SMUL, UMUL -> false
                           | SUBX, SDIVcc -> false
                           | SDIVcc, SUBX -> false
                           | SUBX, UMULcc -> false
                           | UMULcc, SUBX -> false
                           | SUBX, MULScc -> false
                           | MULScc, SUBX -> false
                           | SUBX, TSUBccTV -> false
                           | TSUBccTV, SUBX -> false
                           | SUBX, TSUBcc -> false
                           | TSUBcc, SUBX -> false
                           | SUBX, SUBXcc -> false
                           | SUBXcc, SUBX -> false
                           | SUBX, TADDccTV -> false
                           | TADDccTV, SUBX -> false
                           | SUBX, TADDcc -> false
                           | TADDcc, SUBX -> false
                           | SUBX, ADDXcc -> false
                           | ADDXcc, SUBX -> false
                           | SUBX, SDIV -> false
                           | SDIV, SUBX -> false
                           | SUBX, UDIVcc -> false
                           | UDIVcc, SUBX -> false
                           | SUBX, UDIV -> false
                           | UDIV, SUBX -> false
                           | SUBX, SMULcc -> false
                           | SMULcc, SUBX -> false
                           | SUBX, SMUL -> false
                           | SMUL, SUBX -> false
                           | SUBX, UMUL -> false
                           | UMUL, SUBX -> false
                           | SUBcc, SDIVcc -> false
                           | SDIVcc, SUBcc -> false
                           | SUBcc, UMULcc -> false
                           | UMULcc, SUBcc -> false
                           | SUBcc, MULScc -> false
                           | MULScc, SUBcc -> false
                           | SUBcc, TSUBccTV -> false
                           | TSUBccTV, SUBcc -> false
                           | SUBcc, TSUBcc -> false
                           | TSUBcc, SUBcc -> false
                           | SUBcc, SUBXcc -> false
                           | SUBXcc, SUBcc -> false
                           | SUBcc, TADDccTV -> false
                           | TADDccTV, SUBcc -> false
                           | SUBcc, TADDcc -> false
                           | TADDcc, SUBcc -> false
                           | SUBcc, ADDXcc -> false
                           | ADDXcc, SUBcc -> false
                           | SUBcc, SDIV -> false
                           | SDIV, SUBcc -> false
                           | SUBcc, UDIVcc -> false
                           | UDIVcc, SUBcc -> false
                           | SUBcc, UDIV -> false
                           | UDIV, SUBcc -> false
                           | SUBcc, SMULcc -> false
                           | SMULcc, SUBcc -> false
                           | SUBcc, SMUL -> false
                           | SMUL, SUBcc -> false
                           | SUBcc, UMUL -> false
                           | UMUL, SUBcc -> false
                           | SUBcc, SUBX -> false
                           | SUBX, SUBcc -> false
                           | SUB, SDIVcc -> false
                           | SDIVcc, SUB -> false
                           | SUB, UMULcc -> false
                           | UMULcc, SUB -> false
                           | SUB, MULScc -> false
                           | MULScc, SUB -> false
                           | SUB, TSUBccTV -> false
                           | TSUBccTV, SUB -> false
                           | SUB, TSUBcc -> false
                           | TSUBcc, SUB -> false
                           | SUB, SUBXcc -> false
                           | SUBXcc, SUB -> false
                           | SUB, TADDccTV -> false
                           | TADDccTV, SUB -> false
                           | SUB, TADDcc -> false
                           | TADDcc, SUB -> false
                           | SUB, ADDXcc -> false
                           | ADDXcc, SUB -> false
                           | SUB, SDIV -> false
                           | SDIV, SUB -> false
                           | SUB, UDIVcc -> false
                           | UDIVcc, SUB -> false
                           | SUB, UDIV -> false
                           | UDIV, SUB -> false
                           | SUB, SMULcc -> false
                           | SMULcc, SUB -> false
                           | SUB, SMUL -> false
                           | SMUL, SUB -> false
                           | SUB, UMUL -> false
                           | UMUL, SUB -> false
                           | SUB, SUBX -> false
                           | SUBX, SUB -> false
                           | SUB, SUBcc -> false
                           | SUBcc, SUB -> false
                           | ADDX, SDIVcc -> false
                           | SDIVcc, ADDX -> false
                           | ADDX, UMULcc -> false
                           | UMULcc, ADDX -> false
                           | ADDX, MULScc -> false
                           | MULScc, ADDX -> false
                           | ADDX, TSUBccTV -> false
                           | TSUBccTV, ADDX -> false
                           | ADDX, TSUBcc -> false
                           | TSUBcc, ADDX -> false
                           | ADDX, SUBXcc -> false
                           | SUBXcc, ADDX -> false
                           | ADDX, TADDccTV -> false
                           | TADDccTV, ADDX -> false
                           | ADDX, TADDcc -> false
                           | TADDcc, ADDX -> false
                           | ADDX, ADDXcc -> false
                           | ADDXcc, ADDX -> false
                           | ADDX, SDIV -> false
                           | SDIV, ADDX -> false
                           | ADDX, UDIVcc -> false
                           | UDIVcc, ADDX -> false
                           | ADDX, UDIV -> false
                           | UDIV, ADDX -> false
                           | ADDX, SMULcc -> false
                           | SMULcc, ADDX -> false
                           | ADDX, SMUL -> false
                           | SMUL, ADDX -> false
                           | ADDX, UMUL -> false
                           | UMUL, ADDX -> false
                           | ADDX, SUBX -> false
                           | SUBX, ADDX -> false
                           | ADDX, SUBcc -> false
                           | SUBcc, ADDX -> false
                           | ADDX, SUB -> false
                           | SUB, ADDX -> false
                           | ADDcc, SDIVcc -> false
                           | SDIVcc, ADDcc -> false
                           | ADDcc, UMULcc -> false
                           | UMULcc, ADDcc -> false
                           | ADDcc, MULScc -> false
                           | MULScc, ADDcc -> false
                           | ADDcc, TSUBccTV -> false
                           | TSUBccTV, ADDcc -> false
                           | ADDcc, TSUBcc -> false
                           | TSUBcc, ADDcc -> false
                           | ADDcc, SUBXcc -> false
                           | SUBXcc, ADDcc -> false
                           | ADDcc, TADDccTV -> false
                           | TADDccTV, ADDcc -> false
                           | ADDcc, TADDcc -> false
                           | TADDcc, ADDcc -> false
                           | ADDcc, ADDXcc -> false
                           | ADDXcc, ADDcc -> false
                           | ADDcc, SDIV -> false
                           | SDIV, ADDcc -> false
                           | ADDcc, UDIVcc -> false
                           | UDIVcc, ADDcc -> false
                           | ADDcc, UDIV -> false
                           | UDIV, ADDcc -> false
                           | ADDcc, SMULcc -> false
                           | SMULcc, ADDcc -> false
                           | ADDcc, SMUL -> false
                           | SMUL, ADDcc -> false
                           | ADDcc, UMUL -> false
                           | UMUL, ADDcc -> false
                           | ADDcc, SUBX -> false
                           | SUBX, ADDcc -> false
                           | ADDcc, SUBcc -> false
                           | SUBcc, ADDcc -> false
                           | ADDcc, SUB -> false
                           | SUB, ADDcc -> false
                           | ADDcc, ADDX -> false
                           | ADDX, ADDcc -> false
                           | ADD, SDIVcc -> false
                           | SDIVcc, ADD -> false
                           | ADD, UMULcc -> false
                           | UMULcc, ADD -> false
                           | ADD, MULScc -> false
                           | MULScc, ADD -> false
                           | ADD, TSUBccTV -> false
                           | TSUBccTV, ADD -> false
                           | ADD, TSUBcc -> false
                           | TSUBcc, ADD -> false
                           | ADD, SUBXcc -> false
                           | SUBXcc, ADD -> false
                           | ADD, TADDccTV -> false
                           | TADDccTV, ADD -> false
                           | ADD, TADDcc -> false
                           | TADDcc, ADD -> false
                           | ADD, ADDXcc -> false
                           | ADDXcc, ADD -> false
                           | ADD, SDIV -> false
                           | SDIV, ADD -> false
                           | ADD, UDIVcc -> false
                           | UDIVcc, ADD -> false
                           | ADD, UDIV -> false
                           | UDIV, ADD -> false
                           | ADD, SMULcc -> false
                           | SMULcc, ADD -> false
                           | ADD, SMUL -> false
                           | SMUL, ADD -> false
                           | ADD, UMUL -> false
                           | UMUL, ADD -> false
                           | ADD, SUBX -> false
                           | SUBX, ADD -> false
                           | ADD, SUBcc -> false
                           | SUBcc, ADD -> false
                           | ADD, SUB -> false
                           | SUB, ADD -> false
                           | ADD, ADDX -> false
                           | ADDX, ADD -> false
                           | ADD, ADDcc -> false
                           | ADDcc, ADD -> false
                           | SDIVcc, SDIVcc -> true
                           | UMULcc, UMULcc -> true
                           | MULScc, MULScc -> true
                           | TSUBccTV, TSUBccTV -> true
                           | TSUBcc, TSUBcc -> true
                           | SUBXcc, SUBXcc -> true
                           | TADDccTV, TADDccTV -> true
                           | TADDcc, TADDcc -> true
                           | ADDXcc, ADDXcc -> true
                           | SDIV, SDIV -> true
                           | UDIVcc, UDIVcc -> true
                           | UDIV, UDIV -> true
                           | SMULcc, SMULcc -> true
                           | SMUL, SMUL -> true
                           | UMUL, UMUL -> true
                           | SUBX, SUBX -> true
                           | SUBcc, SUBcc -> true
                           | SUB, SUB -> true
                           | ADDX, ADDX -> true
                           | ADDcc, ADDcc -> true
                           | ADD, ADD -> true;;

type uimp_type = UNIMP;;

let rec equal_uimp_type UNIMP UNIMP = true;;

type ticc_type = TA | TN | TNE | TE | TG | TLE | TGE | TL | TGU | TLEU | TCC |
  TCS | TPOS | TNEG | TVC | TVS;;

let rec equal_ticc_type x0 x1 = match x0, x1 with TVC, TVS -> false
                          | TVS, TVC -> false
                          | TNEG, TVS -> false
                          | TVS, TNEG -> false
                          | TNEG, TVC -> false
                          | TVC, TNEG -> false
                          | TPOS, TVS -> false
                          | TVS, TPOS -> false
                          | TPOS, TVC -> false
                          | TVC, TPOS -> false
                          | TPOS, TNEG -> false
                          | TNEG, TPOS -> false
                          | TCS, TVS -> false
                          | TVS, TCS -> false
                          | TCS, TVC -> false
                          | TVC, TCS -> false
                          | TCS, TNEG -> false
                          | TNEG, TCS -> false
                          | TCS, TPOS -> false
                          | TPOS, TCS -> false
                          | TCC, TVS -> false
                          | TVS, TCC -> false
                          | TCC, TVC -> false
                          | TVC, TCC -> false
                          | TCC, TNEG -> false
                          | TNEG, TCC -> false
                          | TCC, TPOS -> false
                          | TPOS, TCC -> false
                          | TCC, TCS -> false
                          | TCS, TCC -> false
                          | TLEU, TVS -> false
                          | TVS, TLEU -> false
                          | TLEU, TVC -> false
                          | TVC, TLEU -> false
                          | TLEU, TNEG -> false
                          | TNEG, TLEU -> false
                          | TLEU, TPOS -> false
                          | TPOS, TLEU -> false
                          | TLEU, TCS -> false
                          | TCS, TLEU -> false
                          | TLEU, TCC -> false
                          | TCC, TLEU -> false
                          | TGU, TVS -> false
                          | TVS, TGU -> false
                          | TGU, TVC -> false
                          | TVC, TGU -> false
                          | TGU, TNEG -> false
                          | TNEG, TGU -> false
                          | TGU, TPOS -> false
                          | TPOS, TGU -> false
                          | TGU, TCS -> false
                          | TCS, TGU -> false
                          | TGU, TCC -> false
                          | TCC, TGU -> false
                          | TGU, TLEU -> false
                          | TLEU, TGU -> false
                          | TL, TVS -> false
                          | TVS, TL -> false
                          | TL, TVC -> false
                          | TVC, TL -> false
                          | TL, TNEG -> false
                          | TNEG, TL -> false
                          | TL, TPOS -> false
                          | TPOS, TL -> false
                          | TL, TCS -> false
                          | TCS, TL -> false
                          | TL, TCC -> false
                          | TCC, TL -> false
                          | TL, TLEU -> false
                          | TLEU, TL -> false
                          | TL, TGU -> false
                          | TGU, TL -> false
                          | TGE, TVS -> false
                          | TVS, TGE -> false
                          | TGE, TVC -> false
                          | TVC, TGE -> false
                          | TGE, TNEG -> false
                          | TNEG, TGE -> false
                          | TGE, TPOS -> false
                          | TPOS, TGE -> false
                          | TGE, TCS -> false
                          | TCS, TGE -> false
                          | TGE, TCC -> false
                          | TCC, TGE -> false
                          | TGE, TLEU -> false
                          | TLEU, TGE -> false
                          | TGE, TGU -> false
                          | TGU, TGE -> false
                          | TGE, TL -> false
                          | TL, TGE -> false
                          | TLE, TVS -> false
                          | TVS, TLE -> false
                          | TLE, TVC -> false
                          | TVC, TLE -> false
                          | TLE, TNEG -> false
                          | TNEG, TLE -> false
                          | TLE, TPOS -> false
                          | TPOS, TLE -> false
                          | TLE, TCS -> false
                          | TCS, TLE -> false
                          | TLE, TCC -> false
                          | TCC, TLE -> false
                          | TLE, TLEU -> false
                          | TLEU, TLE -> false
                          | TLE, TGU -> false
                          | TGU, TLE -> false
                          | TLE, TL -> false
                          | TL, TLE -> false
                          | TLE, TGE -> false
                          | TGE, TLE -> false
                          | TG, TVS -> false
                          | TVS, TG -> false
                          | TG, TVC -> false
                          | TVC, TG -> false
                          | TG, TNEG -> false
                          | TNEG, TG -> false
                          | TG, TPOS -> false
                          | TPOS, TG -> false
                          | TG, TCS -> false
                          | TCS, TG -> false
                          | TG, TCC -> false
                          | TCC, TG -> false
                          | TG, TLEU -> false
                          | TLEU, TG -> false
                          | TG, TGU -> false
                          | TGU, TG -> false
                          | TG, TL -> false
                          | TL, TG -> false
                          | TG, TGE -> false
                          | TGE, TG -> false
                          | TG, TLE -> false
                          | TLE, TG -> false
                          | TE, TVS -> false
                          | TVS, TE -> false
                          | TE, TVC -> false
                          | TVC, TE -> false
                          | TE, TNEG -> false
                          | TNEG, TE -> false
                          | TE, TPOS -> false
                          | TPOS, TE -> false
                          | TE, TCS -> false
                          | TCS, TE -> false
                          | TE, TCC -> false
                          | TCC, TE -> false
                          | TE, TLEU -> false
                          | TLEU, TE -> false
                          | TE, TGU -> false
                          | TGU, TE -> false
                          | TE, TL -> false
                          | TL, TE -> false
                          | TE, TGE -> false
                          | TGE, TE -> false
                          | TE, TLE -> false
                          | TLE, TE -> false
                          | TE, TG -> false
                          | TG, TE -> false
                          | TNE, TVS -> false
                          | TVS, TNE -> false
                          | TNE, TVC -> false
                          | TVC, TNE -> false
                          | TNE, TNEG -> false
                          | TNEG, TNE -> false
                          | TNE, TPOS -> false
                          | TPOS, TNE -> false
                          | TNE, TCS -> false
                          | TCS, TNE -> false
                          | TNE, TCC -> false
                          | TCC, TNE -> false
                          | TNE, TLEU -> false
                          | TLEU, TNE -> false
                          | TNE, TGU -> false
                          | TGU, TNE -> false
                          | TNE, TL -> false
                          | TL, TNE -> false
                          | TNE, TGE -> false
                          | TGE, TNE -> false
                          | TNE, TLE -> false
                          | TLE, TNE -> false
                          | TNE, TG -> false
                          | TG, TNE -> false
                          | TNE, TE -> false
                          | TE, TNE -> false
                          | TN, TVS -> false
                          | TVS, TN -> false
                          | TN, TVC -> false
                          | TVC, TN -> false
                          | TN, TNEG -> false
                          | TNEG, TN -> false
                          | TN, TPOS -> false
                          | TPOS, TN -> false
                          | TN, TCS -> false
                          | TCS, TN -> false
                          | TN, TCC -> false
                          | TCC, TN -> false
                          | TN, TLEU -> false
                          | TLEU, TN -> false
                          | TN, TGU -> false
                          | TGU, TN -> false
                          | TN, TL -> false
                          | TL, TN -> false
                          | TN, TGE -> false
                          | TGE, TN -> false
                          | TN, TLE -> false
                          | TLE, TN -> false
                          | TN, TG -> false
                          | TG, TN -> false
                          | TN, TE -> false
                          | TE, TN -> false
                          | TN, TNE -> false
                          | TNE, TN -> false
                          | TA, TVS -> false
                          | TVS, TA -> false
                          | TA, TVC -> false
                          | TVC, TA -> false
                          | TA, TNEG -> false
                          | TNEG, TA -> false
                          | TA, TPOS -> false
                          | TPOS, TA -> false
                          | TA, TCS -> false
                          | TCS, TA -> false
                          | TA, TCC -> false
                          | TCC, TA -> false
                          | TA, TLEU -> false
                          | TLEU, TA -> false
                          | TA, TGU -> false
                          | TGU, TA -> false
                          | TA, TL -> false
                          | TL, TA -> false
                          | TA, TGE -> false
                          | TGE, TA -> false
                          | TA, TLE -> false
                          | TLE, TA -> false
                          | TA, TG -> false
                          | TG, TA -> false
                          | TA, TE -> false
                          | TE, TA -> false
                          | TA, TNE -> false
                          | TNE, TA -> false
                          | TA, TN -> false
                          | TN, TA -> false
                          | TVS, TVS -> true
                          | TVC, TVC -> true
                          | TNEG, TNEG -> true
                          | TPOS, TPOS -> true
                          | TCS, TCS -> true
                          | TCC, TCC -> true
                          | TLEU, TLEU -> true
                          | TGU, TGU -> true
                          | TL, TL -> true
                          | TGE, TGE -> true
                          | TLE, TLE -> true
                          | TG, TG -> true
                          | TE, TE -> true
                          | TNE, TNE -> true
                          | TN, TN -> true
                          | TA, TA -> true;;

type sreg_type = RDASR | RDY | RDPSR | RDWIM | RDTBR | WRASR | WRY | WRPSR |
  WRWIM | WRTBR;;

let rec equal_sreg_type x0 x1 = match x0, x1 with WRWIM, WRTBR -> false
                          | WRTBR, WRWIM -> false
                          | WRPSR, WRTBR -> false
                          | WRTBR, WRPSR -> false
                          | WRPSR, WRWIM -> false
                          | WRWIM, WRPSR -> false
                          | WRY, WRTBR -> false
                          | WRTBR, WRY -> false
                          | WRY, WRWIM -> false
                          | WRWIM, WRY -> false
                          | WRY, WRPSR -> false
                          | WRPSR, WRY -> false
                          | WRASR, WRTBR -> false
                          | WRTBR, WRASR -> false
                          | WRASR, WRWIM -> false
                          | WRWIM, WRASR -> false
                          | WRASR, WRPSR -> false
                          | WRPSR, WRASR -> false
                          | WRASR, WRY -> false
                          | WRY, WRASR -> false
                          | RDTBR, WRTBR -> false
                          | WRTBR, RDTBR -> false
                          | RDTBR, WRWIM -> false
                          | WRWIM, RDTBR -> false
                          | RDTBR, WRPSR -> false
                          | WRPSR, RDTBR -> false
                          | RDTBR, WRY -> false
                          | WRY, RDTBR -> false
                          | RDTBR, WRASR -> false
                          | WRASR, RDTBR -> false
                          | RDWIM, WRTBR -> false
                          | WRTBR, RDWIM -> false
                          | RDWIM, WRWIM -> false
                          | WRWIM, RDWIM -> false
                          | RDWIM, WRPSR -> false
                          | WRPSR, RDWIM -> false
                          | RDWIM, WRY -> false
                          | WRY, RDWIM -> false
                          | RDWIM, WRASR -> false
                          | WRASR, RDWIM -> false
                          | RDWIM, RDTBR -> false
                          | RDTBR, RDWIM -> false
                          | RDPSR, WRTBR -> false
                          | WRTBR, RDPSR -> false
                          | RDPSR, WRWIM -> false
                          | WRWIM, RDPSR -> false
                          | RDPSR, WRPSR -> false
                          | WRPSR, RDPSR -> false
                          | RDPSR, WRY -> false
                          | WRY, RDPSR -> false
                          | RDPSR, WRASR -> false
                          | WRASR, RDPSR -> false
                          | RDPSR, RDTBR -> false
                          | RDTBR, RDPSR -> false
                          | RDPSR, RDWIM -> false
                          | RDWIM, RDPSR -> false
                          | RDY, WRTBR -> false
                          | WRTBR, RDY -> false
                          | RDY, WRWIM -> false
                          | WRWIM, RDY -> false
                          | RDY, WRPSR -> false
                          | WRPSR, RDY -> false
                          | RDY, WRY -> false
                          | WRY, RDY -> false
                          | RDY, WRASR -> false
                          | WRASR, RDY -> false
                          | RDY, RDTBR -> false
                          | RDTBR, RDY -> false
                          | RDY, RDWIM -> false
                          | RDWIM, RDY -> false
                          | RDY, RDPSR -> false
                          | RDPSR, RDY -> false
                          | RDASR, WRTBR -> false
                          | WRTBR, RDASR -> false
                          | RDASR, WRWIM -> false
                          | WRWIM, RDASR -> false
                          | RDASR, WRPSR -> false
                          | WRPSR, RDASR -> false
                          | RDASR, WRY -> false
                          | WRY, RDASR -> false
                          | RDASR, WRASR -> false
                          | WRASR, RDASR -> false
                          | RDASR, RDTBR -> false
                          | RDTBR, RDASR -> false
                          | RDASR, RDWIM -> false
                          | RDWIM, RDASR -> false
                          | RDASR, RDPSR -> false
                          | RDPSR, RDASR -> false
                          | RDASR, RDY -> false
                          | RDY, RDASR -> false
                          | WRTBR, WRTBR -> true
                          | WRWIM, WRWIM -> true
                          | WRPSR, WRPSR -> true
                          | WRY, WRY -> true
                          | WRASR, WRASR -> true
                          | RDTBR, RDTBR -> true
                          | RDWIM, RDWIM -> true
                          | RDPSR, RDPSR -> true
                          | RDY, RDY -> true
                          | RDASR, RDASR -> true;;

type ctrl_type = JMPL | RETT | SAVE | RESTORE;;

let rec equal_ctrl_type x0 x1 = match x0, x1 with SAVE, RESTORE -> false
                          | RESTORE, SAVE -> false
                          | RETT, RESTORE -> false
                          | RESTORE, RETT -> false
                          | RETT, SAVE -> false
                          | SAVE, RETT -> false
                          | JMPL, RESTORE -> false
                          | RESTORE, JMPL -> false
                          | JMPL, SAVE -> false
                          | SAVE, JMPL -> false
                          | JMPL, RETT -> false
                          | RETT, JMPL -> false
                          | RESTORE, RESTORE -> true
                          | SAVE, SAVE -> true
                          | RETT, RETT -> true
                          | JMPL, JMPL -> true;;

type call_type = CALL;;

let rec equal_call_type CALL CALL = true;;

type bicc_type = BE | BNE | BGU | BLE | BL | BGE | BNEG | BG | BCS | BLEU | BCC
  | BA | BN | BPOS | BVC | BVS;;

let rec equal_bicc_type x0 x1 = match x0, x1 with BVC, BVS -> false
                          | BVS, BVC -> false
                          | BPOS, BVS -> false
                          | BVS, BPOS -> false
                          | BPOS, BVC -> false
                          | BVC, BPOS -> false
                          | BN, BVS -> false
                          | BVS, BN -> false
                          | BN, BVC -> false
                          | BVC, BN -> false
                          | BN, BPOS -> false
                          | BPOS, BN -> false
                          | BA, BVS -> false
                          | BVS, BA -> false
                          | BA, BVC -> false
                          | BVC, BA -> false
                          | BA, BPOS -> false
                          | BPOS, BA -> false
                          | BA, BN -> false
                          | BN, BA -> false
                          | BCC, BVS -> false
                          | BVS, BCC -> false
                          | BCC, BVC -> false
                          | BVC, BCC -> false
                          | BCC, BPOS -> false
                          | BPOS, BCC -> false
                          | BCC, BN -> false
                          | BN, BCC -> false
                          | BCC, BA -> false
                          | BA, BCC -> false
                          | BLEU, BVS -> false
                          | BVS, BLEU -> false
                          | BLEU, BVC -> false
                          | BVC, BLEU -> false
                          | BLEU, BPOS -> false
                          | BPOS, BLEU -> false
                          | BLEU, BN -> false
                          | BN, BLEU -> false
                          | BLEU, BA -> false
                          | BA, BLEU -> false
                          | BLEU, BCC -> false
                          | BCC, BLEU -> false
                          | BCS, BVS -> false
                          | BVS, BCS -> false
                          | BCS, BVC -> false
                          | BVC, BCS -> false
                          | BCS, BPOS -> false
                          | BPOS, BCS -> false
                          | BCS, BN -> false
                          | BN, BCS -> false
                          | BCS, BA -> false
                          | BA, BCS -> false
                          | BCS, BCC -> false
                          | BCC, BCS -> false
                          | BCS, BLEU -> false
                          | BLEU, BCS -> false
                          | BG, BVS -> false
                          | BVS, BG -> false
                          | BG, BVC -> false
                          | BVC, BG -> false
                          | BG, BPOS -> false
                          | BPOS, BG -> false
                          | BG, BN -> false
                          | BN, BG -> false
                          | BG, BA -> false
                          | BA, BG -> false
                          | BG, BCC -> false
                          | BCC, BG -> false
                          | BG, BLEU -> false
                          | BLEU, BG -> false
                          | BG, BCS -> false
                          | BCS, BG -> false
                          | BNEG, BVS -> false
                          | BVS, BNEG -> false
                          | BNEG, BVC -> false
                          | BVC, BNEG -> false
                          | BNEG, BPOS -> false
                          | BPOS, BNEG -> false
                          | BNEG, BN -> false
                          | BN, BNEG -> false
                          | BNEG, BA -> false
                          | BA, BNEG -> false
                          | BNEG, BCC -> false
                          | BCC, BNEG -> false
                          | BNEG, BLEU -> false
                          | BLEU, BNEG -> false
                          | BNEG, BCS -> false
                          | BCS, BNEG -> false
                          | BNEG, BG -> false
                          | BG, BNEG -> false
                          | BGE, BVS -> false
                          | BVS, BGE -> false
                          | BGE, BVC -> false
                          | BVC, BGE -> false
                          | BGE, BPOS -> false
                          | BPOS, BGE -> false
                          | BGE, BN -> false
                          | BN, BGE -> false
                          | BGE, BA -> false
                          | BA, BGE -> false
                          | BGE, BCC -> false
                          | BCC, BGE -> false
                          | BGE, BLEU -> false
                          | BLEU, BGE -> false
                          | BGE, BCS -> false
                          | BCS, BGE -> false
                          | BGE, BG -> false
                          | BG, BGE -> false
                          | BGE, BNEG -> false
                          | BNEG, BGE -> false
                          | BL, BVS -> false
                          | BVS, BL -> false
                          | BL, BVC -> false
                          | BVC, BL -> false
                          | BL, BPOS -> false
                          | BPOS, BL -> false
                          | BL, BN -> false
                          | BN, BL -> false
                          | BL, BA -> false
                          | BA, BL -> false
                          | BL, BCC -> false
                          | BCC, BL -> false
                          | BL, BLEU -> false
                          | BLEU, BL -> false
                          | BL, BCS -> false
                          | BCS, BL -> false
                          | BL, BG -> false
                          | BG, BL -> false
                          | BL, BNEG -> false
                          | BNEG, BL -> false
                          | BL, BGE -> false
                          | BGE, BL -> false
                          | BLE, BVS -> false
                          | BVS, BLE -> false
                          | BLE, BVC -> false
                          | BVC, BLE -> false
                          | BLE, BPOS -> false
                          | BPOS, BLE -> false
                          | BLE, BN -> false
                          | BN, BLE -> false
                          | BLE, BA -> false
                          | BA, BLE -> false
                          | BLE, BCC -> false
                          | BCC, BLE -> false
                          | BLE, BLEU -> false
                          | BLEU, BLE -> false
                          | BLE, BCS -> false
                          | BCS, BLE -> false
                          | BLE, BG -> false
                          | BG, BLE -> false
                          | BLE, BNEG -> false
                          | BNEG, BLE -> false
                          | BLE, BGE -> false
                          | BGE, BLE -> false
                          | BLE, BL -> false
                          | BL, BLE -> false
                          | BGU, BVS -> false
                          | BVS, BGU -> false
                          | BGU, BVC -> false
                          | BVC, BGU -> false
                          | BGU, BPOS -> false
                          | BPOS, BGU -> false
                          | BGU, BN -> false
                          | BN, BGU -> false
                          | BGU, BA -> false
                          | BA, BGU -> false
                          | BGU, BCC -> false
                          | BCC, BGU -> false
                          | BGU, BLEU -> false
                          | BLEU, BGU -> false
                          | BGU, BCS -> false
                          | BCS, BGU -> false
                          | BGU, BG -> false
                          | BG, BGU -> false
                          | BGU, BNEG -> false
                          | BNEG, BGU -> false
                          | BGU, BGE -> false
                          | BGE, BGU -> false
                          | BGU, BL -> false
                          | BL, BGU -> false
                          | BGU, BLE -> false
                          | BLE, BGU -> false
                          | BNE, BVS -> false
                          | BVS, BNE -> false
                          | BNE, BVC -> false
                          | BVC, BNE -> false
                          | BNE, BPOS -> false
                          | BPOS, BNE -> false
                          | BNE, BN -> false
                          | BN, BNE -> false
                          | BNE, BA -> false
                          | BA, BNE -> false
                          | BNE, BCC -> false
                          | BCC, BNE -> false
                          | BNE, BLEU -> false
                          | BLEU, BNE -> false
                          | BNE, BCS -> false
                          | BCS, BNE -> false
                          | BNE, BG -> false
                          | BG, BNE -> false
                          | BNE, BNEG -> false
                          | BNEG, BNE -> false
                          | BNE, BGE -> false
                          | BGE, BNE -> false
                          | BNE, BL -> false
                          | BL, BNE -> false
                          | BNE, BLE -> false
                          | BLE, BNE -> false
                          | BNE, BGU -> false
                          | BGU, BNE -> false
                          | BE, BVS -> false
                          | BVS, BE -> false
                          | BE, BVC -> false
                          | BVC, BE -> false
                          | BE, BPOS -> false
                          | BPOS, BE -> false
                          | BE, BN -> false
                          | BN, BE -> false
                          | BE, BA -> false
                          | BA, BE -> false
                          | BE, BCC -> false
                          | BCC, BE -> false
                          | BE, BLEU -> false
                          | BLEU, BE -> false
                          | BE, BCS -> false
                          | BCS, BE -> false
                          | BE, BG -> false
                          | BG, BE -> false
                          | BE, BNEG -> false
                          | BNEG, BE -> false
                          | BE, BGE -> false
                          | BGE, BE -> false
                          | BE, BL -> false
                          | BL, BE -> false
                          | BE, BLE -> false
                          | BLE, BE -> false
                          | BE, BGU -> false
                          | BGU, BE -> false
                          | BE, BNE -> false
                          | BNE, BE -> false
                          | BVS, BVS -> true
                          | BVC, BVC -> true
                          | BPOS, BPOS -> true
                          | BN, BN -> true
                          | BA, BA -> true
                          | BCC, BCC -> true
                          | BLEU, BLEU -> true
                          | BCS, BCS -> true
                          | BG, BG -> true
                          | BNEG, BNEG -> true
                          | BGE, BGE -> true
                          | BL, BL -> true
                          | BLE, BLE -> true
                          | BGU, BGU -> true
                          | BNE, BNE -> true
                          | BE, BE -> true;;

type nop_type = NOP;;

let rec equal_nop_type NOP NOP = true;;

type sparc_operation = Call_type of call_type | Sethi_type of sethi_type |
  Nop_type of nop_type | Bicc_type of bicc_type |
  Load_store_type of load_store_type | Arith_type of arith_type |
  Logic_type of logic_type | Shift_type of shift_type | Ctrl_type of ctrl_type |
  Sreg_type of sreg_type | Uimp_type of uimp_type | Ticc_type of ticc_type;;

let rec equal_sparc_operationa
  x0 x1 = match x0, x1 with Uimp_type x11, Ticc_type x12 -> false
    | Ticc_type x12, Uimp_type x11 -> false
    | Sreg_type x10, Ticc_type x12 -> false
    | Ticc_type x12, Sreg_type x10 -> false
    | Sreg_type x10, Uimp_type x11 -> false
    | Uimp_type x11, Sreg_type x10 -> false
    | Ctrl_type x9, Ticc_type x12 -> false
    | Ticc_type x12, Ctrl_type x9 -> false
    | Ctrl_type x9, Uimp_type x11 -> false
    | Uimp_type x11, Ctrl_type x9 -> false
    | Ctrl_type x9, Sreg_type x10 -> false
    | Sreg_type x10, Ctrl_type x9 -> false
    | Shift_type x8, Ticc_type x12 -> false
    | Ticc_type x12, Shift_type x8 -> false
    | Shift_type x8, Uimp_type x11 -> false
    | Uimp_type x11, Shift_type x8 -> false
    | Shift_type x8, Sreg_type x10 -> false
    | Sreg_type x10, Shift_type x8 -> false
    | Shift_type x8, Ctrl_type x9 -> false
    | Ctrl_type x9, Shift_type x8 -> false
    | Logic_type x7, Ticc_type x12 -> false
    | Ticc_type x12, Logic_type x7 -> false
    | Logic_type x7, Uimp_type x11 -> false
    | Uimp_type x11, Logic_type x7 -> false
    | Logic_type x7, Sreg_type x10 -> false
    | Sreg_type x10, Logic_type x7 -> false
    | Logic_type x7, Ctrl_type x9 -> false
    | Ctrl_type x9, Logic_type x7 -> false
    | Logic_type x7, Shift_type x8 -> false
    | Shift_type x8, Logic_type x7 -> false
    | Arith_type x6, Ticc_type x12 -> false
    | Ticc_type x12, Arith_type x6 -> false
    | Arith_type x6, Uimp_type x11 -> false
    | Uimp_type x11, Arith_type x6 -> false
    | Arith_type x6, Sreg_type x10 -> false
    | Sreg_type x10, Arith_type x6 -> false
    | Arith_type x6, Ctrl_type x9 -> false
    | Ctrl_type x9, Arith_type x6 -> false
    | Arith_type x6, Shift_type x8 -> false
    | Shift_type x8, Arith_type x6 -> false
    | Arith_type x6, Logic_type x7 -> false
    | Logic_type x7, Arith_type x6 -> false
    | Load_store_type x5, Ticc_type x12 -> false
    | Ticc_type x12, Load_store_type x5 -> false
    | Load_store_type x5, Uimp_type x11 -> false
    | Uimp_type x11, Load_store_type x5 -> false
    | Load_store_type x5, Sreg_type x10 -> false
    | Sreg_type x10, Load_store_type x5 -> false
    | Load_store_type x5, Ctrl_type x9 -> false
    | Ctrl_type x9, Load_store_type x5 -> false
    | Load_store_type x5, Shift_type x8 -> false
    | Shift_type x8, Load_store_type x5 -> false
    | Load_store_type x5, Logic_type x7 -> false
    | Logic_type x7, Load_store_type x5 -> false
    | Load_store_type x5, Arith_type x6 -> false
    | Arith_type x6, Load_store_type x5 -> false
    | Bicc_type x4, Ticc_type x12 -> false
    | Ticc_type x12, Bicc_type x4 -> false
    | Bicc_type x4, Uimp_type x11 -> false
    | Uimp_type x11, Bicc_type x4 -> false
    | Bicc_type x4, Sreg_type x10 -> false
    | Sreg_type x10, Bicc_type x4 -> false
    | Bicc_type x4, Ctrl_type x9 -> false
    | Ctrl_type x9, Bicc_type x4 -> false
    | Bicc_type x4, Shift_type x8 -> false
    | Shift_type x8, Bicc_type x4 -> false
    | Bicc_type x4, Logic_type x7 -> false
    | Logic_type x7, Bicc_type x4 -> false
    | Bicc_type x4, Arith_type x6 -> false
    | Arith_type x6, Bicc_type x4 -> false
    | Bicc_type x4, Load_store_type x5 -> false
    | Load_store_type x5, Bicc_type x4 -> false
    | Nop_type x3, Ticc_type x12 -> false
    | Ticc_type x12, Nop_type x3 -> false
    | Nop_type x3, Uimp_type x11 -> false
    | Uimp_type x11, Nop_type x3 -> false
    | Nop_type x3, Sreg_type x10 -> false
    | Sreg_type x10, Nop_type x3 -> false
    | Nop_type x3, Ctrl_type x9 -> false
    | Ctrl_type x9, Nop_type x3 -> false
    | Nop_type x3, Shift_type x8 -> false
    | Shift_type x8, Nop_type x3 -> false
    | Nop_type x3, Logic_type x7 -> false
    | Logic_type x7, Nop_type x3 -> false
    | Nop_type x3, Arith_type x6 -> false
    | Arith_type x6, Nop_type x3 -> false
    | Nop_type x3, Load_store_type x5 -> false
    | Load_store_type x5, Nop_type x3 -> false
    | Nop_type x3, Bicc_type x4 -> false
    | Bicc_type x4, Nop_type x3 -> false
    | Sethi_type x2, Ticc_type x12 -> false
    | Ticc_type x12, Sethi_type x2 -> false
    | Sethi_type x2, Uimp_type x11 -> false
    | Uimp_type x11, Sethi_type x2 -> false
    | Sethi_type x2, Sreg_type x10 -> false
    | Sreg_type x10, Sethi_type x2 -> false
    | Sethi_type x2, Ctrl_type x9 -> false
    | Ctrl_type x9, Sethi_type x2 -> false
    | Sethi_type x2, Shift_type x8 -> false
    | Shift_type x8, Sethi_type x2 -> false
    | Sethi_type x2, Logic_type x7 -> false
    | Logic_type x7, Sethi_type x2 -> false
    | Sethi_type x2, Arith_type x6 -> false
    | Arith_type x6, Sethi_type x2 -> false
    | Sethi_type x2, Load_store_type x5 -> false
    | Load_store_type x5, Sethi_type x2 -> false
    | Sethi_type x2, Bicc_type x4 -> false
    | Bicc_type x4, Sethi_type x2 -> false
    | Sethi_type x2, Nop_type x3 -> false
    | Nop_type x3, Sethi_type x2 -> false
    | Call_type x1, Ticc_type x12 -> false
    | Ticc_type x12, Call_type x1 -> false
    | Call_type x1, Uimp_type x11 -> false
    | Uimp_type x11, Call_type x1 -> false
    | Call_type x1, Sreg_type x10 -> false
    | Sreg_type x10, Call_type x1 -> false
    | Call_type x1, Ctrl_type x9 -> false
    | Ctrl_type x9, Call_type x1 -> false
    | Call_type x1, Shift_type x8 -> false
    | Shift_type x8, Call_type x1 -> false
    | Call_type x1, Logic_type x7 -> false
    | Logic_type x7, Call_type x1 -> false
    | Call_type x1, Arith_type x6 -> false
    | Arith_type x6, Call_type x1 -> false
    | Call_type x1, Load_store_type x5 -> false
    | Load_store_type x5, Call_type x1 -> false
    | Call_type x1, Bicc_type x4 -> false
    | Bicc_type x4, Call_type x1 -> false
    | Call_type x1, Nop_type x3 -> false
    | Nop_type x3, Call_type x1 -> false
    | Call_type x1, Sethi_type x2 -> false
    | Sethi_type x2, Call_type x1 -> false
    | Ticc_type x12, Ticc_type y12 -> equal_ticc_type x12 y12
    | Uimp_type x11, Uimp_type y11 -> equal_uimp_type x11 y11
    | Sreg_type x10, Sreg_type y10 -> equal_sreg_type x10 y10
    | Ctrl_type x9, Ctrl_type y9 -> equal_ctrl_type x9 y9
    | Shift_type x8, Shift_type y8 -> equal_shift_type x8 y8
    | Logic_type x7, Logic_type y7 -> equal_logic_type x7 y7
    | Arith_type x6, Arith_type y6 -> equal_arith_type x6 y6
    | Load_store_type x5, Load_store_type y5 -> equal_load_store_type x5 y5
    | Bicc_type x4, Bicc_type y4 -> equal_bicc_type x4 y4
    | Nop_type x3, Nop_type y3 -> equal_nop_type x3 y3
    | Sethi_type x2, Sethi_type y2 -> equal_sethi_type x2 y2
    | Call_type x1, Call_type y1 -> equal_call_type x1 y1;;

let equal_sparc_operation =
  ({equal = equal_sparc_operationa} : sparc_operation equal);;

type 'a set = Set of 'a list | Coset of 'a list;;

type ('a, 'b) sum = Inl of 'a | Inr of 'b;;

type exceptiona = Invalid_cond_f2 | Invalid_op2_f2 | Illegal_instruction2 |
  Invalid_op3_f3_op11 | Case_impossible | Invalid_op3_f3_op10 | Invalid_op_f3 |
  Unsupported_instruction | Fetch_instruction_error | Invalid_trap_cond;;

type word_length9 = EMPTY__;;

type 'a mMU_state_ext =
  MMU_state_ext of (mMU_register -> word_length32 word) * 'a;;

type inst_operand = W5 of word_length5 word | W30 of word_length30 word |
  W22 of word_length22 word | Cond of word_length4 word |
  Flag of word_length1 word | Asi of word_length8 word |
  Simm13 of word_length13 word | Opf of word_length9 word |
  Imm7 of word_length7 word;;

type 'a cpu_cache_ext =
  Cpu_cache_ext of
    (word_length20 word * word_length12 word -> word_length8 word option) *
      (word_length20 word * word_length12 word -> word_length8 word option) *
      'a;;

type 'a sparc_state_var_ext =
  Sparc_state_var_ext of
    bool * bool * bool * bool * bool * word_length7 word * word_length3 word *
      bool * (word_length32 word -> bool) * (word_length32 word -> bool) * 'a;;

type ('a, 'b) sparc_state_ext =
  Sparc_state_ext of
    (cPU_register -> word_length32 word) *
      ('a word -> word_length5 word -> word_length32 word) *
      (sys_reg -> word_length32 word) *
      (word_length8 word -> word_length36 word -> word_length8 word option) *
      unit mMU_state_ext * unit cpu_cache_ext *
      (int * (word_length32 word * cPU_register)) list *
      unit sparc_state_var_ext * trap set * bool * 'b;;

let rec id x = (fun xa -> xa) x;;

let rec nat = function Pos k -> nat_of_num k
              | Zero_int -> Zero_nat
              | Neg k -> Zero_nat;;

let rec comp f g = (fun x -> f (g x));;

let rec nth x0 x1 = match x0, x1 with x :: xs, Suc n -> nth xs n
              | x :: xs, Zero_nat -> x;;

let rec fold f x1 s = match f, x1, s with f, x :: xs, s -> fold f xs (f x s)
               | f, [], s -> s;;

let rec null = function [] -> true
               | x :: xs -> false;;

let rec minus_nat m n = match m, n with Suc m, Suc n -> minus_nat m n
                    | Zero_nat, n -> Zero_nat
                    | m, Zero_nat -> m;;

let rec less_eq_num x0 n = match x0, n with Bit1 m, Bit0 n -> less_num m n
                      | Bit1 m, Bit1 n -> less_eq_num m n
                      | Bit0 m, Bit1 n -> less_eq_num m n
                      | Bit0 m, Bit0 n -> less_eq_num m n
                      | Bit1 m, One -> false
                      | Bit0 m, One -> false
                      | One, n -> true
and less_num m x1 = match m, x1 with Bit1 m, Bit0 n -> less_num m n
               | Bit1 m, Bit1 n -> less_num m n
               | Bit0 m, Bit1 n -> less_eq_num m n
               | Bit0 m, Bit0 n -> less_num m n
               | One, Bit1 n -> true
               | One, Bit0 n -> true
               | m, One -> false;;

let rec less_eq_int x0 x1 = match x0, x1 with Neg k, Neg l -> less_eq_num l k
                      | Neg k, Pos l -> true
                      | Neg k, Zero_int -> true
                      | Pos k, Neg l -> false
                      | Pos k, Pos l -> less_eq_num k l
                      | Pos k, Zero_int -> false
                      | Zero_int, Neg l -> false
                      | Zero_int, Pos l -> true
                      | Zero_int, Zero_int -> true;;

let rec divmod_step_int
  l (q, r) =
    (if less_eq_int (Pos l) r
      then (plus_inta (times_inta (Pos (Bit0 One)) q) one_inta,
             minus_int r (Pos l))
      else (times_inta (Pos (Bit0 One)) q, r));;

let rec divmod_int
  x0 x1 = match x0, x1 with
    Bit1 m, Bit1 n ->
      (if less_num m n then (Zero_int, Pos (Bit1 m))
        else divmod_step_int (Bit1 n) (divmod_int (Bit1 m) (Bit0 (Bit1 n))))
    | Bit0 m, Bit1 n ->
        (if less_eq_num m n then (Zero_int, Pos (Bit0 m))
          else divmod_step_int (Bit1 n) (divmod_int (Bit0 m) (Bit0 (Bit1 n))))
    | Bit1 m, Bit0 n ->
        (let (q, r) = divmod_int m n in
          (q, plus_inta (times_inta (Pos (Bit0 One)) r) one_inta))
    | Bit0 m, Bit0 n ->
        (let (q, r) = divmod_int m n in (q, times_inta (Pos (Bit0 One)) r))
    | One, Bit1 n -> (Zero_int, Pos One)
    | One, Bit0 n -> (Zero_int, Pos One)
    | Bit1 m, One -> (Pos (Bit1 m), Zero_int)
    | Bit0 m, One -> (Pos (Bit0 m), Zero_int)
    | One, One -> (Pos One, Zero_int);;

let rec fst (x1, x2) = x1;;

let rec of_bool _A = function true -> one _A.one_zero_neq_one
                     | false -> zero _A.zero_zero_neq_one;;

let rec adjust_div
  (q, r) =
    plus_inta q (of_bool zero_neq_one_int (not (equal_inta r Zero_int)));;

let rec divide_int
  k ka = match k, ka with Neg m, Neg n -> fst (divmod_int m n)
    | Pos m, Neg n -> uminus_int (adjust_div (divmod_int m n))
    | Neg m, Pos n -> uminus_int (adjust_div (divmod_int m n))
    | Pos m, Pos n -> fst (divmod_int m n)
    | k, Neg One -> uminus_int k
    | k, Pos One -> k
    | Zero_int, k -> Zero_int
    | k, Zero_int -> Zero_int;;

let rec bin_rest w = divide_int w (Pos (Bit0 One));;

let rec snd (x1, x2) = x2;;

let rec adjust_mod
  l r = (if equal_inta r Zero_int then Zero_int else minus_int l r);;

let rec modulo_int
  k ka = match k, ka with Neg m, Neg n -> uminus_int (snd (divmod_int m n))
    | Pos m, Neg n -> uminus_int (adjust_mod (Pos n) (snd (divmod_int m n)))
    | Neg m, Pos n -> adjust_mod (Pos n) (snd (divmod_int m n))
    | Pos m, Pos n -> snd (divmod_int m n)
    | k, Neg One -> Zero_int
    | k, Pos One -> Zero_int
    | Zero_int, k -> Zero_int
    | k, Zero_int -> k;;

let rec bin_last w = equal_inta (modulo_int w (Pos (Bit0 One))) one_inta;;

let rec bit k b = plus_inta (plus_inta (if b then one_inta else Zero_int) k) k;;

let rec sbintrunc
  x0 bin = match x0, bin with
    Zero_nat, bin -> (if bin_last bin then uminus_int one_inta else Zero_int)
    | Suc n, bin -> bit (sbintrunc n (bin_rest bin)) (bin_last bin);;

let rec sint _A
  w = sbintrunc (minus_nat (len_of _A.len0_len Type) one_nat)
        (uint _A.len0_len w);;

let rec unat _A w = nat (uint _A w);;

let rec funpow x0 f = match x0, f with Zero_nat, f -> id
                 | Suc n, f -> comp f (funpow n f);;

let rec removeAll _A
  x xa1 = match x, xa1 with x, [] -> []
    | x, y :: xs ->
        (if eq _A x y then removeAll _A x xs else y :: removeAll _A x xs);;

let rec membera _A x0 y = match x0, y with [], y -> false
                     | x :: xs, y -> eq _A x y || membera _A xs y;;

let rec inserta _A x xs = (if membera _A xs x then xs else x :: xs);;

let rec insert _A
  x xa1 = match x, xa1 with x, Coset xs -> Coset (removeAll _A x xs)
    | x, Set xs -> Set (inserta _A x xs);;

let rec member _A
  x xa1 = match x, xa1 with x, Coset xs -> not (membera _A xs x)
    | x, Set xs -> membera _A xs x;;

let rec power _A a x1 = match a, x1 with a, Zero_nat -> one _A.one_power
                   | a, Suc n -> times _A.times_power a (power _A a n);;

let rec word_of_int _A
  k = Word (modulo_int k (power power_int (Pos (Bit0 One)) (len_of _A Type)));;

let rec ucast _A _B w = word_of_int _B (uint _A w);;

let rec h1 f s = f s;;

let rec h2 g fs = (let a = fst fs in
                   let (aa, b) = a in
                    g aa b);;

let rec fun_upd _A f a b = (fun x -> (if eq _A x a then b else f x));;

let rec filter
  p x1 = match p, x1 with p, [] -> []
    | p, x :: xs -> (if p x then x :: filter p xs else filter p xs);;

let rec get x = (fun s -> ((s, s), false)) x;;

let rec put s = (fun _ -> (((), s), false));;

let rec remove1 _A
  x xa1 = match x, xa1 with x, [] -> []
    | x, y :: xs -> (if eq _A x y then xs else y :: remove1 _A x xs);;

let rec shiftl1 _A w = word_of_int _A (bit (uint _A w) false);;

let rec shiftr1 _A w = word_of_int _A (bin_rest (uint _A w));;

let rec sshiftr1 _A w = word_of_int _A.len0_len (bin_rest (sint _A w));;

let rec sshiftr _A w n = funpow n (sshiftr1 _A) w;;

let rec bind f g = (fun s -> (let fs = h1 f s in
                              let v = h2 g fs in
                               (fst v, snd v || snd fs)));;

let rec fail a = (fun s -> ((a, s), true));;

let rec return a = (fun s -> ((a, s), false));;

let rec gets f = bind get (fun s -> return (f s));;

let rec zero_word _A = word_of_int _A Zero_int;;

let rec mMU_registers_init r = zero_word len0_word_length32;;

let mmu_setup : unit mMU_state_ext = MMU_state_ext (mMU_registers_init, ());;

let rec bin_cat w x1 v = match w, x1, v with w, Zero_nat, v -> w
                  | w, Suc n, v -> bit (bin_cat w n (bin_rest v)) (bin_last v);;

let rec word_cat _A _B _C
  a b = word_of_int _C (bin_cat (uint _A a) (len_of _B Type) (uint _B b));;

let rec shiftr_word _A w n = funpow n (shiftr1 _A) w;;

let rec shiftl_word _A w n = funpow n (shiftl1 _A) w;;

let rec bitAND_int
  x y = (if equal_inta x Zero_int then Zero_int
          else (if equal_inta x (uminus_int one_inta) then y
                 else bit (bitAND_int (bin_rest x) (bin_rest y))
                        (bin_last x && bin_last y)));;

let rec bitAND_word _A
  a b = word_of_int _A (bitAND_int (uint _A a) (uint _A b));;

let rec bitNOT_int x = (fun xa -> minus_int (uminus_int xa) one_inta) x;;

let rec bitOR_int
  x = (fun xa y -> bitNOT_int (bitAND_int (bitNOT_int xa) (bitNOT_int y))) x;;

let rec bitOR_word _A a b = word_of_int _A (bitOR_int (uint _A a) (uint _A b));;

let rec equal_nat x0 x1 = match x0, x1 with Zero_nat, Suc x2 -> false
                    | Suc x2, Zero_nat -> false
                    | Suc x2, Suc y2 -> equal_nat x2 y2
                    | Zero_nat, Zero_nat -> true;;

let rec one_word _A = word_of_int _A one_inta;;

let rec less_nat m x1 = match m, x1 with m, Suc n -> less_eq_nat m n
                   | n, Zero_nat -> false
and less_eq_nat x0 n = match x0, n with Suc m, n -> less_nat m n
                  | Zero_nat, n -> true;;

let rec is_none = function Some x -> false
                  | None -> true;;

let rec mem_context_val
  asi add m =
    (let asi8 = word_of_int len0_word_length8 (Pos (Bit0 (Bit0 (Bit0 One)))) in
     let r1 = m asi add in
      (if is_none r1 then m asi8 add else r1));;

let rec mem_context_val_w32
  asi addr m =
    (let addra =
       bitAND_word len0_word_length36 addr
         (word_of_int len0_word_length36
           (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 One)))))))))))))))))))))))))))))))))))))
       in
     let addr0 =
       bitOR_word len0_word_length36 addra (zero_word len0_word_length36) in
     let addr1 =
       bitOR_word len0_word_length36 addra (one_word len0_word_length36) in
     let addr2 =
       bitOR_word len0_word_length36 addra
         (word_of_int len0_word_length36 (Pos (Bit0 One)))
       in
     let addr3 =
       bitOR_word len0_word_length36 addra
         (word_of_int len0_word_length36 (Pos (Bit1 One)))
       in
     let r0 = mem_context_val asi addr0 m in
     let r1 = mem_context_val asi addr1 m in
     let r2 = mem_context_val asi addr2 m in
     let r3 = mem_context_val asi addr3 m in
      (if is_none r0 || (is_none r1 || (is_none r2 || is_none r3)) then None
        else (let byte0 = (let Some v = r0 in v) in
              let byte1 = (let Some v = r1 in v) in
              let byte2 = (let Some v = r2 in v) in
              let byte3 = (let Some v = r3 in v) in
               Some (bitOR_word len0_word_length32
                      (bitOR_word len0_word_length32
                        (bitOR_word len0_word_length32
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte0)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte1)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One)))))))
                        (shiftl_word len0_word_length32
                          (ucast len0_word_length8 len0_word_length32 byte2)
                          (nat_of_num (Bit0 (Bit0 (Bit0 One))))))
                      (ucast len0_word_length8 len0_word_length32 byte3)))));;

let rec ptd_lookup
  va pt m lvl =
    (if less_nat (nat_of_num (Bit1 One)) lvl then None
      else (let thislvl_offset =
              (if equal_nat lvl one_nat
                then ucast len0_word_length8 len0_word_length32
                       (ucast len0_word_length32 len0_word_length8
                         (shiftr_word len0_word_length32 va
                           (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One)))))))
                else (if equal_nat lvl (nat_of_num (Bit0 One))
                       then ucast len0_word_length6 len0_word_length32
                              (ucast len0_word_length32 len0_word_length6
                                (shiftr_word len0_word_length32 va
                                  (nat_of_num (Bit0 (Bit1 (Bit0 (Bit0 One)))))))
                       else ucast len0_word_length6 len0_word_length32
                              (ucast len0_word_length32 len0_word_length6
                                (shiftr_word len0_word_length32 va
                                  (nat_of_num (Bit0 (Bit0 (Bit1 One))))))))
              in
            let thislvl_addr = bitOR_word len0_word_length32 pt thislvl_offset
              in
             (match
               mem_context_val_w32
                 (word_of_int len0_word_length8 (Pos (Bit1 (Bit0 (Bit0 One)))))
                 (ucast len0_word_length32 len0_word_length36 thislvl_addr) m
               with None -> None
               | Some v ->
                 (let et_val =
                    bitAND_word len0_word_length32 v
                      (word_of_int len0_word_length32 (Pos (Bit1 One)))
                    in
                   (if equal_worda len0_word_length32 et_val
                         (zero_word len0_word_length32)
                     then None
                     else (if equal_worda len0_word_length32 et_val
                                (one_word len0_word_length32)
                            then (let ptp =
                                    bitAND_word len0_word_length32 v
                                      (word_of_int len0_word_length32
(Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
   (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
     (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
   (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
                                    in
                                   ptd_lookup va ptp m (plus_nat lvl one_nat))
                            else (if equal_worda len0_word_length32 et_val
                                       (word_of_int len0_word_length32
 (Pos (Bit0 One)))
                                   then (let ppn =
   ucast len0_word_length32 len0_word_length24
     (shiftr_word len0_word_length32 v (nat_of_num (Bit0 (Bit0 (Bit0 One)))))
   in
 let va_offset =
   ucast len0_word_length12 len0_word_length36
     (ucast len0_word_length32 len0_word_length12 va)
   in
  Some (bitOR_word len0_word_length36
          (shiftl_word len0_word_length36
            (ucast len0_word_length24 len0_word_length36 ppn)
            (nat_of_num (Bit0 (Bit0 (Bit1 One)))))
          va_offset,
         ucast len0_word_length32 len0_word_length8 v))
                                   else None)))))));;

let rec k_bind x = (fun xa _ -> xa) x;;

let rec modify f = bind get (fun s -> put (f s));;

let rec registers_update
  registersa (MMU_state_ext (registers, more)) =
    MMU_state_ext (registersa registers, more);;

let rec registers (MMU_state_ext (registers, more)) = registers;;

let rec mmu_reg_mod
  mmu_state addr w =
    (if equal_worda len0_word_length32 addr (zero_word len0_word_length32)
      then Some (registers_update
                  (fun _ ->
                    fun_upd equal_MMU_register (registers mmu_state) CR w)
                  mmu_state)
      else (if equal_worda len0_word_length32 addr
                 (word_of_int len0_word_length32
                   (Pos (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))
             then Some (registers_update
                         (fun _ ->
                           fun_upd equal_MMU_register (registers mmu_state) CTP
                             w)
                         mmu_state)
             else (if equal_worda len0_word_length32 addr
                        (word_of_int len0_word_length32
                          (Pos (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))
                    then Some (registers_update
                                (fun _ ->
                                  fun_upd equal_MMU_register
                                    (registers mmu_state) CNR w)
                                mmu_state)
                    else (if equal_worda len0_word_length32 addr
                               (word_of_int len0_word_length32
                                 (Pos (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 One)))))))))))
                           then Some (registers_update
                                       (fun _ ->
 fun_upd equal_MMU_register (registers mmu_state) FTSR w)
                                       mmu_state)
                           else (if equal_worda len0_word_length32 addr
                                      (word_of_int len0_word_length32
(Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))))
                                  then Some (registers_update
      (fun _ -> fun_upd equal_MMU_register (registers mmu_state) FAR w)
      mmu_state)
                                  else None)))));;

let rec mmu_reg_val
  mmu_state addr =
    (if equal_worda len0_word_length32 addr (zero_word len0_word_length32)
      then Some (registers mmu_state CR)
      else (if equal_worda len0_word_length32 addr
                 (word_of_int len0_word_length32
                   (Pos (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))
             then Some (registers mmu_state CTP)
             else (if equal_worda len0_word_length32 addr
                        (word_of_int len0_word_length32
                          (Pos (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))
                    then Some (registers mmu_state CNR)
                    else (if equal_worda len0_word_length32 addr
                               (word_of_int len0_word_length32
                                 (Pos (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 One)))))))))))
                           then Some (registers mmu_state FTSR)
                           else (if equal_worda len0_word_length32 addr
                                      (word_of_int len0_word_length32
(Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))))
                                  then Some (registers mmu_state FAR)
                                  else None)))));;

let rec get_acc_flag
  w8 = ucast len0_word_length8 len0_word_length3
         (shiftr_word len0_word_length8 w8 (nat_of_num (Bit0 One)));;

let bot_set : 'a set = Set [];;

let rec mmu_readable
  f asi =
    (if member equal_int (uint len0_word_length8 asi)
          (insert equal_int (Pos (Bit0 (Bit0 (Bit0 One))))
            (insert equal_int (Pos (Bit0 (Bit1 (Bit0 One)))) bot_set))
      then (if member equal_int (uint len0_word_length3 f)
                 (insert equal_int Zero_int
                   (insert equal_int one_inta
                     (insert equal_int (Pos (Bit0 One))
                       (insert equal_int (Pos (Bit1 One))
                         (insert equal_int (Pos (Bit1 (Bit0 One))) bot_set)))))
             then true else false)
      else (if member equal_int (uint len0_word_length8 asi)
                 (insert equal_int (Pos (Bit1 (Bit0 (Bit0 One))))
                   (insert equal_int (Pos (Bit1 (Bit1 (Bit0 One)))) bot_set))
             then (if member equal_int (uint len0_word_length3 f)
                        (insert equal_int Zero_int
                          (insert equal_int one_inta
                            (insert equal_int (Pos (Bit0 One))
                              (insert equal_int (Pos (Bit1 One))
                                (insert equal_int (Pos (Bit1 (Bit0 One)))
                                  (insert equal_int (Pos (Bit0 (Bit1 One)))
                                    (insert equal_int (Pos (Bit1 (Bit1 One)))
                                      bot_set)))))))
                    then true else false)
             else false));;

let rec mmu_writable
  f asi =
    (if member equal_int (uint len0_word_length8 asi)
          (insert equal_int (Pos (Bit0 (Bit0 (Bit0 One))))
            (insert equal_int (Pos (Bit0 (Bit1 (Bit0 One)))) bot_set))
      then (if member equal_int (uint len0_word_length3 f)
                 (insert equal_int one_inta
                   (insert equal_int (Pos (Bit1 One)) bot_set))
             then true else false)
      else (if member equal_int (uint len0_word_length8 asi)
                 (insert equal_int (Pos (Bit1 (Bit0 (Bit0 One))))
                   (insert equal_int (Pos (Bit1 (Bit1 (Bit0 One)))) bot_set))
             then (if member equal_int (uint len0_word_length3 f)
                        (insert equal_int one_inta
                          (insert equal_int (Pos (Bit1 One))
                            (insert equal_int (Pos (Bit1 (Bit0 One)))
                              (insert equal_int (Pos (Bit1 (Bit1 One)))
                                bot_set))))
                    then true else false)
             else false));;

let rec virt_to_phys
  va mmu m =
    (let ctp_val =
       mmu_reg_val mmu
         (word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))
       in
     let cnr_val =
       mmu_reg_val mmu
         (word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))
       in
     let mmu_cr_val = registers mmu CR in
      (if not (equal_worda len0_word_length32
                (bitAND_word len0_word_length32 mmu_cr_val
                  (one_word len0_word_length32))
                (zero_word len0_word_length32))
        then (match (ctp_val, cnr_val) with (None, _) -> None
               | (Some _, None) -> None
               | (Some v1, Some v2) ->
                 (let context_table_entry =
                    bitOR_word len0_word_length32
                      (shiftl_word len0_word_length32
                        (shiftr_word len0_word_length32 v1
                          (nat_of_num (Bit1 (Bit1 (Bit0 One)))))
                        (nat_of_num (Bit1 (Bit1 (Bit0 One)))))
                      (shiftl_word len0_word_length32
                        (bitAND_word len0_word_length32 v2
                          (word_of_int len0_word_length32
                            (Pos (Bit1 (Bit1
 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))
                        (nat_of_num (Bit0 One)))
                    in
                   (match
                     mem_context_val_w32
                       (word_of_int len0_word_length8
                         (Pos (Bit1 (Bit0 (Bit0 One)))))
                       (ucast len0_word_length32 len0_word_length36
                         context_table_entry)
                       m
                     with None -> None
                     | Some lvl1_page_table ->
                       ptd_lookup va lvl1_page_table m one_nat)))
        else Some (ucast len0_word_length32 len0_word_length36 va,
                    word_of_int len0_word_length8
                      (Pos (Bit1 (Bit1 (Bit1
 (Bit1 (Bit0 (Bit1 (Bit1 One)))))))))));;

let rec get_S
  psr = (if equal_worda len0_word_length32
              (bitAND_word len0_word_length32 psr
                (word_of_int len0_word_length32
                  (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))
              (zero_word len0_word_length32)
          then zero_word len0_word_length1 else one_word len0_word_length1);;

let rec list_all p x1 = match p, x1 with p, [] -> true
                   | p, x :: xs -> p x && list_all p xs;;

let rec get_ET
  psr = ucast len0_word_length32 len0_word_length1
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 psr
              (word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))
            (nat_of_num (Bit1 (Bit0 One))));;

let rec get_PS
  psr = ucast len0_word_length32 len0_word_length1
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 psr
              (word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))
            (nat_of_num (Bit0 (Bit1 One))));;

let rec mem_update
  mema (Sparc_state_ext
         (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
           undef, more))
    = Sparc_state_ext
        (cpu_reg, user_reg, sys_reg, mema mem, mmu, cache, dwrite, state_var,
          traps, undef, more);;

let rec mem
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = mem;;

let rec mem_mod
  asi addr vala state =
    (let state1 =
       mem_update
         (fun _ ->
           fun_upd (equal_word len0_word_length8) (mem state) asi
             (fun_upd (equal_word len0_word_length36) (mem state asi) addr
               (Some vala)))
         state
       in
      (if equal_inta (uint len0_word_length8 asi)
            (Pos (Bit0 (Bit0 (Bit0 One)))) ||
            equal_inta (uint len0_word_length8 asi)
              (Pos (Bit0 (Bit1 (Bit0 One))))
        then (let asi2 =
                word_of_int len0_word_length8
                  (plus_inta (uint len0_word_length8 asi) one_inta)
                in
               mem_update
                 (fun _ ->
                   fun_upd (equal_word len0_word_length8) (mem state1) asi2
                     (fun_upd (equal_word len0_word_length36) (mem state1 asi2)
                       addr None))
                 state1)
        else (if equal_inta (uint len0_word_length8 asi)
                   (Pos (Bit1 (Bit0 (Bit0 One)))) ||
                   equal_inta (uint len0_word_length8 asi)
                     (Pos (Bit1 (Bit1 (Bit0 One))))
               then (let asi2 =
                       word_of_int len0_word_length8
                         (minus_int (uint len0_word_length8 asi) one_inta)
                       in
                      mem_update
                        (fun _ ->
                          fun_upd (equal_word len0_word_length8) (mem state1)
                            asi2
                            (fun_upd (equal_word len0_word_length36)
                              (mem state1 asi2) addr None))
                        state1)
               else state1)));;

let rec get_CWP
  psr = ucast len0_word_length32 len0_word_length5
          (bitAND_word len0_word_length32 psr
            (word_of_int len0_word_length32
              (Pos (Bit1 (Bit1 (Bit1 (Bit1 One)))))));;

let rec get_PIL
  psr = ucast len0_word_length32 len0_word_length4
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 psr
              (word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1 (Bit1 One))))))))))))))
            (nat_of_num (Bit0 (Bit0 (Bit0 One)))));;

let rec exe_pool w = (let (n, (v, c)) = w in (minus_int n one_inta, (v, c)));;

let delaynum : int = Zero_int;;

let nwindows : int = Pos (Bit0 (Bit0 (Bit0 One)));;

let rec update_S
  s_val psr_val =
    (let tmp0 =
       bitAND_word len0_word_length32 psr_val
         (word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit0 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
       in
      bitOR_word len0_word_length32 tmp0
        (shiftl_word len0_word_length32
          (ucast len0_word_length1 len0_word_length32 s_val)
          (nat_of_num (Bit1 (Bit1 One)))));;

let rec write_tt
  new_tt_val tbr_val =
    (let tmp =
       bitAND_word len0_word_length32 tbr_val
         (word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One))))))))))))))))))))))))))))))))))
       in
      bitOR_word len0_word_length32 tmp
        (shiftl_word len0_word_length32
          (ucast len0_word_length8 len0_word_length32 new_tt_val)
          (nat_of_num (Bit0 (Bit0 One)))));;

let rec state_var_update
  state_vara
    (Sparc_state_ext
      (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
        undef, more))
    = Sparc_state_ext
        (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite,
          state_vara state_var, traps, undef, more);;

let rec state_var
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = state_var;;

let rec annul_update
  annula
    (Sparc_state_var_ext
      (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
        atm_ldst_word, more))
    = Sparc_state_var_ext
        (annula annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar,
          atm_ldst_byte, atm_ldst_word, more);;

let rec write_annul b v = annul_update (fun _ -> b) v;;

let rec annul_mod
  b s = state_var_update (fun _ -> write_annul b (state_var s)) s;;

let rec annul
  (Sparc_state_var_ext
    (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
      atm_ldst_word, more))
    = annul;;

let rec get_annul v = annul v;;

let rec annul_val state = get_annul (state_var state);;

let rec cache_update
  cachea
    (Sparc_state_ext
      (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
        undef, more))
    = Sparc_state_ext
        (cpu_reg, user_reg, sys_reg, mem, mmu, cachea cache, dwrite, state_var,
          traps, undef, more);;

let rec icache_update
  icachea (Cpu_cache_ext (dcache, icache, more)) =
    Cpu_cache_ext (dcache, icachea icache, more);;

let rec cache
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = cache;;

let rec empty_cache c = None;;

let rec flush_instr_cache
  state =
    cache_update (fun _ -> icache_update (fun _ -> empty_cache) (cache state))
      state;;

let rec dcache_update
  dcachea (Cpu_cache_ext (dcache, icache, more)) =
    Cpu_cache_ext (dcachea dcache, icache, more);;

let rec flush_data_cache
  state =
    cache_update (fun _ -> dcache_update (fun _ -> empty_cache) (cache state))
      state;;

let rec sys_reg
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = sys_reg;;

let rec sys_reg_val reg state = sys_reg state reg;;

let rec ccr_flush
  state =
    (let ccr_val = sys_reg_val CCR state in
     let fi_val =
       shiftr_word len0_word_length32
         (bitAND_word len0_word_length32 ccr_val
           (word_of_int len0_word_length32
             (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 One))))))))))))))))))))))))
         (nat_of_num (Bit1 (Bit0 (Bit1 (Bit0 One)))))
       in
     let fd_val =
       shiftr_word len0_word_length32
         (bitAND_word len0_word_length32 ccr_val
           (word_of_int len0_word_length32
             (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 One)))))))))))))))))))))))))
         (nat_of_num (Bit0 (Bit1 (Bit1 (Bit0 One)))))
       in
     let state1 =
       (if equal_worda len0_word_length32 fi_val (one_word len0_word_length32)
         then flush_instr_cache state else state)
       in
      (if equal_worda len0_word_length32 fd_val (one_word len0_word_length32)
        then flush_data_cache state1 else state1));;

let rec set_annul b = bind (modify (annul_mod b)) (k_bind (return ()));;

let rec cpu_reg_update
  cpu_rega
    (Sparc_state_ext
      (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
        undef, more))
    = Sparc_state_ext
        (cpu_rega cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite,
          state_var, traps, undef, more);;

let rec cpu_reg
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = cpu_reg;;

let rec cpu_reg_mod
  data_w32 cpu state =
    cpu_reg_update
      (fun _ -> fun_upd equal_CPU_register (cpu_reg state) cpu data_w32) state;;

let rec write_cpu w cr = bind (modify (cpu_reg_mod w cr)) (k_bind (return ()));;

let rec user_reg_update
  user_rega
    (Sparc_state_ext
      (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
        undef, more))
    = Sparc_state_ext
        (cpu_reg, user_rega user_reg, sys_reg, mem, mmu, cache, dwrite,
          state_var, traps, undef, more);;

let rec user_reg
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = user_reg;;

let rec less_int x0 x1 = match x0, x1 with Neg k, Neg l -> less_num l k
                   | Neg k, Pos l -> true
                   | Neg k, Zero_int -> true
                   | Pos k, Neg l -> false
                   | Pos k, Pos l -> less_num k l
                   | Pos k, Zero_int -> false
                   | Zero_int, Neg l -> false
                   | Zero_int, Pos l -> true
                   | Zero_int, Zero_int -> false;;

let rec less_word _A a b = less_int (uint _A a) (uint _A b);;

let rec of_nat_aux _A inc x1 i = match inc, x1, i with inc, Zero_nat, i -> i
                        | inc, Suc n, i -> of_nat_aux _A inc n (inc i);;

let rec of_nat _A
  n = of_nat_aux _A
        (fun i ->
          plus _A.semiring_numeral_semiring_1.numeral_semiring_numeral.semigroup_add_numeral.plus_semigroup_add
            i (one _A.semiring_numeral_semiring_1.numeral_semiring_numeral.one_numeral))
        n (zero _A.semiring_0_semiring_1.mult_zero_semiring_0.zero_mult_zero);;

let rec global_reg_mod _A
  data_w32 x1 ur state = match data_w32, x1, ur, state with
    data_w32, Zero_nat, ur, state -> state
    | data_w32, Suc v, ur, state ->
        (let win_word =
           word_of_int _A (of_nat semiring_1_int (minus_nat (Suc v) one_nat)) in
         let a =
           user_reg_update
             (fun _ ->
               fun_upd (equal_word _A) (user_reg state) win_word
                 (fun_upd (equal_word len0_word_length5)
                   (user_reg state win_word) ur data_w32))
             state
           in
          global_reg_mod _A data_w32 (minus_nat (Suc v) one_nat) ur a);;

let rec plus_word _A a b = word_of_int _A (plus_inta (uint _A a) (uint _A b));;

let rec minus_word _A a b = word_of_int _A (minus_int (uint _A a) (uint _A b));;

let rec pre_window _A
  win = (if less_int Zero_int (uint _A win) then minus_word _A win (one_word _A)
          else word_of_int _A (minus_int nwindows one_inta));;

let rec out_reg_mod _A
  data_w32 win ur state =
    (let statea =
       user_reg_update
         (fun _ ->
           fun_upd (equal_word _A) (user_reg state) win
             (fun_upd (equal_word len0_word_length5) (user_reg state win) ur
               data_w32))
         state
       in
     let wina = pre_window _A win in
     let ura =
       plus_word len0_word_length5 ur
         (word_of_int len0_word_length5 (Pos (Bit0 (Bit0 (Bit0 (Bit0 One))))))
       in
      user_reg_update
        (fun _ ->
          fun_upd (equal_word _A) (user_reg statea) wina
            (fun_upd (equal_word len0_word_length5) (user_reg statea wina) ura
              data_w32))
        statea);;

let rec next_window _A
  win = (if less_int (uint _A win) (minus_int nwindows one_inta)
          then plus_word _A win (one_word _A) else zero_word _A);;

let rec in_reg_mod _A
  data_w32 win ur state =
    (let statea =
       user_reg_update
         (fun _ ->
           fun_upd (equal_word _A) (user_reg state) win
             (fun_upd (equal_word len0_word_length5) (user_reg state win) ur
               data_w32))
         state
       in
     let wina = next_window _A win in
     let ura =
       minus_word len0_word_length5 ur
         (word_of_int len0_word_length5 (Pos (Bit0 (Bit0 (Bit0 (Bit0 One))))))
       in
      user_reg_update
        (fun _ ->
          fun_upd (equal_word _A) (user_reg statea) wina
            (fun_upd (equal_word len0_word_length5) (user_reg statea wina) ura
              data_w32))
        statea);;

let rec user_reg_mod _A
  data_w32 win ur state =
    (if equal_worda len0_word_length5 ur (zero_word len0_word_length5)
      then state
      else (if less_word len0_word_length5 (zero_word len0_word_length5) ur &&
                 less_word len0_word_length5 ur
                   (word_of_int len0_word_length5
                     (Pos (Bit0 (Bit0 (Bit0 One)))))
             then global_reg_mod _A data_w32 (nat nwindows) ur state
             else (if less_word len0_word_length5
                        (word_of_int len0_word_length5 (Pos (Bit1 (Bit1 One))))
                        ur &&
                        less_word len0_word_length5 ur
                          (word_of_int len0_word_length5
                            (Pos (Bit0 (Bit0 (Bit0 (Bit0 One))))))
                    then out_reg_mod _A data_w32 win ur state
                    else (if less_word len0_word_length5
                               (word_of_int len0_word_length5
                                 (Pos (Bit1 (Bit1 (Bit1 One)))))
                               ur &&
                               less_word len0_word_length5 ur
                                 (word_of_int len0_word_length5
                                   (Pos (Bit0 (Bit0 (Bit0 (Bit1 One))))))
                           then user_reg_update
                                  (fun _ ->
                                    fun_upd (equal_word _A) (user_reg state) win
                                      (fun_upd (equal_word len0_word_length5)
(user_reg state win) ur data_w32))
                                  state
                           else in_reg_mod _A data_w32 win ur state))));;

let rec write_reg _A
  w win ur = bind (modify (user_reg_mod _A w win ur)) (k_bind (return ()));;

let rec get_icc_C
  psr = ucast len0_word_length32 len0_word_length1
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 psr
              (word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))))))))))))))
            (nat_of_num (Bit0 (Bit0 (Bit1 (Bit0 One))))));;

let rec get_icc_N
  psr = ucast len0_word_length32 len0_word_length1
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 psr
              (word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))))))))))))))))))
            (nat_of_num (Bit1 (Bit1 (Bit1 (Bit0 One))))));;

let rec get_icc_V
  psr = ucast len0_word_length32 len0_word_length1
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 psr
              (word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 One))))))))))))))))))))))))
            (nat_of_num (Bit1 (Bit0 (Bit1 (Bit0 One))))));;

let rec get_icc_Z
  psr = ucast len0_word_length32 len0_word_length1
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 psr
              (word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 (Bit0 One)))))))))))))))))))))))))
            (nat_of_num (Bit0 (Bit1 (Bit1 (Bit0 One))))));;

let rec sign_ext8
  w = (let highest_bit =
         shiftr_word len0_word_length8
           (bitAND_word len0_word_length8 w
             (word_of_int len0_word_length8
               (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))
           (nat_of_num (Bit1 (Bit1 One)))
         in
        (if equal_worda len0_word_length8 highest_bit
              (zero_word len0_word_length8)
          then ucast len0_word_length8 len0_word_length32 w
          else bitOR_word len0_word_length32
                 (ucast len0_word_length8 len0_word_length32 w)
                 (word_of_int len0_word_length32
                   (Pos (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))));;

let rec zero_ext8 w = ucast len0_word_length8 len0_word_length32 w;;

let rec dcache (Cpu_cache_ext (dcache, icache, more)) = dcache;;

let rec dcache_mod
  c vala state =
    cache_update
      (fun _ ->
        dcache_update
          (fun _ ->
            fun_upd
              (equal_prod (equal_word len0_word_length20)
                (equal_word len0_word_length12))
              (dcache (cache state)) c (Some vala))
          (cache state))
      state;;

let rec dcache_val c state = dcache (cache state) c;;

let rec icache (Cpu_cache_ext (dcache, icache, more)) = icache;;

let rec icache_mod
  c vala state =
    cache_update
      (fun _ ->
        icache_update
          (fun _ ->
            fun_upd
              (equal_prod (equal_word len0_word_length20)
                (equal_word len0_word_length12))
              (icache (cache state)) c (Some vala))
          (cache state))
      state;;

let rec icache_val c state = icache (cache state) c;;

let rec traps_update
  trapsa
    (Sparc_state_ext
      (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
        undef, more))
    = Sparc_state_ext
        (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var,
          trapsa traps, undef, more);;

let rec traps
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = traps;;

let rec sup_set _A
  x0 a = match x0, a with
    Coset xs, a -> Coset (filter (fun x -> not (member _A x a)) xs)
    | Set xs, a -> fold (insert _A) xs a;;

let rec add_trap_set
  t s = traps_update
          (fun _ -> sup_set equal_Trap (traps s) (insert equal_Trap t bot_set))
          s;;

let rec raise_trap t = bind (modify (add_trap_set t)) (k_bind (return ()));;

let rec sign_ext13
  w = (let highest_bit =
         shiftr_word len0_word_length13
           (bitAND_word len0_word_length13 w
             (word_of_int len0_word_length13
               (Pos (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))))))
           (nat_of_num (Bit0 (Bit0 (Bit1 One))))
         in
        (if equal_worda len0_word_length13 highest_bit
              (zero_word len0_word_length13)
          then ucast len0_word_length13 len0_word_length32 w
          else bitOR_word len0_word_length32
                 (ucast len0_word_length13 len0_word_length32 w)
                 (word_of_int len0_word_length32
                   (Pos (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))));;

let rec sign_ext16
  w = (let highest_bit =
         shiftr_word len0_word_length16
           (bitAND_word len0_word_length16 w
             (word_of_int len0_word_length16
               (Pos (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 One))))))))))))))))))
           (nat_of_num (Bit1 (Bit1 (Bit1 One))))
         in
        (if equal_worda len0_word_length16 highest_bit
              (zero_word len0_word_length16)
          then ucast len0_word_length16 len0_word_length32 w
          else bitOR_word len0_word_length32
                 (ucast len0_word_length16 len0_word_length32 w)
                 (word_of_int len0_word_length32
                   (Pos (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))));;

let rec sign_ext24
  w = (let highest_bit =
         shiftr_word len0_word_length24
           (bitAND_word len0_word_length24 w
             (word_of_int len0_word_length24
               (Pos (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))))))))))))))))))
           (nat_of_num (Bit1 (Bit1 (Bit1 (Bit0 One)))))
         in
        (if equal_worda len0_word_length24 highest_bit
              (zero_word len0_word_length24)
          then ucast len0_word_length24 len0_word_length32 w
          else bitOR_word len0_word_length32
                 (ucast len0_word_length24 len0_word_length32 w)
                 (word_of_int len0_word_length32
                   (Pos (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))));;

let rec update_CWP
  cwp_val psr_val =
    (let tmp0 =
       bitAND_word len0_word_length32 psr_val
         (word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
       in
     let s_val = ucast len0_word_length1 len0_word_length1 (get_S psr_val) in
      (if equal_worda len0_word_length1 s_val (zero_word len0_word_length1)
        then bitAND_word len0_word_length32
               (bitOR_word len0_word_length32 tmp0
                 (ucast len0_word_length5 len0_word_length32 cwp_val))
               (word_of_int len0_word_length32
                 (Pos (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit0 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
        else bitOR_word len0_word_length32
               (bitOR_word len0_word_length32 tmp0
                 (ucast len0_word_length5 len0_word_length32 cwp_val))
               (word_of_int len0_word_length32
                 (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))));;

let rec zero_ext16 w = ucast len0_word_length16 len0_word_length32 w;;

let rec get_a
  w = (let mask_a =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 One))))))))))))))))))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_a w)
            (nat_of_num (Bit1 (Bit0 (Bit1 (Bit1 One)))))));;

let rec get_i
  w = (let mask_i =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_i w)
            (nat_of_num (Bit1 (Bit0 (Bit1 One))))));;

let rec cpu_reg_val reg state = cpu_reg state reg;;

let rec mem_mod_w32
  asi addr byte_mask data_w32 state =
    (let addra =
       bitAND_word len0_word_length36 addr
         (word_of_int len0_word_length36
           (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 One)))))))))))))))))))))))))))))))))))))
       in
     let addr0 =
       bitOR_word len0_word_length36 addra (zero_word len0_word_length36) in
     let addr1 =
       bitOR_word len0_word_length36 addra (one_word len0_word_length36) in
     let addr2 =
       bitOR_word len0_word_length36 addra
         (word_of_int len0_word_length36 (Pos (Bit0 One)))
       in
     let addr3 =
       bitOR_word len0_word_length36 addra
         (word_of_int len0_word_length36 (Pos (Bit1 One)))
       in
     let byte0 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 data_w32
           (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
       in
     let byte1 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 data_w32
           (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One))))))
       in
     let byte2 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 data_w32
           (nat_of_num (Bit0 (Bit0 (Bit0 One)))))
       in
     let byte3 = ucast len0_word_length32 len0_word_length8 data_w32 in
     let s0 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 (Bit0 One))))))
               (nat_of_num (Bit1 One)))
             (one_word len0_word_length4)
         then mem_mod asi addr0 byte0 state else state)
       in
     let s1 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 One)))))
               (nat_of_num (Bit0 One)))
             (one_word len0_word_length4)
         then mem_mod asi addr1 byte1 s0 else s0)
       in
     let s2 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 One))))
               one_nat)
             (one_word len0_word_length4)
         then mem_mod asi addr2 byte2 s1 else s1)
       in
     let s3 =
       (if equal_worda len0_word_length4
             (bitAND_word len0_word_length4 byte_mask
               (one_word len0_word_length4))
             (one_word len0_word_length4)
         then mem_mod asi addr3 byte3 s2 else s2)
       in
      s3);;

let rec mem_val_alt
  asi add state =
    (let r1 = mem state asi add in
     let asi8 = word_of_int len0_word_length8 (Pos (Bit0 (Bit0 (Bit0 One)))) in
     let asi9 = word_of_int len0_word_length8 (Pos (Bit1 (Bit0 (Bit0 One)))) in
     let asi10 = word_of_int len0_word_length8 (Pos (Bit0 (Bit1 (Bit0 One)))) in
     let asi11 = word_of_int len0_word_length8 (Pos (Bit1 (Bit1 (Bit0 One)))) in
      (if is_none r1 &&
            equal_inta (uint len0_word_length8 asi)
              (Pos (Bit0 (Bit0 (Bit0 One))))
        then (let r2 = mem state asi9 add in r2)
        else (if is_none r1 &&
                   equal_inta (uint len0_word_length8 asi)
                     (Pos (Bit1 (Bit0 (Bit0 One))))
               then (let r2 = mem state asi8 add in r2)
               else (if is_none r1 &&
                          equal_inta (uint len0_word_length8 asi)
                            (Pos (Bit0 (Bit1 (Bit0 One))))
                      then (let r2 = mem state asi11 add in
                             (if is_none r2
                               then (let r3 = mem state asi8 add in
                                      (if is_none r3 then mem state asi9 add
else r3))
                               else r2))
                      else (if is_none r1 &&
                                 equal_inta (uint len0_word_length8 asi)
                                   (Pos (Bit1 (Bit1 (Bit0 One))))
                             then (let r2 = mem state asi10 add in
                                    (if is_none r2
                                      then (let r3 = mem state asi8 add in
     (if is_none r3 then mem state asi9 add else r3))
                                      else r2))
                             else r1)))));;

let rec mem_val_w32
  asi addr state =
    (let addra =
       bitAND_word len0_word_length36 addr
         (word_of_int len0_word_length36
           (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 One)))))))))))))))))))))))))))))))))))))
       in
     let addr0 = addra in
     let addr1 =
       plus_word len0_word_length36 addra (one_word len0_word_length36) in
     let addr2 =
       plus_word len0_word_length36 addra
         (word_of_int len0_word_length36 (Pos (Bit0 One)))
       in
     let addr3 =
       plus_word len0_word_length36 addra
         (word_of_int len0_word_length36 (Pos (Bit1 One)))
       in
     let r0 = mem_val_alt asi addr0 state in
     let r1 = mem_val_alt asi addr1 state in
     let r2 = mem_val_alt asi addr2 state in
     let r3 = mem_val_alt asi addr3 state in
      (if is_none r0 || (is_none r1 || (is_none r2 || is_none r3)) then None
        else (let byte0 = (let Some v = r0 in v) in
              let byte1 = (let Some v = r1 in v) in
              let byte2 = (let Some v = r2 in v) in
              let byte3 = (let Some v = r3 in v) in
               Some (bitOR_word len0_word_length32
                      (bitOR_word len0_word_length32
                        (bitOR_word len0_word_length32
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte0)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte1)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One)))))))
                        (shiftl_word len0_word_length32
                          (ucast len0_word_length8 len0_word_length32 byte2)
                          (nat_of_num (Bit0 (Bit0 (Bit0 One))))))
                      (ucast len0_word_length8 len0_word_length32 byte3)))));;

let rec read_instr_cache
  state va =
    (let tag =
       ucast len0_word_length32 len0_word_length20
         (shiftr_word len0_word_length32 va
           (nat_of_num (Bit0 (Bit0 (Bit1 One)))))
       in
     let offset0 =
       bitAND_word len0_word_length12
         (ucast len0_word_length32 len0_word_length12 va)
         (word_of_int len0_word_length12
           (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))
       in
     let offset1 =
       bitOR_word len0_word_length12 offset0 (one_word len0_word_length12) in
     let offset2 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit0 One)))
       in
     let offset3 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit1 One)))
       in
     let r0 = icache_val (tag, offset0) state in
     let r1 = icache_val (tag, offset1) state in
     let r2 = icache_val (tag, offset2) state in
     let r3 = icache_val (tag, offset3) state in
      (if is_none r0 || (is_none r1 || (is_none r2 || is_none r3)) then None
        else (let byte0 = (let Some v = r0 in v) in
              let byte1 = (let Some v = r1 in v) in
              let byte2 = (let Some v = r2 in v) in
              let byte3 = (let Some v = r3 in v) in
               Some (bitOR_word len0_word_length32
                      (bitOR_word len0_word_length32
                        (bitOR_word len0_word_length32
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte0)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte1)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One)))))))
                        (shiftl_word len0_word_length32
                          (ucast len0_word_length8 len0_word_length32 byte2)
                          (nat_of_num (Bit0 (Bit0 (Bit0 One))))))
                      (ucast len0_word_length8 len0_word_length32 byte3)))));;

let rec mmu
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = mmu;;

let rec read_data_cache
  state va =
    (let tag =
       ucast len0_word_length32 len0_word_length20
         (shiftr_word len0_word_length32 va
           (nat_of_num (Bit0 (Bit0 (Bit1 One)))))
       in
     let offset0 =
       bitAND_word len0_word_length12
         (ucast len0_word_length32 len0_word_length12 va)
         (word_of_int len0_word_length12
           (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))
       in
     let offset1 =
       bitOR_word len0_word_length12 offset0 (one_word len0_word_length12) in
     let offset2 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit0 One)))
       in
     let offset3 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit1 One)))
       in
     let r0 = dcache_val (tag, offset0) state in
     let r1 = dcache_val (tag, offset1) state in
     let r2 = dcache_val (tag, offset2) state in
     let r3 = dcache_val (tag, offset3) state in
      (if is_none r0 || (is_none r1 || (is_none r2 || is_none r3)) then None
        else (let byte0 = (let Some v = r0 in v) in
              let byte1 = (let Some v = r1 in v) in
              let byte2 = (let Some v = r2 in v) in
              let byte3 = (let Some v = r3 in v) in
               Some (bitOR_word len0_word_length32
                      (bitOR_word len0_word_length32
                        (bitOR_word len0_word_length32
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte0)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
                          (shiftl_word len0_word_length32
                            (ucast len0_word_length8 len0_word_length32 byte1)
                            (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One)))))))
                        (shiftl_word len0_word_length32
                          (ucast len0_word_length8 len0_word_length32 byte2)
                          (nat_of_num (Bit0 (Bit0 (Bit0 One))))))
                      (ucast len0_word_length8 len0_word_length32 byte3)))));;

let rec add_instr_cache
  state va word byte_mask =
    (let tag =
       ucast len0_word_length32 len0_word_length20
         (shiftr_word len0_word_length32 va
           (nat_of_num (Bit0 (Bit0 (Bit1 One)))))
       in
     let offset0 =
       bitAND_word len0_word_length12
         (ucast len0_word_length32 len0_word_length12 va)
         (word_of_int len0_word_length12
           (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))
       in
     let offset1 =
       bitOR_word len0_word_length12 offset0 (one_word len0_word_length12) in
     let offset2 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit0 One)))
       in
     let offset3 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit1 One)))
       in
     let byte0 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 word
           (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
       in
     let byte1 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 word
           (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One))))))
       in
     let byte2 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 word
           (nat_of_num (Bit0 (Bit0 (Bit0 One)))))
       in
     let byte3 = ucast len0_word_length32 len0_word_length8 word in
     let s0 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 (Bit0 One))))))
               (nat_of_num (Bit1 One)))
             (one_word len0_word_length4)
         then icache_mod (tag, offset0) byte0 state else state)
       in
     let s1 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 One)))))
               (nat_of_num (Bit0 One)))
             (one_word len0_word_length4)
         then icache_mod (tag, offset1) byte1 s0 else s0)
       in
     let s2 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 One))))
               one_nat)
             (one_word len0_word_length4)
         then icache_mod (tag, offset2) byte2 s1 else s1)
       in
     let s3 =
       (if equal_worda len0_word_length4
             (bitAND_word len0_word_length4 byte_mask
               (one_word len0_word_length4))
             (one_word len0_word_length4)
         then icache_mod (tag, offset3) byte3 s2 else s2)
       in
      s3);;

let rec add_data_cache
  state va word byte_mask =
    (let tag =
       ucast len0_word_length32 len0_word_length20
         (shiftr_word len0_word_length32 va
           (nat_of_num (Bit0 (Bit0 (Bit1 One)))))
       in
     let offset0 =
       bitAND_word len0_word_length12
         (ucast len0_word_length32 len0_word_length12 va)
         (word_of_int len0_word_length12
           (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))
       in
     let offset1 =
       bitOR_word len0_word_length12 offset0 (one_word len0_word_length12) in
     let offset2 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit0 One)))
       in
     let offset3 =
       bitOR_word len0_word_length12 offset0
         (word_of_int len0_word_length12 (Pos (Bit1 One)))
       in
     let byte0 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 word
           (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
       in
     let byte1 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 word
           (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One))))))
       in
     let byte2 =
       ucast len0_word_length32 len0_word_length8
         (shiftr_word len0_word_length32 word
           (nat_of_num (Bit0 (Bit0 (Bit0 One)))))
       in
     let byte3 = ucast len0_word_length32 len0_word_length8 word in
     let s0 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 (Bit0 One))))))
               (nat_of_num (Bit1 One)))
             (one_word len0_word_length4)
         then dcache_mod (tag, offset0) byte0 state else state)
       in
     let s1 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 One)))))
               (nat_of_num (Bit0 One)))
             (one_word len0_word_length4)
         then dcache_mod (tag, offset1) byte1 s0 else s0)
       in
     let s2 =
       (if equal_worda len0_word_length4
             (shiftr_word len0_word_length4
               (bitAND_word len0_word_length4 byte_mask
                 (word_of_int len0_word_length4 (Pos (Bit0 One))))
               one_nat)
             (one_word len0_word_length4)
         then dcache_mod (tag, offset2) byte2 s1 else s1)
       in
     let s3 =
       (if equal_worda len0_word_length4
             (bitAND_word len0_word_length4 byte_mask
               (one_word len0_word_length4))
             (one_word len0_word_length4)
         then dcache_mod (tag, offset3) byte3 s2 else s2)
       in
      s3);;

let rec load_word_mem
  state va asi =
    (match virt_to_phys va (mmu state) (mem state) with None -> None
      | Some pair ->
        (if mmu_readable (get_acc_flag (snd pair)) asi
          then mem_val_w32 asi (fst pair) state else None));;

let rec memory_read
  asi addr state =
    (let asi_int = uint len0_word_length8 asi in
      (if equal_inta asi_int one_inta
        then (let r1 =
                load_word_mem state addr
                  (word_of_int len0_word_length8 (Pos (Bit0 (Bit0 (Bit0 One)))))
                in
               (if is_none r1
                 then (let r2 =
                         load_word_mem state addr
                           (word_of_int len0_word_length8
                             (Pos (Bit0 (Bit1 (Bit0 One)))))
                         in
                        (if is_none r2 then (None, state) else (r2, state)))
                 else (r1, state)))
        else (if equal_inta asi_int (Pos (Bit0 One))
               then (if equal_inta (uint len0_word_length32 addr) Zero_int
                      then (Some (sys_reg_val CCR state), state)
                      else (if equal_inta (uint len0_word_length32 addr)
                                 (Pos (Bit0 (Bit0 (Bit0 One))))
                             then (Some (sys_reg_val ICCR state), state)
                             else (if equal_inta (uint len0_word_length32 addr)
(Pos (Bit0 (Bit0 (Bit1 One))))
                                    then (Some (sys_reg_val DCCR state), state)
                                    else (None, state))))
               else (if member equal_int asi_int
                          (insert equal_int (Pos (Bit0 (Bit0 (Bit0 One))))
                            (insert equal_int (Pos (Bit1 (Bit0 (Bit0 One))))
                              bot_set))
                      then (let ccr_val = sys_reg state CCR in
                             (if not (equal_worda len0_word_length32
                                       (bitAND_word len0_word_length32 ccr_val
 (one_word len0_word_length32))
                                       (zero_word len0_word_length32))
                               then (match load_word_mem state addr asi
                                      with None -> (None, state)
                                      | Some w ->
(Some w,
  add_instr_cache state addr w
    (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One)))))))
                               else (load_word_mem state addr asi, state)))
                      else (if member equal_int asi_int
                                 (insert equal_int
                                   (Pos (Bit0 (Bit1 (Bit0 One))))
                                   (insert equal_int
                                     (Pos (Bit1 (Bit1 (Bit0 One)))) bot_set))
                             then (let ccr_val = sys_reg state CCR in
                                    (if not
  (equal_worda len0_word_length32
    (bitAND_word len0_word_length32 ccr_val (one_word len0_word_length32))
    (zero_word len0_word_length32))
                                      then (match load_word_mem state addr asi
     with None -> (None, state)
     | Some w ->
       (Some w,
         add_data_cache state addr w
           (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One)))))))
                                      else (load_word_mem state addr asi,
     state)))
                             else (if equal_inta asi_int
(Pos (Bit1 (Bit0 (Bit1 One))))
                                    then (match read_instr_cache state addr
   with None -> (None, state) | Some w -> (Some w, state))
                                    else (if equal_inta asi_int
       (Pos (Bit1 (Bit1 (Bit1 One))))
   then (match read_data_cache state addr with None -> (None, state)
          | Some w -> (Some w, state))
   else (if member equal_int asi_int
              (insert equal_int (Pos (Bit0 (Bit0 (Bit0 (Bit0 One)))))
                (insert equal_int (Pos (Bit1 (Bit0 (Bit0 (Bit0 One)))))
                  bot_set))
          then (None, state)
          else (if member equal_int asi_int
                     (insert equal_int (Pos (Bit0 (Bit0 (Bit1 (Bit0 One)))))
                       (insert equal_int (Pos (Bit1 (Bit0 (Bit1 (Bit0 One)))))
                         bot_set))
                 then (None, state)
                 else (if equal_inta asi_int
                            (Pos (Bit0 (Bit0 (Bit0 (Bit1 One)))))
                        then (None, state)
                        else (if equal_inta asi_int
                                   (Pos (Bit1 (Bit0 (Bit0 (Bit1 One)))))
                               then (mmu_reg_val (mmu state) addr, state)
                               else (if equal_inta asi_int
  (Pos (Bit0 (Bit0 (Bit1 (Bit1 One)))))
                                      then (mem_val_w32 asi
      (ucast len0_word_length32 len0_word_length36 addr) state,
     state)
                                      else (if equal_inta asi_int
         (Pos (Bit1 (Bit0 (Bit1 (Bit1 One)))))
     then (None, state) else (None, state))))))))))))));;

let rec undef
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = undef;;

let rec state_undef state = undef state;;

let rec sys_reg_update
  sys_rega
    (Sparc_state_ext
      (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
        undef, more))
    = Sparc_state_ext
        (cpu_reg, user_reg, sys_rega sys_reg, mem, mmu, cache, dwrite,
          state_var, traps, undef, more);;

let rec sys_reg_mod
  data_w32 sys state =
    sys_reg_update (fun _ -> fun_upd equal_sys_reg (sys_reg state) sys data_w32)
      state;;

let rec get_WIM_bit
  n wim =
    (let mask =
       shiftl_word len0_word_length32
         (ucast len0_word_length1 len0_word_length32
           (one_word len0_word_length1))
         n
       in
      ucast len0_word_length32 len0_word_length1
        (shiftr_word len0_word_length32
          (bitAND_word len0_word_length32 mask wim) n));;

let rec abs_int i = (if less_int i Zero_int then uminus_int i else i);;

let rec equal_bool p pa = match p, pa with p, true -> p
                     | p, false -> not p
                     | true, p -> p
                     | false, p -> not p;;

let rec get_trap_imm7
  w = (let mask_imm7 =
         word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))
         in
        uint len0_word_length32 (bitAND_word len0_word_length32 mask_imm7 w));;

let rec get_trap_cond
  w = (let mask_cond =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1
  (Bit1 One)))))))))))))))))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_cond w)
            (nat_of_num (Bit1 (Bit0 (Bit0 (Bit1 One)))))));;

let rec get_simm13
  w = (let mask_simm13 =
         word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))
         in
        uint len0_word_length32
          (bitAND_word len0_word_length32 mask_simm13 w));;

let rec get_rs2
  w = (let mask_rs2 =
         word_of_int len0_word_length32 (Pos (Bit1 (Bit1 (Bit1 (Bit1 One))))) in
        uint len0_word_length32 (bitAND_word len0_word_length32 mask_rs2 w));;

let rec get_rs1
  w = (let mask_rs1 =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_rs1 w)
            (nat_of_num (Bit0 (Bit1 (Bit1 One))))));;

let rec get_op3
  w = (let mask_op3 =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_op3 w)
            (nat_of_num (Bit1 (Bit1 (Bit0 (Bit0 One)))))));;

let rec get_asi
  w = (let mask_asi =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_asi w)
            (nat_of_num (Bit1 (Bit0 One)))));;

let rec get_rd
  w = (let mask_rd =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1
  (Bit1 (Bit1 One))))))))))))))))))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_rd w)
            (nat_of_num (Bit1 (Bit0 (Bit0 (Bit1 One)))))));;

let rec get_op
  w = uint len0_word_length32
        (shiftr_word len0_word_length32 w
          (nat_of_num (Bit0 (Bit1 (Bit1 (Bit1 One))))));;

let rec parse_instr_f3
  w = (let this_op = get_op w in
       let rd = get_rd w in
       let op3 = get_op3 w in
       let rs1 = get_rs1 w in
       let flagi = get_i w in
       let asi = get_asi w in
       let rs2 = get_rs2 w in
       let simm13 = get_simm13 w in
        (if equal_inta this_op
              (uint len0_word_length2
                (word_of_int len0_word_length2 (Pos (Bit1 One))))
          then (if equal_inta op3
                     (uint len0_word_length6
                       (word_of_int len0_word_length6
                         (Pos (Bit1 (Bit0 (Bit0 One))))))
                 then (if equal_inta flagi one_inta
                        then Inr (Load_store_type LDSB,
                                   [Flag (word_of_int len0_word_length1 flagi);
                                     W5 (word_of_int len0_word_length5 rs1);
                                     Simm13
                                       (word_of_int len0_word_length13 simm13);
                                     W5 (word_of_int len0_word_length5 rd)])
                        else Inr (Load_store_type LDSB,
                                   [Flag (word_of_int len0_word_length1 flagi);
                                     W5 (word_of_int len0_word_length5 rs1);
                                     W5 (word_of_int len0_word_length5 rs2);
                                     W5 (word_of_int len0_word_length5 rd)]))
                 else (if equal_inta op3
                            (uint len0_word_length6
                              (word_of_int len0_word_length6
                                (Pos (Bit1 (Bit0 (Bit0 (Bit1 One)))))))
                        then Inr (Load_store_type LDSBA,
                                   [Flag (word_of_int len0_word_length1 flagi);
                                     W5 (word_of_int len0_word_length5 rs1);
                                     W5 (word_of_int len0_word_length5 rs2);
                                     Asi (word_of_int len0_word_length8 asi);
                                     W5 (word_of_int len0_word_length5 rd)])
                        else (if equal_inta op3
                                   (uint len0_word_length6
                                     (word_of_int len0_word_length6
                                       (Pos (Bit0 (Bit1 (Bit0 One))))))
                               then (if equal_inta flagi one_inta
                                      then Inr
     (Load_store_type LDSH,
       [Flag (word_of_int len0_word_length1 flagi);
         W5 (word_of_int len0_word_length5 rs1);
         Simm13 (word_of_int len0_word_length13 simm13);
         W5 (word_of_int len0_word_length5 rd)])
                                      else Inr
     (Load_store_type LDSH,
       [Flag (word_of_int len0_word_length1 flagi);
         W5 (word_of_int len0_word_length5 rs1);
         W5 (word_of_int len0_word_length5 rs2);
         W5 (word_of_int len0_word_length5 rd)]))
                               else (if equal_inta op3
  (uint len0_word_length6
    (word_of_int len0_word_length6 (Pos (Bit0 (Bit1 (Bit0 (Bit1 One)))))))
                                      then Inr
     (Load_store_type LDSHA,
       [Flag (word_of_int len0_word_length1 flagi);
         W5 (word_of_int len0_word_length5 rs1);
         W5 (word_of_int len0_word_length5 rs2);
         Asi (word_of_int len0_word_length8 asi);
         W5 (word_of_int len0_word_length5 rd)])
                                      else (if equal_inta op3
         (uint len0_word_length6 (one_word len0_word_length6))
     then (if equal_inta flagi one_inta
            then Inr (Load_store_type LDUB,
                       [Flag (word_of_int len0_word_length1 flagi);
                         W5 (word_of_int len0_word_length5 rs1);
                         Simm13 (word_of_int len0_word_length13 simm13);
                         W5 (word_of_int len0_word_length5 rd)])
            else Inr (Load_store_type LDUB,
                       [Flag (word_of_int len0_word_length1 flagi);
                         W5 (word_of_int len0_word_length5 rs1);
                         W5 (word_of_int len0_word_length5 rs2);
                         W5 (word_of_int len0_word_length5 rd)]))
     else (if equal_inta op3
                (uint len0_word_length6
                  (word_of_int len0_word_length6
                    (Pos (Bit1 (Bit0 (Bit0 (Bit0 One)))))))
            then Inr (Load_store_type LDUBA,
                       [Flag (word_of_int len0_word_length1 flagi);
                         W5 (word_of_int len0_word_length5 rs1);
                         W5 (word_of_int len0_word_length5 rs2);
                         Asi (word_of_int len0_word_length8 asi);
                         W5 (word_of_int len0_word_length5 rd)])
            else (if equal_inta op3
                       (uint len0_word_length6
                         (word_of_int len0_word_length6 (Pos (Bit0 One))))
                   then (if equal_inta flagi one_inta
                          then Inr (Load_store_type LDUH,
                                     [Flag
(word_of_int len0_word_length1 flagi);
                                       W5 (word_of_int len0_word_length5 rs1);
                                       Simm13
 (word_of_int len0_word_length13 simm13);
                                       W5 (word_of_int len0_word_length5 rd)])
                          else Inr (Load_store_type LDUH,
                                     [Flag
(word_of_int len0_word_length1 flagi);
                                       W5 (word_of_int len0_word_length5 rs1);
                                       W5 (word_of_int len0_word_length5 rs2);
                                       W5 (word_of_int len0_word_length5 rd)]))
                   else (if equal_inta op3
                              (uint len0_word_length6
                                (word_of_int len0_word_length6
                                  (Pos (Bit0 (Bit1 (Bit0 (Bit0 One)))))))
                          then Inr (Load_store_type LDUHA,
                                     [Flag
(word_of_int len0_word_length1 flagi);
                                       W5 (word_of_int len0_word_length5 rs1);
                                       W5 (word_of_int len0_word_length5 rs2);
                                       Asi (word_of_int len0_word_length8 asi);
                                       W5 (word_of_int len0_word_length5 rd)])
                          else (if equal_inta op3
                                     (uint len0_word_length6
                                       (zero_word len0_word_length6))
                                 then (if equal_inta flagi one_inta
then Inr (Load_store_type LD,
           [Flag (word_of_int len0_word_length1 flagi);
             W5 (word_of_int len0_word_length5 rs1);
             Simm13 (word_of_int len0_word_length13 simm13);
             W5 (word_of_int len0_word_length5 rd)])
else Inr (Load_store_type LD,
           [Flag (word_of_int len0_word_length1 flagi);
             W5 (word_of_int len0_word_length5 rs1);
             W5 (word_of_int len0_word_length5 rs2);
             W5 (word_of_int len0_word_length5 rd)]))
                                 else (if equal_inta op3
    (uint len0_word_length6
      (word_of_int len0_word_length6 (Pos (Bit0 (Bit0 (Bit0 (Bit0 One)))))))
then Inr (Load_store_type LDA,
           [Flag (word_of_int len0_word_length1 flagi);
             W5 (word_of_int len0_word_length5 rs1);
             W5 (word_of_int len0_word_length5 rs2);
             Asi (word_of_int len0_word_length8 asi);
             W5 (word_of_int len0_word_length5 rd)])
else (if equal_inta op3
           (uint len0_word_length6
             (word_of_int len0_word_length6 (Pos (Bit1 One))))
       then (if equal_inta flagi one_inta
              then Inr (Load_store_type LDD,
                         [Flag (word_of_int len0_word_length1 flagi);
                           W5 (word_of_int len0_word_length5 rs1);
                           Simm13 (word_of_int len0_word_length13 simm13);
                           W5 (word_of_int len0_word_length5 rd)])
              else Inr (Load_store_type LDD,
                         [Flag (word_of_int len0_word_length1 flagi);
                           W5 (word_of_int len0_word_length5 rs1);
                           W5 (word_of_int len0_word_length5 rs2);
                           W5 (word_of_int len0_word_length5 rd)]))
       else (if equal_inta op3
                  (uint len0_word_length6
                    (word_of_int len0_word_length6
                      (Pos (Bit1 (Bit1 (Bit0 (Bit0 One)))))))
              then Inr (Load_store_type LDDA,
                         [Flag (word_of_int len0_word_length1 flagi);
                           W5 (word_of_int len0_word_length5 rs1);
                           W5 (word_of_int len0_word_length5 rs2);
                           Asi (word_of_int len0_word_length8 asi);
                           W5 (word_of_int len0_word_length5 rd)])
              else (if equal_inta op3
                         (uint len0_word_length6
                           (word_of_int len0_word_length6
                             (Pos (Bit1 (Bit0 (Bit1 One))))))
                     then (if equal_inta flagi one_inta
                            then Inr (Load_store_type LDSTUB,
                                       [Flag
  (word_of_int len0_word_length1 flagi);
 W5 (word_of_int len0_word_length5 rs1);
 Simm13 (word_of_int len0_word_length13 simm13);
 W5 (word_of_int len0_word_length5 rd)])
                            else Inr (Load_store_type LDSTUB,
                                       [Flag
  (word_of_int len0_word_length1 flagi);
 W5 (word_of_int len0_word_length5 rs1); W5 (word_of_int len0_word_length5 rs2);
 W5 (word_of_int len0_word_length5 rd)]))
                     else (if equal_inta op3
                                (uint len0_word_length6
                                  (word_of_int len0_word_length6
                                    (Pos (Bit1 (Bit0 (Bit1 (Bit1 One)))))))
                            then Inr (Load_store_type LDSTUBA,
                                       [Flag
  (word_of_int len0_word_length1 flagi);
 W5 (word_of_int len0_word_length5 rs1); W5 (word_of_int len0_word_length5 rs2);
 Asi (word_of_int len0_word_length8 asi);
 W5 (word_of_int len0_word_length5 rd)])
                            else (if equal_inta op3
                                       (uint len0_word_length6
 (word_of_int len0_word_length6 (Pos (Bit1 (Bit0 One)))))
                                   then (if equal_inta flagi one_inta
  then Inr (Load_store_type STB,
             [Flag (word_of_int len0_word_length1 flagi);
               W5 (word_of_int len0_word_length5 rs1);
               Simm13 (word_of_int len0_word_length13 simm13);
               W5 (word_of_int len0_word_length5 rd)])
  else Inr (Load_store_type STB,
             [Flag (word_of_int len0_word_length1 flagi);
               W5 (word_of_int len0_word_length5 rs1);
               W5 (word_of_int len0_word_length5 rs2);
               W5 (word_of_int len0_word_length5 rd)]))
                                   else (if equal_inta op3
      (uint len0_word_length6
        (word_of_int len0_word_length6 (Pos (Bit1 (Bit0 (Bit1 (Bit0 One)))))))
  then Inr (Load_store_type STBA,
             [Flag (word_of_int len0_word_length1 flagi);
               W5 (word_of_int len0_word_length5 rs1);
               W5 (word_of_int len0_word_length5 rs2);
               Asi (word_of_int len0_word_length8 asi);
               W5 (word_of_int len0_word_length5 rd)])
  else (if equal_inta op3
             (uint len0_word_length6
               (word_of_int len0_word_length6 (Pos (Bit0 (Bit1 One)))))
         then (if equal_inta flagi one_inta
                then Inr (Load_store_type STH,
                           [Flag (word_of_int len0_word_length1 flagi);
                             W5 (word_of_int len0_word_length5 rs1);
                             Simm13 (word_of_int len0_word_length13 simm13);
                             W5 (word_of_int len0_word_length5 rd)])
                else Inr (Load_store_type STH,
                           [Flag (word_of_int len0_word_length1 flagi);
                             W5 (word_of_int len0_word_length5 rs1);
                             W5 (word_of_int len0_word_length5 rs2);
                             W5 (word_of_int len0_word_length5 rd)]))
         else (if equal_inta op3
                    (uint len0_word_length6
                      (word_of_int len0_word_length6
                        (Pos (Bit0 (Bit1 (Bit1 (Bit0 One)))))))
                then Inr (Load_store_type STHA,
                           [Flag (word_of_int len0_word_length1 flagi);
                             W5 (word_of_int len0_word_length5 rs1);
                             W5 (word_of_int len0_word_length5 rs2);
                             Asi (word_of_int len0_word_length8 asi);
                             W5 (word_of_int len0_word_length5 rd)])
                else (if equal_inta op3
                           (uint len0_word_length6
                             (word_of_int len0_word_length6
                               (Pos (Bit0 (Bit0 One)))))
                       then (if equal_inta flagi one_inta
                              then Inr (Load_store_type ST,
 [Flag (word_of_int len0_word_length1 flagi);
   W5 (word_of_int len0_word_length5 rs1);
   Simm13 (word_of_int len0_word_length13 simm13);
   W5 (word_of_int len0_word_length5 rd)])
                              else Inr (Load_store_type ST,
 [Flag (word_of_int len0_word_length1 flagi);
   W5 (word_of_int len0_word_length5 rs1);
   W5 (word_of_int len0_word_length5 rs2);
   W5 (word_of_int len0_word_length5 rd)]))
                       else (if equal_inta op3
                                  (uint len0_word_length6
                                    (word_of_int len0_word_length6
                                      (Pos (Bit0 (Bit0 (Bit1 (Bit0 One)))))))
                              then Inr (Load_store_type STA,
 [Flag (word_of_int len0_word_length1 flagi);
   W5 (word_of_int len0_word_length5 rs1);
   W5 (word_of_int len0_word_length5 rs2);
   Asi (word_of_int len0_word_length8 asi);
   W5 (word_of_int len0_word_length5 rd)])
                              else (if equal_inta op3
 (uint len0_word_length6
   (word_of_int len0_word_length6 (Pos (Bit1 (Bit1 One)))))
                                     then (if equal_inta flagi one_inta
    then Inr (Load_store_type STD,
               [Flag (word_of_int len0_word_length1 flagi);
                 W5 (word_of_int len0_word_length5 rs1);
                 Simm13 (word_of_int len0_word_length13 simm13);
                 W5 (word_of_int len0_word_length5 rd)])
    else Inr (Load_store_type STD,
               [Flag (word_of_int len0_word_length1 flagi);
                 W5 (word_of_int len0_word_length5 rs1);
                 W5 (word_of_int len0_word_length5 rs2);
                 W5 (word_of_int len0_word_length5 rd)]))
                                     else (if equal_inta op3
        (uint len0_word_length6
          (word_of_int len0_word_length6 (Pos (Bit1 (Bit1 (Bit1 (Bit0 One)))))))
    then Inr (Load_store_type STDA,
               [Flag (word_of_int len0_word_length1 flagi);
                 W5 (word_of_int len0_word_length5 rs1);
                 W5 (word_of_int len0_word_length5 rs2);
                 Asi (word_of_int len0_word_length8 asi);
                 W5 (word_of_int len0_word_length5 rd)])
    else (if equal_inta op3
               (uint len0_word_length6
                 (word_of_int len0_word_length6 (Pos (Bit1 (Bit1 (Bit1 One))))))
           then (if equal_inta flagi one_inta
                  then Inr (Load_store_type SWAP,
                             [Flag (word_of_int len0_word_length1 flagi);
                               W5 (word_of_int len0_word_length5 rs1);
                               Simm13 (word_of_int len0_word_length13 simm13);
                               W5 (word_of_int len0_word_length5 rd)])
                  else Inr (Load_store_type SWAP,
                             [Flag (word_of_int len0_word_length1 flagi);
                               W5 (word_of_int len0_word_length5 rs1);
                               W5 (word_of_int len0_word_length5 rs2);
                               W5 (word_of_int len0_word_length5 rd)]))
           else (if equal_inta op3
                      (uint len0_word_length6
                        (word_of_int len0_word_length6
                          (Pos (Bit1 (Bit1 (Bit1 (Bit1 One)))))))
                  then Inr (Load_store_type SWAPA,
                             [Flag (word_of_int len0_word_length1 flagi);
                               W5 (word_of_int len0_word_length5 rs1);
                               W5 (word_of_int len0_word_length5 rs2);
                               Asi (word_of_int len0_word_length8 asi);
                               W5 (word_of_int len0_word_length5 rd)])
                  else (if equal_inta op3
                             (uint len0_word_length6
                               (word_of_int len0_word_length6
                                 (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1 One))))))))
                         then Inr (Load_store_type CASA,
                                    [Flag (word_of_int len0_word_length1 flagi);
                                      W5 (word_of_int len0_word_length5 rs1);
                                      W5 (word_of_int len0_word_length5 rs2);
                                      Asi (word_of_int len0_word_length8 asi);
                                      W5 (word_of_int len0_word_length5 rd)])
                         else (if equal_inta op3
                                    (uint len0_word_length6
                                      (word_of_int len0_word_length6
(Pos (Bit0 (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                                then Inr (Load_store_type CASXA,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     W5 (word_of_int len0_word_length5 rs2);
     Asi (word_of_int len0_word_length8 asi);
     W5 (word_of_int len0_word_length5 rd)])
                                else Inl [Invalid_op3_f3_op11]))))))))))))))))))))))))))
          else (if equal_inta this_op
                     (uint len0_word_length2
                       (word_of_int len0_word_length2 (Pos (Bit0 One))))
                 then (if equal_inta op3
                            (uint len0_word_length6
                              (word_of_int len0_word_length6
                                (Pos (Bit0 (Bit0 (Bit0 (Bit1 (Bit1 One))))))))
                        then (if equal_inta flagi Zero_int
                               then Inr (Ctrl_type JMPL,
  [Flag (word_of_int len0_word_length1 flagi);
    W5 (word_of_int len0_word_length5 rs1);
    W5 (word_of_int len0_word_length5 rs2);
    W5 (word_of_int len0_word_length5 rd)])
                               else Inr (Ctrl_type JMPL,
  [Flag (word_of_int len0_word_length1 flagi);
    W5 (word_of_int len0_word_length5 rs1);
    Simm13 (word_of_int len0_word_length13 simm13);
    W5 (word_of_int len0_word_length5 rd)]))
                        else (if equal_inta op3
                                   (uint len0_word_length6
                                     (word_of_int len0_word_length6
                                       (Pos
 (Bit1 (Bit0 (Bit0 (Bit1 (Bit1 One))))))))
                               then (if equal_inta flagi Zero_int
                                      then Inr
     (Ctrl_type RETT,
       [Flag (word_of_int len0_word_length1 flagi);
         W5 (word_of_int len0_word_length5 rs1);
         W5 (word_of_int len0_word_length5 rs2)])
                                      else Inr
     (Ctrl_type RETT,
       [Flag (word_of_int len0_word_length1 flagi);
         W5 (word_of_int len0_word_length5 rs1);
         Simm13 (word_of_int len0_word_length13 simm13)]))
                               else (if equal_inta op3
  (uint len0_word_length6
    (word_of_int len0_word_length6
      (Pos (Bit0 (Bit0 (Bit0 (Bit1 (Bit0 One)))))))) &&
  not (equal_inta rs1 Zero_int)
                                      then (if equal_inta rs1
         (uint len0_word_length6
           (word_of_int len0_word_length6 (Pos (Bit1 (Bit1 (Bit1 One)))))) &&
         equal_inta rd Zero_int
     then Inr (Load_store_type STBAR, [])
     else Inr (Sreg_type RDASR,
                [W5 (word_of_int len0_word_length5 rs1);
                  W5 (word_of_int len0_word_length5 rd)]))
                                      else (if equal_inta op3
         (uint len0_word_length6
           (word_of_int len0_word_length6
             (Pos (Bit0 (Bit0 (Bit0 (Bit1 (Bit0 One)))))))) &&
         equal_inta rs1 Zero_int
     then Inr (Sreg_type RDY,
                [W5 (word_of_int len0_word_length5 rs1);
                  W5 (word_of_int len0_word_length5 rd)])
     else (if equal_inta op3
                (uint len0_word_length6
                  (word_of_int len0_word_length6
                    (Pos (Bit1 (Bit0 (Bit0 (Bit1 (Bit0 One))))))))
            then Inr (Sreg_type RDPSR,
                       [W5 (word_of_int len0_word_length5 rs1);
                         W5 (word_of_int len0_word_length5 rd)])
            else (if equal_inta op3
                       (uint len0_word_length6
                         (word_of_int len0_word_length6
                           (Pos (Bit0 (Bit1 (Bit0 (Bit1 (Bit0 One))))))))
                   then Inr (Sreg_type RDWIM,
                              [W5 (word_of_int len0_word_length5 rs1);
                                W5 (word_of_int len0_word_length5 rd)])
                   else (if equal_inta op3
                              (uint len0_word_length6
                                (word_of_int len0_word_length6
                                  (Pos (Bit1 (Bit1 (Bit0 (Bit1 (Bit0 One))))))))
                          then Inr (Sreg_type RDTBR,
                                     [W5 (word_of_int len0_word_length5 rs1);
                                       W5 (word_of_int len0_word_length5 rd)])
                          else (if equal_inta op3
                                     (uint len0_word_length6
                                       (word_of_int len0_word_length6
 (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 One)))))))) &&
                                     not (equal_inta rd Zero_int)
                                 then (if equal_inta flagi Zero_int
then Inr (Sreg_type WRASR,
           [Flag (word_of_int len0_word_length1 flagi);
             W5 (word_of_int len0_word_length5 rs1);
             W5 (word_of_int len0_word_length5 rs2);
             W5 (word_of_int len0_word_length5 rd)])
else Inr (Sreg_type WRASR,
           [Flag (word_of_int len0_word_length1 flagi);
             W5 (word_of_int len0_word_length5 rs1);
             Simm13 (word_of_int len0_word_length13 simm13);
             W5 (word_of_int len0_word_length5 rd)]))
                                 else (if equal_inta op3
    (uint len0_word_length6
      (word_of_int len0_word_length6
        (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 One)))))))) &&
    equal_inta rd Zero_int
then (if equal_inta flagi Zero_int
       then Inr (Sreg_type WRY,
                  [Flag (word_of_int len0_word_length1 flagi);
                    W5 (word_of_int len0_word_length5 rs1);
                    W5 (word_of_int len0_word_length5 rs2);
                    W5 (word_of_int len0_word_length5 rd)])
       else Inr (Sreg_type WRY,
                  [Flag (word_of_int len0_word_length1 flagi);
                    W5 (word_of_int len0_word_length5 rs1);
                    Simm13 (word_of_int len0_word_length13 simm13);
                    W5 (word_of_int len0_word_length5 rd)]))
else (if equal_inta op3
           (uint len0_word_length6
             (word_of_int len0_word_length6
               (Pos (Bit1 (Bit0 (Bit0 (Bit0 (Bit1 One))))))))
       then (if equal_inta flagi Zero_int
              then Inr (Sreg_type WRPSR,
                         [Flag (word_of_int len0_word_length1 flagi);
                           W5 (word_of_int len0_word_length5 rs1);
                           W5 (word_of_int len0_word_length5 rs2);
                           W5 (word_of_int len0_word_length5 rd)])
              else Inr (Sreg_type WRPSR,
                         [Flag (word_of_int len0_word_length1 flagi);
                           W5 (word_of_int len0_word_length5 rs1);
                           Simm13 (word_of_int len0_word_length13 simm13);
                           W5 (word_of_int len0_word_length5 rd)]))
       else (if equal_inta op3
                  (uint len0_word_length6
                    (word_of_int len0_word_length6
                      (Pos (Bit0 (Bit1 (Bit0 (Bit0 (Bit1 One))))))))
              then (if equal_inta flagi Zero_int
                     then Inr (Sreg_type WRWIM,
                                [Flag (word_of_int len0_word_length1 flagi);
                                  W5 (word_of_int len0_word_length5 rs1);
                                  W5 (word_of_int len0_word_length5 rs2);
                                  W5 (word_of_int len0_word_length5 rd)])
                     else Inr (Sreg_type WRWIM,
                                [Flag (word_of_int len0_word_length1 flagi);
                                  W5 (word_of_int len0_word_length5 rs1);
                                  Simm13
                                    (word_of_int len0_word_length13 simm13);
                                  W5 (word_of_int len0_word_length5 rd)]))
              else (if equal_inta op3
                         (uint len0_word_length6
                           (word_of_int len0_word_length6
                             (Pos (Bit1 (Bit1 (Bit0 (Bit0 (Bit1 One))))))))
                     then (if equal_inta flagi Zero_int
                            then Inr (Sreg_type WRTBR,
                                       [Flag
  (word_of_int len0_word_length1 flagi);
 W5 (word_of_int len0_word_length5 rs1); W5 (word_of_int len0_word_length5 rs2);
 W5 (word_of_int len0_word_length5 rd)])
                            else Inr (Sreg_type WRTBR,
                                       [Flag
  (word_of_int len0_word_length1 flagi);
 W5 (word_of_int len0_word_length5 rs1);
 Simm13 (word_of_int len0_word_length13 simm13);
 W5 (word_of_int len0_word_length5 rd)]))
                     else (if equal_inta op3
                                (uint len0_word_length6
                                  (word_of_int len0_word_length6
                                    (Pos (Bit1
   (Bit1 (Bit0 (Bit1 (Bit1 One))))))))
                            then (if equal_inta flagi Zero_int
                                   then Inr
  (Load_store_type FLUSH,
    [Flag (word_of_int len0_word_length1 flagi);
      W5 (word_of_int len0_word_length5 rs1);
      W5 (word_of_int len0_word_length5 rs2)])
                                   else Inr
  (Load_store_type FLUSH,
    [Flag (word_of_int len0_word_length1 flagi);
      W5 (word_of_int len0_word_length5 rs1);
      Simm13 (word_of_int len0_word_length13 simm13)]))
                            else (if equal_inta op3
                                       (uint len0_word_length6
 (one_word len0_word_length6))
                                   then (if equal_inta flagi Zero_int
  then Inr (Logic_type ANDs,
             [Flag (word_of_int len0_word_length1 flagi);
               W5 (word_of_int len0_word_length5 rs1);
               W5 (word_of_int len0_word_length5 rs2);
               W5 (word_of_int len0_word_length5 rd)])
  else Inr (Logic_type ANDs,
             [Flag (word_of_int len0_word_length1 flagi);
               W5 (word_of_int len0_word_length5 rs1);
               Simm13 (word_of_int len0_word_length13 simm13);
               W5 (word_of_int len0_word_length5 rd)]))
                                   else (if equal_inta op3
      (uint len0_word_length6
        (word_of_int len0_word_length6 (Pos (Bit1 (Bit0 (Bit0 (Bit0 One)))))))
  then (if equal_inta flagi Zero_int
         then Inr (Logic_type ANDcc,
                    [Flag (word_of_int len0_word_length1 flagi);
                      W5 (word_of_int len0_word_length5 rs1);
                      W5 (word_of_int len0_word_length5 rs2);
                      W5 (word_of_int len0_word_length5 rd)])
         else Inr (Logic_type ANDcc,
                    [Flag (word_of_int len0_word_length1 flagi);
                      W5 (word_of_int len0_word_length5 rs1);
                      Simm13 (word_of_int len0_word_length13 simm13);
                      W5 (word_of_int len0_word_length5 rd)]))
  else (if equal_inta op3
             (uint len0_word_length6
               (word_of_int len0_word_length6 (Pos (Bit1 (Bit0 One)))))
         then (if equal_inta flagi Zero_int
                then Inr (Logic_type ANDN,
                           [Flag (word_of_int len0_word_length1 flagi);
                             W5 (word_of_int len0_word_length5 rs1);
                             W5 (word_of_int len0_word_length5 rs2);
                             W5 (word_of_int len0_word_length5 rd)])
                else Inr (Logic_type ANDN,
                           [Flag (word_of_int len0_word_length1 flagi);
                             W5 (word_of_int len0_word_length5 rs1);
                             Simm13 (word_of_int len0_word_length13 simm13);
                             W5 (word_of_int len0_word_length5 rd)]))
         else (if equal_inta op3
                    (uint len0_word_length6
                      (word_of_int len0_word_length6
                        (Pos (Bit1 (Bit0 (Bit1 (Bit0 One)))))))
                then (if equal_inta flagi Zero_int
                       then Inr (Logic_type ANDNcc,
                                  [Flag (word_of_int len0_word_length1 flagi);
                                    W5 (word_of_int len0_word_length5 rs1);
                                    W5 (word_of_int len0_word_length5 rs2);
                                    W5 (word_of_int len0_word_length5 rd)])
                       else Inr (Logic_type ANDNcc,
                                  [Flag (word_of_int len0_word_length1 flagi);
                                    W5 (word_of_int len0_word_length5 rs1);
                                    Simm13
                                      (word_of_int len0_word_length13 simm13);
                                    W5 (word_of_int len0_word_length5 rd)]))
                else (if equal_inta op3
                           (uint len0_word_length6
                             (word_of_int len0_word_length6 (Pos (Bit0 One))))
                       then (if equal_inta flagi Zero_int
                              then Inr (Logic_type ORs,
 [Flag (word_of_int len0_word_length1 flagi);
   W5 (word_of_int len0_word_length5 rs1);
   W5 (word_of_int len0_word_length5 rs2);
   W5 (word_of_int len0_word_length5 rd)])
                              else Inr (Logic_type ORs,
 [Flag (word_of_int len0_word_length1 flagi);
   W5 (word_of_int len0_word_length5 rs1);
   Simm13 (word_of_int len0_word_length13 simm13);
   W5 (word_of_int len0_word_length5 rd)]))
                       else (if equal_inta op3
                                  (uint len0_word_length6
                                    (word_of_int len0_word_length6
                                      (Pos (Bit0 (Bit1 (Bit0 (Bit0 One)))))))
                              then (if equal_inta flagi Zero_int
                                     then Inr
    (Logic_type ORcc,
      [Flag (word_of_int len0_word_length1 flagi);
        W5 (word_of_int len0_word_length5 rs1);
        W5 (word_of_int len0_word_length5 rs2);
        W5 (word_of_int len0_word_length5 rd)])
                                     else Inr
    (Logic_type ORcc,
      [Flag (word_of_int len0_word_length1 flagi);
        W5 (word_of_int len0_word_length5 rs1);
        Simm13 (word_of_int len0_word_length13 simm13);
        W5 (word_of_int len0_word_length5 rd)]))
                              else (if equal_inta op3
 (uint len0_word_length6
   (word_of_int len0_word_length6 (Pos (Bit0 (Bit1 One)))))
                                     then (if equal_inta flagi Zero_int
    then Inr (Logic_type ORN,
               [Flag (word_of_int len0_word_length1 flagi);
                 W5 (word_of_int len0_word_length5 rs1);
                 W5 (word_of_int len0_word_length5 rs2);
                 W5 (word_of_int len0_word_length5 rd)])
    else Inr (Logic_type ORN,
               [Flag (word_of_int len0_word_length1 flagi);
                 W5 (word_of_int len0_word_length5 rs1);
                 Simm13 (word_of_int len0_word_length13 simm13);
                 W5 (word_of_int len0_word_length5 rd)]))
                                     else (if equal_inta op3
        (uint len0_word_length6
          (word_of_int len0_word_length6 (Pos (Bit0 (Bit1 (Bit1 (Bit0 One)))))))
    then (if equal_inta flagi Zero_int
           then Inr (Logic_type ORNcc,
                      [Flag (word_of_int len0_word_length1 flagi);
                        W5 (word_of_int len0_word_length5 rs1);
                        W5 (word_of_int len0_word_length5 rs2);
                        W5 (word_of_int len0_word_length5 rd)])
           else Inr (Logic_type ORNcc,
                      [Flag (word_of_int len0_word_length1 flagi);
                        W5 (word_of_int len0_word_length5 rs1);
                        Simm13 (word_of_int len0_word_length13 simm13);
                        W5 (word_of_int len0_word_length5 rd)]))
    else (if equal_inta op3
               (uint len0_word_length6
                 (word_of_int len0_word_length6 (Pos (Bit1 One))))
           then (if equal_inta flagi Zero_int
                  then Inr (Logic_type XORs,
                             [Flag (word_of_int len0_word_length1 flagi);
                               W5 (word_of_int len0_word_length5 rs1);
                               W5 (word_of_int len0_word_length5 rs2);
                               W5 (word_of_int len0_word_length5 rd)])
                  else Inr (Logic_type XORs,
                             [Flag (word_of_int len0_word_length1 flagi);
                               W5 (word_of_int len0_word_length5 rs1);
                               Simm13 (word_of_int len0_word_length13 simm13);
                               W5 (word_of_int len0_word_length5 rd)]))
           else (if equal_inta op3
                      (uint len0_word_length6
                        (word_of_int len0_word_length6
                          (Pos (Bit1 (Bit1 (Bit0 (Bit0 One)))))))
                  then (if equal_inta flagi Zero_int
                         then Inr (Logic_type XORcc,
                                    [Flag (word_of_int len0_word_length1 flagi);
                                      W5 (word_of_int len0_word_length5 rs1);
                                      W5 (word_of_int len0_word_length5 rs2);
                                      W5 (word_of_int len0_word_length5 rd)])
                         else Inr (Logic_type XORcc,
                                    [Flag (word_of_int len0_word_length1 flagi);
                                      W5 (word_of_int len0_word_length5 rs1);
                                      Simm13
(word_of_int len0_word_length13 simm13);
                                      W5 (word_of_int len0_word_length5 rd)]))
                  else (if equal_inta op3
                             (uint len0_word_length6
                               (word_of_int len0_word_length6
                                 (Pos (Bit1 (Bit1 One)))))
                         then (if equal_inta flagi Zero_int
                                then Inr (Logic_type XNOR,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     W5 (word_of_int len0_word_length5 rs2);
     W5 (word_of_int len0_word_length5 rd)])
                                else Inr (Logic_type XNOR,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     Simm13 (word_of_int len0_word_length13 simm13);
     W5 (word_of_int len0_word_length5 rd)]))
                         else (if equal_inta op3
                                    (uint len0_word_length6
                                      (word_of_int len0_word_length6
(Pos (Bit1 (Bit1 (Bit1 (Bit0 One)))))))
                                then (if equal_inta flagi Zero_int
                                       then Inr
      (Logic_type XNORcc,
        [Flag (word_of_int len0_word_length1 flagi);
          W5 (word_of_int len0_word_length5 rs1);
          W5 (word_of_int len0_word_length5 rs2);
          W5 (word_of_int len0_word_length5 rd)])
                                       else Inr
      (Logic_type XNORcc,
        [Flag (word_of_int len0_word_length1 flagi);
          W5 (word_of_int len0_word_length5 rs1);
          Simm13 (word_of_int len0_word_length13 simm13);
          W5 (word_of_int len0_word_length5 rd)]))
                                else (if equal_inta op3
   (uint len0_word_length6
     (word_of_int len0_word_length6
       (Pos (Bit1 (Bit0 (Bit1 (Bit0 (Bit0 One))))))))
                                       then (if equal_inta flagi Zero_int
      then Inr (Shift_type SLL,
                 [Flag (word_of_int len0_word_length1 flagi);
                   W5 (word_of_int len0_word_length5 rs1);
                   W5 (word_of_int len0_word_length5 rs2);
                   W5 (word_of_int len0_word_length5 rd)])
      else (let shcnt = rs2 in
             Inr (Shift_type SLL,
                   [Flag (word_of_int len0_word_length1 flagi);
                     W5 (word_of_int len0_word_length5 rs1);
                     W5 (word_of_int len0_word_length5 shcnt);
                     W5 (word_of_int len0_word_length5 rd)])))
                                       else (if equal_inta op3
          (uint len0_word_length6
            (word_of_int len0_word_length6
              (Pos (Bit0 (Bit1 (Bit1 (Bit0 (Bit0 One))))))))
      then (if equal_inta flagi Zero_int
             then Inr (Shift_type SRL,
                        [Flag (word_of_int len0_word_length1 flagi);
                          W5 (word_of_int len0_word_length5 rs1);
                          W5 (word_of_int len0_word_length5 rs2);
                          W5 (word_of_int len0_word_length5 rd)])
             else (let shcnt = rs2 in
                    Inr (Shift_type SRL,
                          [Flag (word_of_int len0_word_length1 flagi);
                            W5 (word_of_int len0_word_length5 rs1);
                            W5 (word_of_int len0_word_length5 shcnt);
                            W5 (word_of_int len0_word_length5 rd)])))
      else (if equal_inta op3
                 (uint len0_word_length6
                   (word_of_int len0_word_length6
                     (Pos (Bit1 (Bit1 (Bit1 (Bit0 (Bit0 One))))))))
             then (if equal_inta flagi Zero_int
                    then Inr (Shift_type SRA,
                               [Flag (word_of_int len0_word_length1 flagi);
                                 W5 (word_of_int len0_word_length5 rs1);
                                 W5 (word_of_int len0_word_length5 rs2);
                                 W5 (word_of_int len0_word_length5 rd)])
                    else (let shcnt = rs2 in
                           Inr (Shift_type SRA,
                                 [Flag (word_of_int len0_word_length1 flagi);
                                   W5 (word_of_int len0_word_length5 rs1);
                                   W5 (word_of_int len0_word_length5 shcnt);
                                   W5 (word_of_int len0_word_length5 rd)])))
             else (if equal_inta op3
                        (uint len0_word_length6 (zero_word len0_word_length6))
                    then (if equal_inta flagi Zero_int
                           then Inr (Arith_type ADD,
                                      [Flag
 (word_of_int len0_word_length1 flagi);
W5 (word_of_int len0_word_length5 rs1); W5 (word_of_int len0_word_length5 rs2);
W5 (word_of_int len0_word_length5 rd)])
                           else Inr (Arith_type ADD,
                                      [Flag
 (word_of_int len0_word_length1 flagi);
W5 (word_of_int len0_word_length5 rs1);
Simm13 (word_of_int len0_word_length13 simm13);
W5 (word_of_int len0_word_length5 rd)]))
                    else (if equal_inta op3
                               (uint len0_word_length6
                                 (word_of_int len0_word_length6
                                   (Pos (Bit0 (Bit0 (Bit0 (Bit0 One)))))))
                           then (if equal_inta flagi Zero_int
                                  then Inr
 (Arith_type ADDcc,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     W5 (word_of_int len0_word_length5 rs2);
     W5 (word_of_int len0_word_length5 rd)])
                                  else Inr
 (Arith_type ADDcc,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     Simm13 (word_of_int len0_word_length13 simm13);
     W5 (word_of_int len0_word_length5 rd)]))
                           else (if equal_inta op3
                                      (uint len0_word_length6
(word_of_int len0_word_length6 (Pos (Bit0 (Bit0 (Bit0 One))))))
                                  then (if equal_inta flagi Zero_int
 then Inr (Arith_type ADDX,
            [Flag (word_of_int len0_word_length1 flagi);
              W5 (word_of_int len0_word_length5 rs1);
              W5 (word_of_int len0_word_length5 rs2);
              W5 (word_of_int len0_word_length5 rd)])
 else Inr (Arith_type ADDX,
            [Flag (word_of_int len0_word_length1 flagi);
              W5 (word_of_int len0_word_length5 rs1);
              Simm13 (word_of_int len0_word_length13 simm13);
              W5 (word_of_int len0_word_length5 rd)]))
                                  else (if equal_inta op3
     (uint len0_word_length6
       (word_of_int len0_word_length6 (Pos (Bit0 (Bit0 (Bit0 (Bit1 One)))))))
 then (if equal_inta flagi Zero_int
        then Inr (Arith_type ADDXcc,
                   [Flag (word_of_int len0_word_length1 flagi);
                     W5 (word_of_int len0_word_length5 rs1);
                     W5 (word_of_int len0_word_length5 rs2);
                     W5 (word_of_int len0_word_length5 rd)])
        else Inr (Arith_type ADDXcc,
                   [Flag (word_of_int len0_word_length1 flagi);
                     W5 (word_of_int len0_word_length5 rs1);
                     Simm13 (word_of_int len0_word_length13 simm13);
                     W5 (word_of_int len0_word_length5 rd)]))
 else (if equal_inta op3
            (uint len0_word_length6
              (word_of_int len0_word_length6
                (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))
        then (if equal_inta flagi Zero_int
               then Inr (Arith_type TADDcc,
                          [Flag (word_of_int len0_word_length1 flagi);
                            W5 (word_of_int len0_word_length5 rs1);
                            W5 (word_of_int len0_word_length5 rs2);
                            W5 (word_of_int len0_word_length5 rd)])
               else Inr (Arith_type TADDcc,
                          [Flag (word_of_int len0_word_length1 flagi);
                            W5 (word_of_int len0_word_length5 rs1);
                            Simm13 (word_of_int len0_word_length13 simm13);
                            W5 (word_of_int len0_word_length5 rd)]))
        else (if equal_inta op3
                   (uint len0_word_length6
                     (word_of_int len0_word_length6
                       (Pos (Bit0 (Bit1 (Bit0 (Bit0 (Bit0 One))))))))
               then (if equal_inta flagi Zero_int
                      then Inr (Arith_type TADDccTV,
                                 [Flag (word_of_int len0_word_length1 flagi);
                                   W5 (word_of_int len0_word_length5 rs1);
                                   W5 (word_of_int len0_word_length5 rs2);
                                   W5 (word_of_int len0_word_length5 rd)])
                      else Inr (Arith_type TADDccTV,
                                 [Flag (word_of_int len0_word_length1 flagi);
                                   W5 (word_of_int len0_word_length5 rs1);
                                   Simm13
                                     (word_of_int len0_word_length13 simm13);
                                   W5 (word_of_int len0_word_length5 rd)]))
               else (if equal_inta op3
                          (uint len0_word_length6
                            (word_of_int len0_word_length6
                              (Pos (Bit0 (Bit0 One)))))
                      then (if equal_inta flagi Zero_int
                             then Inr (Arith_type SUB,
[Flag (word_of_int len0_word_length1 flagi);
  W5 (word_of_int len0_word_length5 rs1);
  W5 (word_of_int len0_word_length5 rs2);
  W5 (word_of_int len0_word_length5 rd)])
                             else Inr (Arith_type SUB,
[Flag (word_of_int len0_word_length1 flagi);
  W5 (word_of_int len0_word_length5 rs1);
  Simm13 (word_of_int len0_word_length13 simm13);
  W5 (word_of_int len0_word_length5 rd)]))
                      else (if equal_inta op3
                                 (uint len0_word_length6
                                   (word_of_int len0_word_length6
                                     (Pos (Bit0 (Bit0 (Bit1 (Bit0 One)))))))
                             then (if equal_inta flagi Zero_int
                                    then Inr
   (Arith_type SUBcc,
     [Flag (word_of_int len0_word_length1 flagi);
       W5 (word_of_int len0_word_length5 rs1);
       W5 (word_of_int len0_word_length5 rs2);
       W5 (word_of_int len0_word_length5 rd)])
                                    else Inr
   (Arith_type SUBcc,
     [Flag (word_of_int len0_word_length1 flagi);
       W5 (word_of_int len0_word_length5 rs1);
       Simm13 (word_of_int len0_word_length13 simm13);
       W5 (word_of_int len0_word_length5 rd)]))
                             else (if equal_inta op3
(uint len0_word_length6
  (word_of_int len0_word_length6 (Pos (Bit0 (Bit0 (Bit1 One))))))
                                    then (if equal_inta flagi Zero_int
   then Inr (Arith_type SUBX,
              [Flag (word_of_int len0_word_length1 flagi);
                W5 (word_of_int len0_word_length5 rs1);
                W5 (word_of_int len0_word_length5 rs2);
                W5 (word_of_int len0_word_length5 rd)])
   else Inr (Arith_type SUBX,
              [Flag (word_of_int len0_word_length1 flagi);
                W5 (word_of_int len0_word_length5 rs1);
                Simm13 (word_of_int len0_word_length13 simm13);
                W5 (word_of_int len0_word_length5 rd)]))
                                    else (if equal_inta op3
       (uint len0_word_length6
         (word_of_int len0_word_length6 (Pos (Bit0 (Bit0 (Bit1 (Bit1 One)))))))
   then (if equal_inta flagi Zero_int
          then Inr (Arith_type SUBXcc,
                     [Flag (word_of_int len0_word_length1 flagi);
                       W5 (word_of_int len0_word_length5 rs1);
                       W5 (word_of_int len0_word_length5 rs2);
                       W5 (word_of_int len0_word_length5 rd)])
          else Inr (Arith_type SUBXcc,
                     [Flag (word_of_int len0_word_length1 flagi);
                       W5 (word_of_int len0_word_length5 rs1);
                       Simm13 (word_of_int len0_word_length13 simm13);
                       W5 (word_of_int len0_word_length5 rd)]))
   else (if equal_inta op3
              (uint len0_word_length6
                (word_of_int len0_word_length6
                  (Pos (Bit1 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))
          then (if equal_inta flagi Zero_int
                 then Inr (Arith_type TSUBcc,
                            [Flag (word_of_int len0_word_length1 flagi);
                              W5 (word_of_int len0_word_length5 rs1);
                              W5 (word_of_int len0_word_length5 rs2);
                              W5 (word_of_int len0_word_length5 rd)])
                 else Inr (Arith_type TSUBcc,
                            [Flag (word_of_int len0_word_length1 flagi);
                              W5 (word_of_int len0_word_length5 rs1);
                              Simm13 (word_of_int len0_word_length13 simm13);
                              W5 (word_of_int len0_word_length5 rd)]))
          else (if equal_inta op3
                     (uint len0_word_length6
                       (word_of_int len0_word_length6
                         (Pos (Bit1 (Bit1 (Bit0 (Bit0 (Bit0 One))))))))
                 then (if equal_inta flagi Zero_int
                        then Inr (Arith_type TSUBccTV,
                                   [Flag (word_of_int len0_word_length1 flagi);
                                     W5 (word_of_int len0_word_length5 rs1);
                                     W5 (word_of_int len0_word_length5 rs2);
                                     W5 (word_of_int len0_word_length5 rd)])
                        else Inr (Arith_type TSUBccTV,
                                   [Flag (word_of_int len0_word_length1 flagi);
                                     W5 (word_of_int len0_word_length5 rs1);
                                     Simm13
                                       (word_of_int len0_word_length13 simm13);
                                     W5 (word_of_int len0_word_length5 rd)]))
                 else (if equal_inta op3
                            (uint len0_word_length6
                              (word_of_int len0_word_length6
                                (Pos (Bit0 (Bit0 (Bit1 (Bit0 (Bit0 One))))))))
                        then (if equal_inta flagi Zero_int
                               then Inr (Arith_type MULScc,
  [Flag (word_of_int len0_word_length1 flagi);
    W5 (word_of_int len0_word_length5 rs1);
    W5 (word_of_int len0_word_length5 rs2);
    W5 (word_of_int len0_word_length5 rd)])
                               else Inr (Arith_type MULScc,
  [Flag (word_of_int len0_word_length1 flagi);
    W5 (word_of_int len0_word_length5 rs1);
    Simm13 (word_of_int len0_word_length13 simm13);
    W5 (word_of_int len0_word_length5 rd)]))
                        else (if equal_inta op3
                                   (uint len0_word_length6
                                     (word_of_int len0_word_length6
                                       (Pos (Bit0 (Bit1 (Bit0 One))))))
                               then (if equal_inta flagi Zero_int
                                      then Inr
     (Arith_type UMUL,
       [Flag (word_of_int len0_word_length1 flagi);
         W5 (word_of_int len0_word_length5 rs1);
         W5 (word_of_int len0_word_length5 rs2);
         W5 (word_of_int len0_word_length5 rd)])
                                      else Inr
     (Arith_type UMUL,
       [Flag (word_of_int len0_word_length1 flagi);
         W5 (word_of_int len0_word_length5 rs1);
         Simm13 (word_of_int len0_word_length13 simm13);
         W5 (word_of_int len0_word_length5 rd)]))
                               else (if equal_inta op3
  (uint len0_word_length6
    (word_of_int len0_word_length6 (Pos (Bit0 (Bit1 (Bit0 (Bit1 One)))))))
                                      then (if equal_inta flagi Zero_int
     then Inr (Arith_type UMULcc,
                [Flag (word_of_int len0_word_length1 flagi);
                  W5 (word_of_int len0_word_length5 rs1);
                  W5 (word_of_int len0_word_length5 rs2);
                  W5 (word_of_int len0_word_length5 rd)])
     else Inr (Arith_type UMULcc,
                [Flag (word_of_int len0_word_length1 flagi);
                  W5 (word_of_int len0_word_length5 rs1);
                  Simm13 (word_of_int len0_word_length13 simm13);
                  W5 (word_of_int len0_word_length5 rd)]))
                                      else (if equal_inta op3
         (uint len0_word_length6
           (word_of_int len0_word_length6 (Pos (Bit1 (Bit1 (Bit0 One))))))
     then (if equal_inta flagi Zero_int
            then Inr (Arith_type SMUL,
                       [Flag (word_of_int len0_word_length1 flagi);
                         W5 (word_of_int len0_word_length5 rs1);
                         W5 (word_of_int len0_word_length5 rs2);
                         W5 (word_of_int len0_word_length5 rd)])
            else Inr (Arith_type SMUL,
                       [Flag (word_of_int len0_word_length1 flagi);
                         W5 (word_of_int len0_word_length5 rs1);
                         Simm13 (word_of_int len0_word_length13 simm13);
                         W5 (word_of_int len0_word_length5 rd)]))
     else (if equal_inta op3
                (uint len0_word_length6
                  (word_of_int len0_word_length6
                    (Pos (Bit1 (Bit1 (Bit0 (Bit1 One)))))))
            then (if equal_inta flagi Zero_int
                   then Inr (Arith_type SMULcc,
                              [Flag (word_of_int len0_word_length1 flagi);
                                W5 (word_of_int len0_word_length5 rs1);
                                W5 (word_of_int len0_word_length5 rs2);
                                W5 (word_of_int len0_word_length5 rd)])
                   else Inr (Arith_type SMULcc,
                              [Flag (word_of_int len0_word_length1 flagi);
                                W5 (word_of_int len0_word_length5 rs1);
                                Simm13 (word_of_int len0_word_length13 simm13);
                                W5 (word_of_int len0_word_length5 rd)]))
            else (if equal_inta op3
                       (uint len0_word_length6
                         (word_of_int len0_word_length6
                           (Pos (Bit0 (Bit1 (Bit1 One))))))
                   then (if equal_inta flagi Zero_int
                          then Inr (Arith_type UDIV,
                                     [Flag
(word_of_int len0_word_length1 flagi);
                                       W5 (word_of_int len0_word_length5 rs1);
                                       W5 (word_of_int len0_word_length5 rs2);
                                       W5 (word_of_int len0_word_length5 rd)])
                          else Inr (Arith_type UDIV,
                                     [Flag
(word_of_int len0_word_length1 flagi);
                                       W5 (word_of_int len0_word_length5 rs1);
                                       Simm13
 (word_of_int len0_word_length13 simm13);
                                       W5 (word_of_int len0_word_length5 rd)]))
                   else (if equal_inta op3
                              (uint len0_word_length6
                                (word_of_int len0_word_length6
                                  (Pos (Bit0 (Bit1 (Bit1 (Bit1 One)))))))
                          then (if equal_inta flagi Zero_int
                                 then Inr
(Arith_type UDIVcc,
  [Flag (word_of_int len0_word_length1 flagi);
    W5 (word_of_int len0_word_length5 rs1);
    W5 (word_of_int len0_word_length5 rs2);
    W5 (word_of_int len0_word_length5 rd)])
                                 else Inr
(Arith_type UDIVcc,
  [Flag (word_of_int len0_word_length1 flagi);
    W5 (word_of_int len0_word_length5 rs1);
    Simm13 (word_of_int len0_word_length13 simm13);
    W5 (word_of_int len0_word_length5 rd)]))
                          else (if equal_inta op3
                                     (uint len0_word_length6
                                       (word_of_int len0_word_length6
 (Pos (Bit1 (Bit1 (Bit1 One))))))
                                 then (if equal_inta flagi Zero_int
then Inr (Arith_type SDIV,
           [Flag (word_of_int len0_word_length1 flagi);
             W5 (word_of_int len0_word_length5 rs1);
             W5 (word_of_int len0_word_length5 rs2);
             W5 (word_of_int len0_word_length5 rd)])
else Inr (Arith_type SDIV,
           [Flag (word_of_int len0_word_length1 flagi);
             W5 (word_of_int len0_word_length5 rs1);
             Simm13 (word_of_int len0_word_length13 simm13);
             W5 (word_of_int len0_word_length5 rd)]))
                                 else (if equal_inta op3
    (uint len0_word_length6
      (word_of_int len0_word_length6 (Pos (Bit1 (Bit1 (Bit1 (Bit1 One)))))))
then (if equal_inta flagi Zero_int
       then Inr (Arith_type SDIVcc,
                  [Flag (word_of_int len0_word_length1 flagi);
                    W5 (word_of_int len0_word_length5 rs1);
                    W5 (word_of_int len0_word_length5 rs2);
                    W5 (word_of_int len0_word_length5 rd)])
       else Inr (Arith_type SDIVcc,
                  [Flag (word_of_int len0_word_length1 flagi);
                    W5 (word_of_int len0_word_length5 rs1);
                    Simm13 (word_of_int len0_word_length13 simm13);
                    W5 (word_of_int len0_word_length5 rd)]))
else (if equal_inta op3
           (uint len0_word_length6
             (word_of_int len0_word_length6
               (Pos (Bit0 (Bit0 (Bit1 (Bit1 (Bit1 One))))))))
       then (if equal_inta flagi Zero_int
              then Inr (Ctrl_type SAVE,
                         [Flag (word_of_int len0_word_length1 flagi);
                           W5 (word_of_int len0_word_length5 rs1);
                           W5 (word_of_int len0_word_length5 rs2);
                           W5 (word_of_int len0_word_length5 rd)])
              else Inr (Ctrl_type SAVE,
                         [Flag (word_of_int len0_word_length1 flagi);
                           W5 (word_of_int len0_word_length5 rs1);
                           Simm13 (word_of_int len0_word_length13 simm13);
                           W5 (word_of_int len0_word_length5 rd)]))
       else (if equal_inta op3
                  (uint len0_word_length6
                    (word_of_int len0_word_length6
                      (Pos (Bit1 (Bit0 (Bit1 (Bit1 (Bit1 One))))))))
              then (if equal_inta flagi Zero_int
                     then Inr (Ctrl_type RESTORE,
                                [Flag (word_of_int len0_word_length1 flagi);
                                  W5 (word_of_int len0_word_length5 rs1);
                                  W5 (word_of_int len0_word_length5 rs2);
                                  W5 (word_of_int len0_word_length5 rd)])
                     else Inr (Ctrl_type RESTORE,
                                [Flag (word_of_int len0_word_length1 flagi);
                                  W5 (word_of_int len0_word_length5 rs1);
                                  Simm13
                                    (word_of_int len0_word_length13 simm13);
                                  W5 (word_of_int len0_word_length5 rd)]))
              else (if equal_inta op3
                         (uint len0_word_length6
                           (word_of_int len0_word_length6
                             (Pos (Bit0 (Bit1 (Bit0 (Bit1 (Bit1 One))))))))
                     then (let trap_cond = get_trap_cond w in
                           let trap_imm7 = get_trap_imm7 w in
                            (if equal_inta trap_cond
                                  (uint len0_word_length4
                                    (word_of_int len0_word_length4
                                      (Pos (Bit0 (Bit0 (Bit0 One))))))
                              then (if equal_inta flagi Zero_int
                                     then Inr
    (Ticc_type TA,
      [Flag (word_of_int len0_word_length1 flagi);
        W5 (word_of_int len0_word_length5 rs1);
        W5 (word_of_int len0_word_length5 rs2)])
                                     else Inr
    (Ticc_type TA,
      [Flag (word_of_int len0_word_length1 flagi);
        W5 (word_of_int len0_word_length5 rs1);
        Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                              else (if equal_inta trap_cond
 (uint len0_word_length4 (zero_word len0_word_length4))
                                     then (if equal_inta flagi Zero_int
    then Inr (Ticc_type TN,
               [Flag (word_of_int len0_word_length1 flagi);
                 W5 (word_of_int len0_word_length5 rs1);
                 W5 (word_of_int len0_word_length5 rs2)])
    else Inr (Ticc_type TN,
               [Flag (word_of_int len0_word_length1 flagi);
                 W5 (word_of_int len0_word_length5 rs1);
                 Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                                     else (if equal_inta trap_cond
        (uint len0_word_length4
          (word_of_int len0_word_length4 (Pos (Bit1 (Bit0 (Bit0 One))))))
    then (if equal_inta flagi Zero_int
           then Inr (Ticc_type TNE,
                      [Flag (word_of_int len0_word_length1 flagi);
                        W5 (word_of_int len0_word_length5 rs1);
                        W5 (word_of_int len0_word_length5 rs2)])
           else Inr (Ticc_type TNE,
                      [Flag (word_of_int len0_word_length1 flagi);
                        W5 (word_of_int len0_word_length5 rs1);
                        Imm7 (word_of_int len0_word_length7 trap_imm7)]))
    else (if equal_inta trap_cond
               (uint len0_word_length4 (one_word len0_word_length4))
           then (if equal_inta flagi Zero_int
                  then Inr (Ticc_type TE,
                             [Flag (word_of_int len0_word_length1 flagi);
                               W5 (word_of_int len0_word_length5 rs1);
                               W5 (word_of_int len0_word_length5 rs2)])
                  else Inr (Ticc_type TE,
                             [Flag (word_of_int len0_word_length1 flagi);
                               W5 (word_of_int len0_word_length5 rs1);
                               Imm7 (word_of_int len0_word_length7 trap_imm7)]))
           else (if equal_inta trap_cond
                      (uint len0_word_length4
                        (word_of_int len0_word_length4
                          (Pos (Bit0 (Bit1 (Bit0 One))))))
                  then (if equal_inta flagi Zero_int
                         then Inr (Ticc_type TG,
                                    [Flag (word_of_int len0_word_length1 flagi);
                                      W5 (word_of_int len0_word_length5 rs1);
                                      W5 (word_of_int len0_word_length5 rs2)])
                         else Inr (Ticc_type TG,
                                    [Flag (word_of_int len0_word_length1 flagi);
                                      W5 (word_of_int len0_word_length5 rs1);
                                      Imm7
(word_of_int len0_word_length7 trap_imm7)]))
                  else (if equal_inta trap_cond
                             (uint len0_word_length4
                               (word_of_int len0_word_length4 (Pos (Bit0 One))))
                         then (if equal_inta flagi Zero_int
                                then Inr (Ticc_type TLE,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     W5 (word_of_int len0_word_length5 rs2)])
                                else Inr (Ticc_type TLE,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                         else (if equal_inta trap_cond
                                    (uint len0_word_length4
                                      (word_of_int len0_word_length4
(Pos (Bit1 (Bit1 (Bit0 One))))))
                                then (if equal_inta flagi Zero_int
                                       then Inr
      (Ticc_type TGE,
        [Flag (word_of_int len0_word_length1 flagi);
          W5 (word_of_int len0_word_length5 rs1);
          W5 (word_of_int len0_word_length5 rs2)])
                                       else Inr
      (Ticc_type TGE,
        [Flag (word_of_int len0_word_length1 flagi);
          W5 (word_of_int len0_word_length5 rs1);
          Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                                else (if equal_inta trap_cond
   (uint len0_word_length4 (word_of_int len0_word_length4 (Pos (Bit1 One))))
                                       then (if equal_inta flagi Zero_int
      then Inr (Ticc_type TL,
                 [Flag (word_of_int len0_word_length1 flagi);
                   W5 (word_of_int len0_word_length5 rs1);
                   W5 (word_of_int len0_word_length5 rs2)])
      else Inr (Ticc_type TL,
                 [Flag (word_of_int len0_word_length1 flagi);
                   W5 (word_of_int len0_word_length5 rs1);
                   Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                                       else (if equal_inta trap_cond
          (uint len0_word_length4
            (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 (Bit1 One))))))
      then (if equal_inta flagi Zero_int
             then Inr (Ticc_type TGU,
                        [Flag (word_of_int len0_word_length1 flagi);
                          W5 (word_of_int len0_word_length5 rs1);
                          W5 (word_of_int len0_word_length5 rs2)])
             else Inr (Ticc_type TGU,
                        [Flag (word_of_int len0_word_length1 flagi);
                          W5 (word_of_int len0_word_length5 rs1);
                          Imm7 (word_of_int len0_word_length7 trap_imm7)]))
      else (if equal_inta trap_cond
                 (uint len0_word_length4
                   (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 One)))))
             then (if equal_inta flagi Zero_int
                    then Inr (Ticc_type TLEU,
                               [Flag (word_of_int len0_word_length1 flagi);
                                 W5 (word_of_int len0_word_length5 rs1);
                                 W5 (word_of_int len0_word_length5 rs2)])
                    else Inr (Ticc_type TLEU,
                               [Flag (word_of_int len0_word_length1 flagi);
                                 W5 (word_of_int len0_word_length5 rs1);
                                 Imm7 (word_of_int len0_word_length7
trap_imm7)]))
             else (if equal_inta trap_cond
                        (uint len0_word_length4
                          (word_of_int len0_word_length4
                            (Pos (Bit1 (Bit0 (Bit1 One))))))
                    then (if equal_inta flagi Zero_int
                           then Inr (Ticc_type TCC,
                                      [Flag
 (word_of_int len0_word_length1 flagi);
W5 (word_of_int len0_word_length5 rs1); W5 (word_of_int len0_word_length5 rs2)])
                           else Inr (Ticc_type TCC,
                                      [Flag
 (word_of_int len0_word_length1 flagi);
W5 (word_of_int len0_word_length5 rs1);
Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                    else (if equal_inta trap_cond
                               (uint len0_word_length4
                                 (word_of_int len0_word_length4
                                   (Pos (Bit1 (Bit0 One)))))
                           then (if equal_inta flagi Zero_int
                                  then Inr
 (Ticc_type TCS,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     W5 (word_of_int len0_word_length5 rs2)])
                                  else Inr
 (Ticc_type TCS,
   [Flag (word_of_int len0_word_length1 flagi);
     W5 (word_of_int len0_word_length5 rs1);
     Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                           else (if equal_inta trap_cond
                                      (uint len0_word_length4
(word_of_int len0_word_length4 (Pos (Bit0 (Bit1 (Bit1 One))))))
                                  then (if equal_inta flagi Zero_int
 then Inr (Ticc_type TPOS,
            [Flag (word_of_int len0_word_length1 flagi);
              W5 (word_of_int len0_word_length5 rs1);
              W5 (word_of_int len0_word_length5 rs2)])
 else Inr (Ticc_type TPOS,
            [Flag (word_of_int len0_word_length1 flagi);
              W5 (word_of_int len0_word_length5 rs1);
              Imm7 (word_of_int len0_word_length7 trap_imm7)]))
                                  else (if equal_inta trap_cond
     (uint len0_word_length4
       (word_of_int len0_word_length4 (Pos (Bit0 (Bit1 One)))))
 then (if equal_inta flagi Zero_int
        then Inr (Ticc_type TNEG,
                   [Flag (word_of_int len0_word_length1 flagi);
                     W5 (word_of_int len0_word_length5 rs1);
                     W5 (word_of_int len0_word_length5 rs2)])
        else Inr (Ticc_type TNEG,
                   [Flag (word_of_int len0_word_length1 flagi);
                     W5 (word_of_int len0_word_length5 rs1);
                     Imm7 (word_of_int len0_word_length7 trap_imm7)]))
 else (if equal_inta trap_cond
            (uint len0_word_length4
              (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One))))))
        then (if equal_inta flagi Zero_int
               then Inr (Ticc_type TVC,
                          [Flag (word_of_int len0_word_length1 flagi);
                            W5 (word_of_int len0_word_length5 rs1);
                            W5 (word_of_int len0_word_length5 rs2)])
               else Inr (Ticc_type TVC,
                          [Flag (word_of_int len0_word_length1 flagi);
                            W5 (word_of_int len0_word_length5 rs1);
                            Imm7 (word_of_int len0_word_length7 trap_imm7)]))
        else (if equal_inta trap_cond
                   (uint len0_word_length4
                     (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 One)))))
               then (if equal_inta flagi Zero_int
                      then Inr (Ticc_type TVS,
                                 [Flag (word_of_int len0_word_length1 flagi);
                                   W5 (word_of_int len0_word_length5 rs1);
                                   W5 (word_of_int len0_word_length5 rs2)])
                      else Inr (Ticc_type TVS,
                                 [Flag (word_of_int len0_word_length1 flagi);
                                   W5 (word_of_int len0_word_length5 rs1);
                                   Imm7 (word_of_int len0_word_length7
  trap_imm7)]))
               else Inl [Invalid_trap_cond])))))))))))))))))
                     else Inl [Invalid_op3_f3_op10]))))))))))))))))))))))))))))))))))))))))))))))))))))
                 else Inl [Invalid_op_f3])));;

let rec get_disp_imm22
  w = (let mask_disp_imm22 =
         word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One))))))))))))))))))))))
         in
        uint len0_word_length32
          (bitAND_word len0_word_length32 mask_disp_imm22 w));;

let rec get_cond
  w = (let mask_cond =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1
  (Bit1 One)))))))))))))))))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_cond w)
            (nat_of_num (Bit1 (Bit0 (Bit0 (Bit1 One)))))));;

let rec get_op2
  w = (let mask_op2 =
         word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit1 (Bit1 One)))))))))))))))))))))))))
         in
        uint len0_word_length32
          (shiftr_word len0_word_length32
            (bitAND_word len0_word_length32 mask_op2 w)
            (nat_of_num (Bit0 (Bit1 (Bit1 (Bit0 One)))))));;

let rec parse_instr_f2
  w = (let op2 = get_op2 w in
        (if equal_inta op2
              (uint len0_word_length3
                (word_of_int len0_word_length3 (Pos (Bit0 (Bit0 One)))))
          then (let rd = get_rd w in
                let imm22 = get_disp_imm22 w in
                 (if equal_inta rd Zero_int && equal_inta imm22 Zero_int
                   then Inr (Nop_type NOP, [])
                   else Inr (Sethi_type SETHI,
                              [W22 (word_of_int len0_word_length22 imm22);
                                W5 (word_of_int len0_word_length5 rd)])))
          else (if equal_inta op2
                     (uint len0_word_length3
                       (word_of_int len0_word_length3 (Pos (Bit0 One))))
                 then (let cond = get_cond w in
                       let flaga =
                         Flag (word_of_int len0_word_length1 (get_a w)) in
                       let disp22 =
                         W22 (word_of_int len0_word_length22 (get_disp_imm22 w))
                         in
                        (if equal_inta cond
                              (uint len0_word_length4
                                (one_word len0_word_length4))
                          then Inr (Bicc_type BE, [flaga; disp22])
                          else (if equal_inta cond
                                     (uint len0_word_length4
                                       (word_of_int len0_word_length4
 (Pos (Bit1 (Bit0 (Bit0 One))))))
                                 then Inr (Bicc_type BNE, [flaga; disp22])
                                 else (if equal_inta cond
    (uint len0_word_length4
      (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 (Bit1 One))))))
then Inr (Bicc_type BGU, [flaga; disp22])
else (if equal_inta cond
           (uint len0_word_length4
             (word_of_int len0_word_length4 (Pos (Bit0 One))))
       then Inr (Bicc_type BLE, [flaga; disp22])
       else (if equal_inta cond
                  (uint len0_word_length4
                    (word_of_int len0_word_length4 (Pos (Bit1 One))))
              then Inr (Bicc_type BL, [flaga; disp22])
              else (if equal_inta cond
                         (uint len0_word_length4
                           (word_of_int len0_word_length4
                             (Pos (Bit1 (Bit1 (Bit0 One))))))
                     then Inr (Bicc_type BGE, [flaga; disp22])
                     else (if equal_inta cond
                                (uint len0_word_length4
                                  (word_of_int len0_word_length4
                                    (Pos (Bit0 (Bit1 One)))))
                            then Inr (Bicc_type BNEG, [flaga; disp22])
                            else (if equal_inta cond
                                       (uint len0_word_length4
 (word_of_int len0_word_length4 (Pos (Bit0 (Bit1 (Bit0 One))))))
                                   then Inr (Bicc_type BG, [flaga; disp22])
                                   else (if equal_inta cond
      (uint len0_word_length4
        (word_of_int len0_word_length4 (Pos (Bit1 (Bit0 One)))))
  then Inr (Bicc_type BCS, [flaga; disp22])
  else (if equal_inta cond
             (uint len0_word_length4
               (word_of_int len0_word_length4 (Pos (Bit0 (Bit0 One)))))
         then Inr (Bicc_type BLEU, [flaga; disp22])
         else (if equal_inta cond
                    (uint len0_word_length4
                      (word_of_int len0_word_length4
                        (Pos (Bit1 (Bit0 (Bit1 One))))))
                then Inr (Bicc_type BCC, [flaga; disp22])
                else (if equal_inta cond
                           (uint len0_word_length4
                             (word_of_int len0_word_length4
                               (Pos (Bit0 (Bit0 (Bit0 One))))))
                       then Inr (Bicc_type BA, [flaga; disp22])
                       else (if equal_inta cond
                                  (uint len0_word_length4
                                    (zero_word len0_word_length4))
                              then Inr (Bicc_type BN, [flaga; disp22])
                              else (if equal_inta cond
 (uint len0_word_length4
   (word_of_int len0_word_length4 (Pos (Bit0 (Bit1 (Bit1 One))))))
                                     then Inr (Bicc_type BPOS, [flaga; disp22])
                                     else (if equal_inta cond
        (uint len0_word_length4
          (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One))))))
    then Inr (Bicc_type BVC, [flaga; disp22])
    else (if equal_inta cond
               (uint len0_word_length4
                 (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 One)))))
           then Inr (Bicc_type BVS, [flaga; disp22])
           else Inl [Invalid_cond_f2])))))))))))))))))
                 else Inl [Invalid_op2_f2])));;

let rec get_disp30
  w = (let mask_disp30 =
         word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 One))))))))))))))))))))))))))))))
         in
        uint len0_word_length32
          (bitAND_word len0_word_length32 mask_disp30 w));;

let rec parse_instr_f1
  w = Inr (Call_type CALL,
            [W30 (word_of_int len0_word_length30 (get_disp30 w))]);;

let rec decode_instruction
  w = (let this_op = get_op w in
        (if equal_inta this_op
              (uint len0_word_length2 (one_word len0_word_length2))
          then parse_instr_f1 w
          else (if equal_inta this_op
                     (uint len0_word_length2 (zero_word len0_word_length2))
                 then parse_instr_f2 w else parse_instr_f3 w)));;

let rec illegal_instruction_ASR r = false;;

let rec get_operand_w5 (W5 r) = r;;

let rec bitXOR_int
  x = (fun xa y ->
        bitOR_int (bitAND_int xa (bitNOT_int y)) (bitAND_int (bitNOT_int xa) y))
        x;;

let rec bitXOR_word _A
  a b = word_of_int _A (bitXOR_int (uint _A a) (uint _A b));;

let rec get_operand_simm13 (Simm13 r) = r;;

let rec get_operand_flag (Flag r) = r;;

let rec user_reg_val
  window ur state =
    (if equal_worda len0_word_length5 ur (zero_word len0_word_length5)
      then zero_word len0_word_length32 else user_reg state window ur);;

let rec get_operand2 _A
  op_list s =
    (let flagi = get_operand_flag (nth op_list Zero_nat) in
     let curr_win = ucast len0_word_length5 _A (get_CWP (cpu_reg_val PSR s)) in
      (if equal_worda len0_word_length1 flagi (zero_word len0_word_length1)
        then (let rs2 = get_operand_w5 (nth op_list (nat_of_num (Bit0 One))) in
              let rs2_val = user_reg_val curr_win rs2 s in
               rs2_val)
        else (let ext_simm13 =
                sign_ext13
                  (get_operand_simm13 (nth op_list (nat_of_num (Bit0 One))))
                in
               ext_simm13)));;

let rec get_curr_win _A
  uu = bind (gets (fun s ->
                    ucast len0_word_length5 _A (get_CWP (cpu_reg_val PSR s))))
         return;;

let rec update_PSR_et_pil
  et pil psr_val =
    (let tmp0 =
       bitAND_word len0_word_length32 psr_val
         (word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit0 (Bit1 (Bit1 (Bit0 (Bit0 (Bit0 (Bit0
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One))))))))))))))))))))))))))))))))))
       in
     let tmp1 =
       bitOR_word len0_word_length32 tmp0
         (shiftl_word len0_word_length32
           (ucast len0_word_length1 len0_word_length32 et)
           (nat_of_num (Bit1 (Bit0 One))))
       in
     let tmp2 =
       bitOR_word len0_word_length32 tmp1
         (shiftl_word len0_word_length32
           (ucast len0_word_length4 len0_word_length32 pil)
           (nat_of_num (Bit0 (Bit0 (Bit0 One)))))
       in
      tmp2);;

let rec dwrite_update
  dwritea
    (Sparc_state_ext
      (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
        undef, more))
    = Sparc_state_ext
        (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwritea dwrite, state_var,
          traps, undef, more);;

let rec dwrite
  (Sparc_state_ext
    (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
      undef, more))
    = dwrite;;

let rec get_delayed_pool state = dwrite state;;

let rec delayed_pool_add
  dw s =
    (let (i, (v, cr)) = dw in
      (if equal_inta i Zero_int then cpu_reg_mod v cr s
        else (let curr_pool = get_delayed_pool s in
               dwrite_update (fun _ -> curr_pool @ [dw]) s)));;

let rec privileged_ASR r = false;;

let rec write_state_reg_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let rs1 = get_operand_w5 (nth op_list one_nat) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (get_curr_win _A ())
        (fun curr_win ->
          bind (gets (cpu_reg_val PSR))
            (fun psr_val ->
              bind (gets (fun _ -> get_S psr_val))
                (fun s_val ->
                  bind (gets (get_operand2 _A op_list))
                    (fun op2 ->
                      bind (gets (user_reg_val curr_win rs1))
                        (fun rs1_val ->
                          bind (gets (fun _ ->
                                       bitXOR_word len0_word_length32 rs1_val
 op2))
                            (fun result ->
                              (if equal_sparc_operationa instr_name
                                    (Sreg_type WRY)
                                then bind (modify
    (delayed_pool_add (delaynum, (result, Y))))
                                       (k_bind (return ()))
                                else (if equal_sparc_operationa instr_name
   (Sreg_type WRASR)
                                       then (if privileged_ASR rd &&
          equal_worda len0_word_length1 s_val (zero_word len0_word_length1)
      then bind (raise_trap Privileged_instruction) (k_bind (return ()))
      else (if illegal_instruction_ASR rd
             then bind (raise_trap Illegal_instruction) (k_bind (return ()))
             else bind (modify (delayed_pool_add (delaynum, (result, ASR rd))))
                    (k_bind (return ()))))
                                       else (if equal_sparc_operationa
          instr_name (Sreg_type WRPSR)
      then (if equal_worda len0_word_length1 s_val (zero_word len0_word_length1)
             then bind (raise_trap Privileged_instruction) (k_bind (return ()))
             else (if less_eq_int nwindows
                        (uint len0_word_length5
                          (ucast len0_word_length32 len0_word_length5 result))
                    then bind (raise_trap Illegal_instruction)
                           (k_bind (return ()))
                    else bind (gets (fun _ -> get_PIL result))
                           (fun pil_val ->
                             bind (gets (fun _ -> get_ET result))
                               (fun et_val ->
                                 bind (gets
(fun _ -> update_PSR_et_pil et_val pil_val psr_val))
                                   (fun new_psr_val ->
                                     bind (write_cpu new_psr_val PSR)
                                       (k_bind
 (bind (modify (delayed_pool_add (delaynum, (result, PSR))))
   (k_bind (return ())))))))))
      else (if equal_sparc_operationa instr_name (Sreg_type WRWIM)
             then (if equal_worda len0_word_length1 s_val
                        (zero_word len0_word_length1)
                    then bind (raise_trap Privileged_instruction)
                           (k_bind (return ()))
                    else bind (gets (fun _ ->
                                      shiftr_word len0_word_length32
(shiftl_word len0_word_length32 result
  (nat (minus_int (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))) nwindows)))
(nat (minus_int (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))) nwindows))))
                           (fun result_f ->
                             bind (modify
                                    (delayed_pool_add
                                      (delaynum, (result_f, WIM))))
                               (k_bind (return ()))))
             else (if equal_worda len0_word_length1 s_val
                        (zero_word len0_word_length1)
                    then bind (raise_trap Privileged_instruction)
                           (k_bind (return ()))
                    else bind (gets (cpu_reg_val TBR))
                           (fun tbr_val ->
                             bind (gets (fun _ ->
  bitAND_word len0_word_length32 tbr_val
    (word_of_int len0_word_length32
      (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
   (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))
                               (fun tbr_val_11_0 ->
                                 bind (gets
(fun _ ->
  bitAND_word len0_word_length32 result
    (word_of_int len0_word_length32
      (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit1
 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
     (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
   (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))))
                                   (fun result_tmp ->
                                     bind (gets
    (fun _ -> bitOR_word len0_word_length32 tbr_val_11_0 result_tmp))
                                       (fun result_f ->
 bind (modify (delayed_pool_add (delaynum, (result_f, TBR))))
   (k_bind (return ()))))))))))))))))));;

let rec read_state_reg_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let rs1 = get_operand_w5 (nth op_list Zero_nat) in
     let rd = get_operand_w5 (nth op_list one_nat) in
      bind (get_curr_win _A ())
        (fun curr_win ->
          bind (gets (cpu_reg_val PSR))
            (fun psr_val ->
              bind (gets (fun _ -> get_S psr_val))
                (fun s_val ->
                  (if (member equal_sparc_operation instr_name
                         (insert equal_sparc_operation (Sreg_type RDPSR)
                           (insert equal_sparc_operation (Sreg_type RDWIM)
                             (insert equal_sparc_operation (Sreg_type RDTBR)
                               bot_set))) ||
                        equal_sparc_operationa instr_name (Sreg_type RDASR) &&
                          privileged_ASR rs1) &&
                        equal_worda len0_word_length1
                          (ucast len0_word_length1 len0_word_length1 s_val)
                          (zero_word len0_word_length1)
                    then bind (raise_trap Privileged_instruction)
                           (k_bind (return ()))
                    else (if illegal_instruction_ASR rs1
                           then bind (raise_trap Illegal_instruction)
                                  (k_bind (return ()))
                           else (if not (equal_worda len0_word_length5 rd
  (zero_word len0_word_length5))
                                  then (if equal_sparc_operationa instr_name
     (Sreg_type RDY)
 then bind (gets (cpu_reg_val Y))
        (fun y_val ->
          bind (write_reg _A y_val curr_win rd) (k_bind (return ())))
 else (if equal_sparc_operationa instr_name (Sreg_type RDASR)
        then bind (gets (cpu_reg_val (ASR rs1)))
               (fun asr_val ->
                 bind (write_reg _A asr_val curr_win rd) (k_bind (return ())))
        else (if equal_sparc_operationa instr_name (Sreg_type RDPSR)
               then bind (write_reg _A psr_val curr_win rd) (k_bind (return ()))
               else (if equal_sparc_operationa instr_name (Sreg_type RDWIM)
                      then bind (gets (cpu_reg_val WIM))
                             (fun wim_val ->
                               bind (write_reg _A wim_val curr_win rd)
                                 (k_bind (return ())))
                      else bind (gets (cpu_reg_val TBR))
                             (fun tbr_val ->
                               bind (write_reg _A tbr_val curr_win rd)
                                 (k_bind (return ())))))))
                                  else return ())))))));;

let rec save_retore_sub1 _A
  result new_cwp rd =
    bind (gets (cpu_reg_val PSR))
      (fun psr_val ->
        bind (gets (fun _ -> update_CWP new_cwp psr_val))
          (fun new_psr_val ->
            bind (write_cpu new_psr_val PSR)
              (k_bind
                (bind (write_reg _A result (ucast len0_word_length5 _A new_cwp)
                        rd)
                  (k_bind (return ()))))));;

let rec get_addr _A
  op_list s =
    (let rs1 = get_operand_w5 (nth op_list one_nat) in
     let curr_win = ucast len0_word_length5 _A (get_CWP (cpu_reg_val PSR s)) in
     let rs1_val = user_reg_val curr_win rs1 s in
     let a = get_operand2 _A op_list s in
      plus_word len0_word_length32 rs1_val a);;

let rec save_restore_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (gets (cpu_reg_val PSR))
        (fun _ ->
          bind (get_curr_win _A ())
            (fun curr_win ->
              bind (gets (cpu_reg_val WIM))
                (fun wim_val ->
                  (if equal_sparc_operationa instr_name (Ctrl_type SAVE)
                    then bind (gets (fun _ ->
                                      word_of_int len0_word_length5
(modulo_int (minus_int (uint _A curr_win) one_inta) nwindows)))
                           (fun new_cwp ->
                             (if not (equal_worda len0_word_length1
                                       (get_WIM_bit
 (unat len0_word_length5 new_cwp) wim_val)
                                       (zero_word len0_word_length1))
                               then bind (raise_trap Window_overflow)
                                      (k_bind (return ()))
                               else bind (gets (get_addr _A op_list))
                                      (fun result ->
save_retore_sub1 _A result new_cwp rd)))
                    else bind (gets (fun _ ->
                                      word_of_int len0_word_length5
(modulo_int (plus_inta (uint _A curr_win) one_inta) nwindows)))
                           (fun new_cwp ->
                             (if not (equal_worda len0_word_length1
                                       (get_WIM_bit
 (unat len0_word_length5 new_cwp) wim_val)
                                       (zero_word len0_word_length1))
                               then bind (raise_trap Window_underflow)
                                      (k_bind (return ()))
                               else bind (gets (get_addr _A op_list))
                                      (fun result ->
save_retore_sub1 _A result new_cwp rd))))))));;

let rec st_bar_update
  st_bara
    (Sparc_state_var_ext
      (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
        atm_ldst_word, more))
    = Sparc_state_var_ext
        (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bara st_bar,
          atm_ldst_byte, atm_ldst_word, more);;

let rec write_store_barrier_pending b v = st_bar_update (fun _ -> b) v;;

let rec store_barrier_pending_mod
  w s = state_var_update (fun _ -> write_store_barrier_pending w (state_var s))
          s;;

let rec mmu_update
  mmua (Sparc_state_ext
         (cpu_reg, user_reg, sys_reg, mem, mmu, cache, dwrite, state_var, traps,
           undef, more))
    = Sparc_state_ext
        (cpu_reg, user_reg, sys_reg, mem, mmua mmu, cache, dwrite, state_var,
          traps, undef, more);;

let rec flush_cache_all
  state =
    cache_update
      (fun _ ->
        dcache_update (fun _ -> empty_cache)
          (icache_update (fun _ -> empty_cache) (cache state)))
      state;;

let rec store_word_mem
  state va wd byte_mask asi =
    (match virt_to_phys va (mmu state) (mem state) with None -> None
      | Some pair ->
        (if mmu_writable (get_acc_flag (snd pair)) asi
          then Some (mem_mod_w32 asi (fst pair) byte_mask wd state)
          else None));;

let rec memory_write_asi
  asi addr byte_mask data_w32 state =
    (let asi_int = uint len0_word_length8 asi in
     let psr_val = cpu_reg_val PSR state in
     let _ = get_S psr_val in
      (if equal_inta asi_int one_inta
        then store_word_mem state addr data_w32 byte_mask
               (word_of_int len0_word_length8 (Pos (Bit0 (Bit1 (Bit0 One)))))
        else (if equal_inta asi_int (Pos (Bit0 One))
               then (if equal_inta (uint len0_word_length32 addr) Zero_int
                      then (let s1 = sys_reg_mod data_w32 CCR state in
                             Some (ccr_flush s1))
                      else (if equal_inta (uint len0_word_length32 addr)
                                 (Pos (Bit0 (Bit0 (Bit0 One))))
                             then Some (sys_reg_mod data_w32 ICCR state)
                             else (if equal_inta (uint len0_word_length32 addr)
(Pos (Bit0 (Bit0 (Bit1 One))))
                                    then Some (sys_reg_mod data_w32 DCCR state)
                                    else None)))
               else (if member equal_int asi_int
                          (insert equal_int (Pos (Bit0 (Bit0 (Bit0 One))))
                            (insert equal_int (Pos (Bit1 (Bit0 (Bit0 One))))
                              bot_set))
                      then (let ns =
                              add_instr_cache state addr data_w32 byte_mask in
                             store_word_mem ns addr data_w32 byte_mask asi)
                      else (if member equal_int asi_int
                                 (insert equal_int
                                   (Pos (Bit0 (Bit1 (Bit0 One))))
                                   (insert equal_int
                                     (Pos (Bit1 (Bit1 (Bit0 One)))) bot_set))
                             then (let ns =
                                     add_data_cache state addr data_w32
                                       byte_mask
                                     in
                                    store_word_mem ns addr data_w32 byte_mask
                                      asi)
                             else (if equal_inta asi_int
(Pos (Bit1 (Bit0 (Bit1 One))))
                                    then Some (add_instr_cache state addr
        data_w32 (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One))))))
                                    else (if equal_inta asi_int
       (Pos (Bit1 (Bit1 (Bit1 One))))
   then Some (add_data_cache state addr data_w32
               (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One))))))
   else (if equal_inta asi_int (Pos (Bit0 (Bit0 (Bit0 (Bit0 One)))))
          then Some (flush_instr_cache state)
          else (if equal_inta asi_int (Pos (Bit1 (Bit0 (Bit0 (Bit0 One)))))
                 then Some (flush_data_cache state)
                 else (if member equal_int asi_int
                            (insert equal_int
                              (Pos (Bit0 (Bit0 (Bit1 (Bit0 One)))))
                              (insert equal_int
                                (Pos (Bit1 (Bit0 (Bit1 (Bit0 One))))) bot_set))
                        then None
                        else (if equal_inta asi_int
                                   (Pos (Bit0 (Bit0 (Bit0 (Bit1 One)))))
                               then Some (flush_cache_all state)
                               else (if equal_inta asi_int
  (Pos (Bit1 (Bit0 (Bit0 (Bit1 One)))))
                                      then (match
     mmu_reg_mod (mmu state) addr data_w32 with None -> None
     | Some mmus -> Some (mmu_update (fun _ -> mmus) state))
                                      else (if equal_inta asi_int
         (Pos (Bit0 (Bit0 (Bit1 (Bit1 One)))))
     then Some (mem_mod_w32 asi
                 (ucast len0_word_length32 len0_word_length36 addr) byte_mask
                 data_w32 state)
     else (if equal_inta asi_int (Pos (Bit1 (Bit0 (Bit1 (Bit1 One))))) then None
            else None))))))))))))));;

let rec memory_write
  asi addr byte_mask data_w32 state =
    (match memory_write_asi asi addr byte_mask data_w32 state with None -> None
      | Some s1 -> Some (store_barrier_pending_mod false s1));;

let rec comp_swap_sub2 _A
  address asi rs2 rd curr_win word0 =
    bind (gets (memory_read asi
                 (plus_word len0_word_length32 address
                   (word_of_int len0_word_length32 (Pos (Bit0 (Bit0 One)))))))
      (fun (result1, new_state1) ->
        (if is_none result1
          then bind (raise_trap Data_access_exception) (k_bind (return ()))
          else bind (gets (fun _ -> (let Some v = result1 in v)))
                 (fun word1 ->
                   bind (modify (fun _ -> new_state1))
                     (k_bind
                       (bind (gets (user_reg_val curr_win
                                     (bitAND_word len0_word_length5 rs2
                                       (word_of_int len0_word_length5
 (Pos (Bit0 (Bit1 (Bit1 (Bit1 One)))))))))
                         (fun rs2_val0 ->
                           bind (gets (user_reg_val curr_win
(bitOR_word len0_word_length5 rs2 (one_word len0_word_length5))))
                             (fun rs2_val1 ->
                               bind (gets (user_reg_val curr_win
    (bitAND_word len0_word_length5 rd
      (word_of_int len0_word_length5 (Pos (Bit0 (Bit1 (Bit1 (Bit1 One)))))))))
                                 (fun rd_val0 ->
                                   bind (gets
  (user_reg_val curr_win
    (bitOR_word len0_word_length5 rd (one_word len0_word_length5))))
                                     (fun rd_val1 ->
                                       (if equal_worda len0_word_length32 word0
     rs2_val0 &&
     equal_worda len0_word_length32 word1 rs2_val1
 then bind (gets (fun _ ->
                   word_of_int len0_word_length4
                     (Pos (Bit1 (Bit1 (Bit1 One))))))
        (fun byte_mask ->
          bind (gets (memory_write asi address byte_mask rd_val0))
            (fun result0 ->
              (if is_none result0
                then bind (raise_trap Data_access_exception)
                       (k_bind (return ()))
                else bind (gets (fun _ -> (let Some v = result0 in v)))
                       (fun new_state0 ->
                         bind (modify (fun _ -> new_state0))
                           (k_bind
                             (bind (gets (memory_write asi
   (plus_word len0_word_length32 address
     (word_of_int len0_word_length32 (Pos (Bit0 (Bit0 One)))))
   byte_mask rd_val1))
                               (fun result1a ->
                                 (if is_none result1a
                                   then bind (raise_trap Data_access_exception)
  (k_bind (return ()))
                                   else bind
  (gets (fun _ -> (let Some v = result1a in v)))
  (fun new_state1a ->
    bind (modify (fun _ -> new_state1a))
      (k_bind
        (bind (write_reg _A word1 curr_win
                (bitOR_word len0_word_length5 rd (one_word len0_word_length5)))
          (k_bind
            (if not (equal_worda len0_word_length5 rd
                      (zero_word len0_word_length5))
              then bind (write_reg _A word0 curr_win
                          (bitAND_word len0_word_length5 rd
                            (word_of_int len0_word_length5
                              (Pos (Bit0 (Bit1 (Bit1 (Bit1 One))))))))
                     (k_bind (return ()))
              else return ())))))))))))))
 else bind (write_reg _A word1 curr_win
             (bitOR_word len0_word_length5 rd (one_word len0_word_length5)))
        (k_bind
          (if not (equal_worda len0_word_length5 rd
                    (zero_word len0_word_length5))
            then bind (write_reg _A word0 curr_win
                        (bitAND_word len0_word_length5 rd
                          (word_of_int len0_word_length5
                            (Pos (Bit0 (Bit1 (Bit1 (Bit1 One))))))))
                   (k_bind (return ()))
            else return ()))))))))))));;

let rec comp_swap_sub1 _A
  instr rs1 rs2 rd s_val asi =
    bind (get_curr_win _A ())
      (fun curr_win ->
        bind (gets (user_reg_val curr_win rs1))
          (fun address ->
            (if equal_sparc_operationa (fst instr) (Load_store_type CASXA) &&
                  not (equal_worda len0_word_length3
                        (ucast len0_word_length32 len0_word_length3 address)
                        (zero_word len0_word_length3)) ||
                  equal_sparc_operationa (fst instr) (Load_store_type CASA) &&
                    not (equal_worda len0_word_length2
                          (ucast len0_word_length32 len0_word_length2 address)
                          (zero_word len0_word_length2))
              then bind (raise_trap Mem_address_not_aligned)
                     (k_bind (return ()))
              else bind (gets (memory_read asi address))
                     (fun (result, new_state) ->
                       (if is_none result
                         then bind (raise_trap Data_access_exception)
                                (k_bind (return ()))
                         else bind (gets (fun _ -> (let Some v = result in v)))
                                (fun word ->
                                  bind (modify (fun _ -> new_state))
                                    (k_bind
                                      (bind (gets (user_reg_val curr_win rs2))
(fun rs2_val ->
  bind (gets (user_reg_val curr_win rd))
    (fun rd_val ->
      (if equal_sparc_operationa (fst instr) (Load_store_type CASA)
        then (if equal_worda len0_word_length32 word rs2_val
               then bind (gets (fun _ ->
                                 word_of_int len0_word_length4
                                   (Pos (Bit1 (Bit1 (Bit1 One))))))
                      (fun byte_mask ->
                        bind (gets (memory_write asi address byte_mask rd_val))
                          (fun result0 ->
                            (if is_none result0
                              then bind (raise_trap Data_access_exception)
                                     (k_bind (return ()))
                              else bind (gets
  (fun _ -> (let Some v = result0 in v)))
                                     (fun new_state1 ->
                                       bind (modify (fun _ -> new_state1))
 (k_bind
   (if not (equal_worda len0_word_length5 rd (zero_word len0_word_length5))
     then bind (write_reg _A word curr_win rd) (k_bind (return ()))
     else return ()))))))
               else (if not (equal_worda len0_word_length5 rd
                              (zero_word len0_word_length5))
                      then bind (write_reg _A word curr_win rd)
                             (k_bind (return ()))
                      else return ()))
        else comp_swap_sub2 _A address asi rs2 rd curr_win word)))))))))));;

let rec get_operand_asi (Asi r) = r;;

let rec ldst_asi
  instr s_val =
    (if member equal_sparc_operation (fst instr)
          (insert equal_sparc_operation (Load_store_type LDSTUB) bot_set)
      then (if equal_worda len0_word_length1 s_val (zero_word len0_word_length1)
             then word_of_int len0_word_length8 (Pos (Bit0 (Bit1 (Bit0 One))))
             else word_of_int len0_word_length8 (Pos (Bit1 (Bit1 (Bit0 One)))))
      else get_operand_asi (nth (snd instr) (nat_of_num (Bit1 One))));;

let rec comp_swap_instr _A
  instr =
    (let _ = fst instr in
     let op_list = snd instr in
     let flagi = get_operand_flag (nth op_list Zero_nat) in
     let rs1 = get_operand_w5 (nth (snd instr) one_nat) in
     let rs2 = get_operand_w5 (nth (snd instr) (nat_of_num (Bit0 One))) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit0 (Bit0 One)))) in
      bind (gets (cpu_reg_val PSR))
        (fun psr_val ->
          bind (gets (fun _ -> get_S psr_val))
            (fun s_val ->
              bind (gets (fun _ -> ldst_asi instr s_val))
                (fun asi ->
                  (if not (equal_worda len0_word_length8 asi
                            (word_of_int len0_word_length8
                              (Pos (Bit0 (Bit1 (Bit0 One)))))) &&
                        equal_worda len0_word_length1 s_val
                          (zero_word len0_word_length1)
                    then bind (raise_trap Privileged_instruction)
                           (k_bind (return ()))
                    else (if equal_worda len0_word_length1 flagi
                               (one_word len0_word_length1)
                           then bind (raise_trap Illegal_instruction)
                                  (k_bind (return ()))
                           else comp_swap_sub1 _A instr rs1 rs2 rd s_val
                                  asi))))));;

let rec update_PSR_icc
  n_val z_val v_val c_val psr_val =
    (let n_val_32 =
       (if equal_worda len0_word_length1 n_val (zero_word len0_word_length1)
         then zero_word len0_word_length32
         else word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))))))))))))))))
       in
     let z_val_32 =
       (if equal_worda len0_word_length1 z_val (zero_word len0_word_length1)
         then zero_word len0_word_length32
         else word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 (Bit0 One))))))))))))))))))))))))
       in
     let v_val_32 =
       (if equal_worda len0_word_length1 v_val (zero_word len0_word_length1)
         then zero_word len0_word_length32
         else word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 One)))))))))))))))))))))))
       in
     let c_val_32 =
       (if equal_worda len0_word_length1 c_val (zero_word len0_word_length1)
         then zero_word len0_word_length32
         else word_of_int len0_word_length32
                (Pos (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))))))))))))))))
       in
     let tmp0 =
       bitAND_word len0_word_length32 psr_val
         (word_of_int len0_word_length32
           (Pos (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
       in
     let tmp1 = bitOR_word len0_word_length32 tmp0 n_val_32 in
     let tmp2 = bitOR_word len0_word_length32 tmp1 z_val_32 in
     let tmp3 = bitOR_word len0_word_length32 tmp2 v_val_32 in
     let tmp4 = bitOR_word len0_word_length32 tmp3 c_val_32 in
      tmp4);;

let rec logical_new_psr_val
  result s =
    (let psr_val = cpu_reg_val PSR s in
     let n_val =
       ucast len0_word_length32 len0_word_length1
         (shiftr_word len0_word_length32 result
           (nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))
       in
     let z_val =
       (if equal_worda len0_word_length32 result (zero_word len0_word_length32)
         then one_word len0_word_length1 else zero_word len0_word_length1)
       in
     let v_val = zero_word len0_word_length1 in
     let c_val = zero_word len0_word_length1 in
      update_PSR_icc n_val z_val v_val c_val psr_val);;

let rec logical_instr_sub1 _A
  instr_name result =
    (if member equal_sparc_operation instr_name
          (insert equal_sparc_operation (Logic_type ANDcc)
            (insert equal_sparc_operation (Logic_type ANDNcc)
              (insert equal_sparc_operation (Logic_type ORcc)
                (insert equal_sparc_operation (Logic_type ORNcc)
                  (insert equal_sparc_operation (Logic_type XORcc)
                    (insert equal_sparc_operation (Logic_type XNORcc)
                      bot_set))))))
      then bind (gets (logical_new_psr_val result))
             (fun new_psr_val ->
               bind (write_cpu new_psr_val PSR) (k_bind (return ())))
      else return ());;

let rec bitNOT_word _A a = word_of_int _A (bitNOT_int (uint _A a));;

let rec logical_result
  instr_name rs1_val operand2 =
    (if equal_sparc_operationa instr_name (Logic_type ANDs) ||
          equal_sparc_operationa instr_name (Logic_type ANDcc)
      then bitAND_word len0_word_length32 rs1_val operand2
      else (if equal_sparc_operationa instr_name (Logic_type ANDN) ||
                 equal_sparc_operationa instr_name (Logic_type ANDNcc)
             then bitAND_word len0_word_length32 rs1_val
                    (bitNOT_word len0_word_length32 operand2)
             else (if equal_sparc_operationa instr_name (Logic_type ORs) ||
                        equal_sparc_operationa instr_name (Logic_type ORcc)
                    then bitOR_word len0_word_length32 rs1_val operand2
                    else (if member equal_sparc_operation instr_name
                               (insert equal_sparc_operation (Logic_type ORN)
                                 (insert equal_sparc_operation
                                   (Logic_type ORNcc) bot_set))
                           then bitOR_word len0_word_length32 rs1_val
                                  (bitNOT_word len0_word_length32 operand2)
                           else (if member equal_sparc_operation instr_name
                                      (insert equal_sparc_operation
(Logic_type XORs) (insert equal_sparc_operation (Logic_type XORcc) bot_set))
                                  then bitXOR_word len0_word_length32 rs1_val
 operand2
                                  else bitXOR_word len0_word_length32 rs1_val
 (bitNOT_word len0_word_length32 operand2))))));;

let rec logical_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let rs1 = get_operand_w5 (nth op_list one_nat) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (gets (get_operand2 _A op_list))
        (fun operand2 ->
          bind (get_curr_win _A ())
            (fun curr_win ->
              bind (gets (user_reg_val curr_win rs1))
                (fun rs1_val ->
                  bind (gets (user_reg_val curr_win rd))
                    (fun rd_val ->
                      bind (gets (fun _ ->
                                   logical_result instr_name rs1_val operand2))
                        (fun result ->
                          bind (gets (fun _ ->
                                       (if not
     (equal_worda len0_word_length5 rd (zero_word len0_word_length5))
 then result else rd_val)))
                            (fun new_rd_val ->
                              bind (write_reg _A new_rd_val curr_win rd)
                                (k_bind
                                  (logical_instr_sub1 _A instr_name
                                    result)))))))));;

let rec eval_icc
  instr_name n_val z_val v_val c_val =
    (if equal_sparc_operationa instr_name (Bicc_type BNE)
      then (if equal_worda len0_word_length1 z_val (zero_word len0_word_length1)
             then one_inta else Zero_int)
      else (if equal_sparc_operationa instr_name (Bicc_type BE)
             then (if equal_worda len0_word_length1 z_val
                        (one_word len0_word_length1)
                    then one_inta else Zero_int)
             else (if equal_sparc_operationa instr_name (Bicc_type BG)
                    then (if equal_worda len0_word_length1
                               (bitOR_word len0_word_length1 z_val
                                 (bitXOR_word len0_word_length1 n_val v_val))
                               (zero_word len0_word_length1)
                           then one_inta else Zero_int)
                    else (if equal_sparc_operationa instr_name (Bicc_type BLE)
                           then (if equal_worda len0_word_length1
                                      (bitOR_word len0_word_length1 z_val
(bitXOR_word len0_word_length1 n_val v_val))
                                      (one_word len0_word_length1)
                                  then one_inta else Zero_int)
                           else (if equal_sparc_operationa instr_name
                                      (Bicc_type BGE)
                                  then (if equal_worda len0_word_length1
     (bitXOR_word len0_word_length1 n_val v_val) (zero_word len0_word_length1)
 then one_inta else Zero_int)
                                  else (if equal_sparc_operationa instr_name
     (Bicc_type BL)
 then (if equal_worda len0_word_length1
            (bitXOR_word len0_word_length1 n_val v_val)
            (one_word len0_word_length1)
        then one_inta else Zero_int)
 else (if equal_sparc_operationa instr_name (Bicc_type BGU)
        then (if equal_worda len0_word_length1 c_val
                   (zero_word len0_word_length1) &&
                   equal_worda len0_word_length1 z_val
                     (zero_word len0_word_length1)
               then one_inta else Zero_int)
        else (if equal_sparc_operationa instr_name (Bicc_type BLEU)
               then (if equal_worda len0_word_length1 c_val
                          (one_word len0_word_length1) ||
                          equal_worda len0_word_length1 z_val
                            (one_word len0_word_length1)
                      then one_inta else Zero_int)
               else (if equal_sparc_operationa instr_name (Bicc_type BCC)
                      then (if equal_worda len0_word_length1 c_val
                                 (zero_word len0_word_length1)
                             then one_inta else Zero_int)
                      else (if equal_sparc_operationa instr_name (Bicc_type BCS)
                             then (if equal_worda len0_word_length1 c_val
(one_word len0_word_length1)
                                    then one_inta else Zero_int)
                             else (if equal_sparc_operationa instr_name
(Bicc_type BNEG)
                                    then (if equal_worda len0_word_length1 n_val
       (one_word len0_word_length1)
   then one_inta else Zero_int)
                                    else (if equal_sparc_operationa instr_name
       (Bicc_type BA)
   then one_inta
   else (if equal_sparc_operationa instr_name (Bicc_type BN) then Zero_int
          else (if equal_sparc_operationa instr_name (Bicc_type BPOS)
                 then (if equal_worda len0_word_length1 n_val
                            (zero_word len0_word_length1)
                        then one_inta else Zero_int)
                 else (if equal_sparc_operationa instr_name (Bicc_type BVC)
                        then (if equal_worda len0_word_length1 v_val
                                   (zero_word len0_word_length1)
                               then one_inta else Zero_int)
                        else (if equal_sparc_operationa instr_name
                                   (Bicc_type BVS)
                               then (if equal_worda len0_word_length1 v_val
  (one_word len0_word_length1)
                                      then one_inta else Zero_int)
                               else uminus_int one_inta))))))))))))))));;

let rec branch_instr_sub1
  instr_name s =
    (let n_val = get_icc_N (cpu_reg s PSR) in
     let z_val = get_icc_Z (cpu_reg s PSR) in
     let v_val = get_icc_V (cpu_reg s PSR) in
     let a = get_icc_C (cpu_reg s PSR) in
      eval_icc instr_name n_val z_val v_val a);;

let rec get_operand_w22 (W22 r) = r;;

let rec branch_instr
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let disp22 = get_operand_w22 (nth op_list one_nat) in
     let flaga = get_operand_flag (nth op_list Zero_nat) in
      bind (gets (branch_instr_sub1 instr_name))
        (fun icc_val ->
          bind (gets (cpu_reg_val NPC))
            (fun npc_val ->
              bind (gets (cpu_reg_val PC))
                (fun pc_val ->
                  bind (write_cpu npc_val PC)
                    (k_bind
                      (if equal_inta icc_val one_inta
                        then bind (write_cpu
                                    (plus_word len0_word_length32 pc_val
                                      (sign_ext24
(shiftl_word len0_word_length24
  (ucast len0_word_length22 len0_word_length24 disp22)
  (nat_of_num (Bit0 One)))))
                                    NPC)
                               (k_bind
                                 (if equal_sparc_operationa instr_name
                                       (Bicc_type BA) &&
                                       equal_worda len0_word_length1 flaga
 (one_word len0_word_length1)
                                   then bind (set_annul true)
  (k_bind (return ()))
                                   else return ()))
                        else bind (write_cpu
                                    (plus_word len0_word_length32 npc_val
                                      (word_of_int len0_word_length32
(Pos (Bit0 (Bit0 One)))))
                                    NPC)
                               (k_bind
                                 (if equal_worda len0_word_length1 flaga
                                       (one_word len0_word_length1)
                                   then bind (set_annul true)
  (k_bind (return ()))
                                   else return ()))))))));;

let rec st_byte_mask
  instr address =
    (if member equal_sparc_operation (fst instr)
          (insert equal_sparc_operation (Load_store_type STD)
            (insert equal_sparc_operation (Load_store_type ST)
              (insert equal_sparc_operation (Load_store_type STA)
                (insert equal_sparc_operation (Load_store_type STDA) bot_set))))
      then word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One))))
      else (if member equal_sparc_operation (fst instr)
                 (insert equal_sparc_operation (Load_store_type STH)
                   (insert equal_sparc_operation (Load_store_type STHA)
                     bot_set))
             then (if equal_worda len0_word_length2
                        (ucast len0_word_length32 len0_word_length2 address)
                        (zero_word len0_word_length2)
                    then word_of_int len0_word_length4
                           (Pos (Bit0 (Bit0 (Bit1 One))))
                    else word_of_int len0_word_length4 (Pos (Bit1 One)))
             else (if equal_worda len0_word_length2
                        (ucast len0_word_length32 len0_word_length2 address)
                        (zero_word len0_word_length2)
                    then word_of_int len0_word_length4
                           (Pos (Bit0 (Bit0 (Bit0 One))))
                    else (if equal_worda len0_word_length2
                               (ucast len0_word_length32 len0_word_length2
                                 address)
                               (one_word len0_word_length2)
                           then word_of_int len0_word_length4
                                  (Pos (Bit0 (Bit0 One)))
                           else (if equal_worda len0_word_length2
                                      (ucast len0_word_length32
len0_word_length2 address)
                                      (word_of_int len0_word_length2
(Pos (Bit0 One)))
                                  then word_of_int len0_word_length4
 (Pos (Bit0 One))
                                  else one_word len0_word_length4)))));;

let rec st_data0 _A
  instr curr_win rd address s =
    (if member equal_sparc_operation (fst instr)
          (insert equal_sparc_operation (Load_store_type STD)
            (insert equal_sparc_operation (Load_store_type STDA) bot_set))
      then user_reg_val curr_win
             (bitAND_word len0_word_length5 rd
               (word_of_int len0_word_length5
                 (Pos (Bit0 (Bit1 (Bit1 (Bit1 One)))))))
             s
      else (if member equal_sparc_operation (fst instr)
                 (insert equal_sparc_operation (Load_store_type ST)
                   (insert equal_sparc_operation (Load_store_type STA) bot_set))
             then user_reg_val curr_win rd s
             else (if member equal_sparc_operation (fst instr)
                        (insert equal_sparc_operation (Load_store_type STH)
                          (insert equal_sparc_operation (Load_store_type STHA)
                            bot_set))
                    then (if equal_worda len0_word_length2
                               (ucast len0_word_length32 len0_word_length2
                                 address)
                               (zero_word len0_word_length2)
                           then shiftl_word len0_word_length32
                                  (user_reg_val curr_win rd s)
                                  (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One)))))
                           else user_reg_val curr_win rd s)
                    else (if equal_worda len0_word_length2
                               (ucast len0_word_length32 len0_word_length2
                                 address)
                               (zero_word len0_word_length2)
                           then shiftl_word len0_word_length32
                                  (user_reg_val curr_win rd s)
                                  (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One)))))
                           else (if equal_worda len0_word_length2
                                      (ucast len0_word_length32
len0_word_length2 address)
                                      (one_word len0_word_length2)
                                  then shiftl_word len0_word_length32
 (user_reg_val curr_win rd s) (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One)))))
                                  else (if equal_worda len0_word_length2
     (ucast len0_word_length32 len0_word_length2 address)
     (word_of_int len0_word_length2 (Pos (Bit0 One)))
 then shiftl_word len0_word_length32 (user_reg_val curr_win rd s)
        (nat_of_num (Bit0 (Bit0 (Bit0 One))))
 else user_reg_val curr_win rd s))))));;

let rec store_sub2 _A
  instr curr_win rd asi address =
    bind (gets (fun _ -> st_byte_mask instr address))
      (fun byte_mask ->
        bind (gets (st_data0 _A instr curr_win rd address))
          (fun data0 ->
            bind (gets (memory_write asi address byte_mask data0))
              (fun result0 ->
                (if is_none result0
                  then bind (raise_trap Data_access_exception)
                         (k_bind (return ()))
                  else bind (gets (fun _ -> (let Some v = result0 in v)))
                         (fun new_state ->
                           bind (modify (fun _ -> new_state))
                             (k_bind
                               (if member equal_sparc_operation (fst instr)
                                     (insert equal_sparc_operation
                                       (Load_store_type STD)
                                       (insert equal_sparc_operation
 (Load_store_type STDA) bot_set))
                                 then bind
(gets (user_reg_val curr_win
        (bitOR_word len0_word_length5 rd (one_word len0_word_length5))))
(fun data1 ->
  bind (gets (memory_write asi
               (plus_word len0_word_length32 address
                 (word_of_int len0_word_length32 (Pos (Bit0 (Bit0 One)))))
               (word_of_int len0_word_length4 (Pos (Bit1 (Bit1 (Bit1 One)))))
               data1))
    (fun result1 ->
      (if is_none result1
        then bind (raise_trap Data_access_exception) (k_bind (return ()))
        else bind (gets (fun _ -> (let Some v = result1 in v)))
               (fun new_state1 ->
                 bind (modify (fun _ -> new_state1)) (k_bind (return ()))))))
                                 else return ())))))));;

let rec st_asi
  instr s_val =
    (if member equal_sparc_operation (fst instr)
          (insert equal_sparc_operation (Load_store_type STD)
            (insert equal_sparc_operation (Load_store_type ST)
              (insert equal_sparc_operation (Load_store_type STH)
                (insert equal_sparc_operation (Load_store_type STB) bot_set))))
      then (if equal_worda len0_word_length1 s_val (zero_word len0_word_length1)
             then word_of_int len0_word_length8 (Pos (Bit0 (Bit1 (Bit0 One))))
             else word_of_int len0_word_length8 (Pos (Bit1 (Bit1 (Bit0 One)))))
      else get_operand_asi (nth (snd instr) (nat_of_num (Bit1 One))));;

let rec store_sub1 _A
  instr rd s_val =
    bind (get_curr_win _A ())
      (fun curr_win ->
        bind (gets (get_addr _A (snd instr)))
          (fun address ->
            bind (gets (fun _ -> st_asi instr s_val))
              (fun asi ->
                (if (equal_sparc_operationa (fst instr) (Load_store_type STH) ||
                      equal_sparc_operationa (fst instr)
                        (Load_store_type STHA)) &&
                      not (equal_worda len0_word_length1
                            (ucast len0_word_length32 len0_word_length1 address)
                            (zero_word len0_word_length1))
                  then bind (raise_trap Mem_address_not_aligned)
                         (k_bind (return ()))
                  else (if member equal_sparc_operation (fst instr)
                             (insert equal_sparc_operation (Load_store_type ST)
                               (insert equal_sparc_operation
                                 (Load_store_type STA) bot_set)) &&
                             not (equal_worda len0_word_length2
                                   (ucast len0_word_length32 len0_word_length2
                                     address)
                                   (zero_word len0_word_length2))
                         then bind (raise_trap Mem_address_not_aligned)
                                (k_bind (return ()))
                         else (if member equal_sparc_operation (fst instr)
                                    (insert equal_sparc_operation
                                      (Load_store_type STD)
                                      (insert equal_sparc_operation
(Load_store_type STDA) bot_set)) &&
                                    not (equal_worda len0_word_length3
  (ucast len0_word_length32 len0_word_length3 address)
  (zero_word len0_word_length3))
                                then bind (raise_trap Mem_address_not_aligned)
                                       (k_bind (return ()))
                                else store_sub2 _A instr curr_win rd asi
                                       address))))));;

let rec store_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let flagi = get_operand_flag (nth op_list Zero_nat) in
     let rd =
       (if member equal_sparc_operation instr_name
             (insert equal_sparc_operation (Load_store_type STA)
               (insert equal_sparc_operation (Load_store_type STBA)
                 (insert equal_sparc_operation (Load_store_type STHA)
                   (insert equal_sparc_operation (Load_store_type STDA)
                     bot_set))))
         then get_operand_w5 (nth op_list (nat_of_num (Bit0 (Bit0 One))))
         else get_operand_w5 (nth op_list (nat_of_num (Bit1 One))))
       in
      bind (gets (cpu_reg_val PSR))
        (fun psr_val ->
          bind (gets (fun _ -> get_S psr_val))
            (fun s_val ->
              (if member equal_sparc_operation instr_name
                    (insert equal_sparc_operation (Load_store_type STA)
                      (insert equal_sparc_operation (Load_store_type STDA)
                        (insert equal_sparc_operation (Load_store_type STHA)
                          (insert equal_sparc_operation (Load_store_type STBA)
                            bot_set)))) &&
                    equal_worda len0_word_length1 s_val
                      (zero_word len0_word_length1)
                then bind (raise_trap Privileged_instruction)
                       (k_bind (return ()))
                else (if member equal_sparc_operation instr_name
                           (insert equal_sparc_operation (Load_store_type STA)
                             (insert equal_sparc_operation
                               (Load_store_type STDA)
                               (insert equal_sparc_operation
                                 (Load_store_type STHA)
                                 (insert equal_sparc_operation
                                   (Load_store_type STBA) bot_set)))) &&
                           equal_worda len0_word_length1 flagi
                             (one_word len0_word_length1)
                       then bind (raise_trap Illegal_instruction)
                              (k_bind (return ()))
                       else store_sub1 _A instr rd s_val)))));;

let rec shift_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let flagi = get_operand_flag (nth op_list Zero_nat) in
     let rs1 = get_operand_w5 (nth op_list one_nat) in
     let rs2_shcnt = get_operand_w5 (nth op_list (nat_of_num (Bit0 One))) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (get_curr_win _A ())
        (fun curr_win ->
          bind (gets (fun s ->
                       (if equal_worda len0_word_length1 flagi
                             (zero_word len0_word_length1)
                         then ucast len0_word_length32 len0_word_length5
                                (user_reg_val curr_win rs2_shcnt s)
                         else rs2_shcnt)))
            (fun shift_count ->
              bind (gets (user_reg_val curr_win rs1))
                (fun rs1_val ->
                  (if equal_sparc_operationa instr_name (Shift_type SLL) &&
                        not (equal_worda len0_word_length5 rd
                              (zero_word len0_word_length5))
                    then bind (gets (fun _ ->
                                      shiftl_word len0_word_length32 rs1_val
(unat len0_word_length5 shift_count)))
                           (fun rd_val ->
                             bind (write_reg _A rd_val curr_win rd)
                               (k_bind (return ())))
                    else (if equal_sparc_operationa instr_name
                               (Shift_type SRL) &&
                               not (equal_worda len0_word_length5 rd
                                     (zero_word len0_word_length5))
                           then bind (gets (fun _ ->
     shiftr_word len0_word_length32 rs1_val
       (unat len0_word_length5 shift_count)))
                                  (fun rd_val ->
                                    bind (write_reg _A rd_val curr_win rd)
                                      (k_bind (return ())))
                           else (if equal_sparc_operationa instr_name
                                      (Shift_type SRA) &&
                                      not
(equal_worda len0_word_length5 rd (zero_word len0_word_length5))
                                  then bind
 (gets (fun _ ->
         sshiftr len_word_length32 rs1_val
           (unat len0_word_length5 shift_count)))
 (fun rd_val -> bind (write_reg _A rd_val curr_win rd) (k_bind (return ())))
                                  else return ())))))));;

let rec sethi_instr _A
  instr =
    (let op_list = snd instr in
     let imm22 = get_operand_w22 (nth op_list Zero_nat) in
     let rd = get_operand_w5 (nth op_list one_nat) in
      (if not (equal_worda len0_word_length5 rd (zero_word len0_word_length5))
        then bind (get_curr_win _A ())
               (fun curr_win ->
                 bind (write_reg _A
                        (shiftl_word len0_word_length32
                          (ucast len0_word_length22 len0_word_length32 imm22)
                          (nat_of_num (Bit0 (Bit1 (Bit0 One)))))
                        curr_win rd)
                   (k_bind (return ())))
        else return ()));;

let rec flush_instr _A
  instr =
    (let op_list = snd instr in
      bind (gets (get_addr _A op_list))
        (fun _ -> bind (modify flush_cache_all) (k_bind (return ()))));;

let rec update_PSR_rett
  cwp_val et_val s_val psr_val =
    (let tmp0 =
       bitAND_word len0_word_length32 psr_val
         (word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit1 (Bit0 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
       in
     let tmp1 =
       bitOR_word len0_word_length32 tmp0
         (ucast len0_word_length5 len0_word_length32 cwp_val)
       in
     let tmp2 =
       bitOR_word len0_word_length32 tmp1
         (shiftl_word len0_word_length32
           (ucast len0_word_length1 len0_word_length32 et_val)
           (nat_of_num (Bit1 (Bit0 One))))
       in
     let tmp3 =
       bitOR_word len0_word_length32 tmp2
         (shiftl_word len0_word_length32
           (ucast len0_word_length1 len0_word_length32 s_val)
           (nat_of_num (Bit1 (Bit1 One))))
       in
      tmp3);;

let rec write_cpu_tt
  w = bind (gets (cpu_reg_val TBR))
        (fun tbr_val ->
          bind (gets (fun _ -> write_tt w tbr_val))
            (fun new_tbr_val ->
              bind (write_cpu new_tbr_val TBR) (k_bind (return ()))));;

let rec exe_update
  exea (Sparc_state_var_ext
         (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar,
           atm_ldst_byte, atm_ldst_word, more))
    = Sparc_state_var_ext
        (annul, resett, exea exe, reset, err, ticc, itrpt_lvl, st_bar,
          atm_ldst_byte, atm_ldst_word, more);;

let rec write_exe_mode b v = exe_update (fun _ -> b) v;;

let rec exe_mode_mod
  b s = state_var_update (fun _ -> write_exe_mode b (state_var s)) s;;

let rec set_exe_mode b = bind (modify (exe_mode_mod b)) (k_bind (return ()));;

let rec err_update
  erra (Sparc_state_var_ext
         (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar,
           atm_ldst_byte, atm_ldst_word, more))
    = Sparc_state_var_ext
        (annul, resett, exe, reset, erra err, ticc, itrpt_lvl, st_bar,
          atm_ldst_byte, atm_ldst_word, more);;

let rec write_err_mode b v = err_update (fun _ -> b) v;;

let rec err_mode_mod
  b s = state_var_update (fun _ -> write_err_mode b (state_var s)) s;;

let rec set_err_mode b = bind (modify (err_mode_mod b)) (k_bind (return ()));;

let rec rett_instr _A
  instr =
    (let op_list = snd instr in
      bind (gets (cpu_reg_val PSR))
        (fun psr_val ->
          bind (gets (fun s -> get_CWP (cpu_reg_val PSR s)))
            (fun curr_win ->
              bind (gets (fun _ ->
                           word_of_int len0_word_length5
                             (modulo_int
                               (plus_inta (uint len0_word_length5 curr_win)
                                 one_inta)
                               nwindows)))
                (fun new_cwp ->
                  bind (gets (fun _ ->
                               modulo_int
                                 (plus_inta (uint len0_word_length5 curr_win)
                                   one_inta)
                                 nwindows))
                    (fun new_cwp_int ->
                      bind (gets (get_addr _A op_list))
                        (fun addr ->
                          bind (gets (fun _ ->
                                       ucast len0_word_length1 len0_word_length1
 (get_ET psr_val)))
                            (fun et_val ->
                              bind (gets (fun _ ->
   ucast len0_word_length1 len0_word_length1 (get_S psr_val)))
                                (fun s_val ->
                                  bind (gets
 (fun _ -> ucast len0_word_length1 len0_word_length1 (get_PS psr_val)))
                                    (fun ps_val ->
                                      bind (gets (cpu_reg_val WIM))
(fun wim_val ->
  bind (gets (cpu_reg_val NPC))
    (fun npc_val ->
      (if equal_worda len0_word_length1 et_val (one_word len0_word_length1)
        then (if equal_worda len0_word_length1 s_val
                   (zero_word len0_word_length1)
               then bind (raise_trap Privileged_instruction)
                      (k_bind (return ()))
               else bind (raise_trap Illegal_instruction) (k_bind (return ())))
        else (if equal_worda len0_word_length1 s_val
                   (zero_word len0_word_length1)
               then bind (write_cpu_tt
                           (word_of_int len0_word_length8 (Pos (Bit1 One))))
                      (k_bind
                        (bind (set_exe_mode false)
                          (k_bind
                            (bind (set_err_mode true)
                              (k_bind
                                (bind (raise_trap Privileged_instruction)
                                  (k_bind (fail ()))))))))
               else (if not (equal_worda len0_word_length1
                              (get_WIM_bit (nat new_cwp_int) wim_val)
                              (zero_word len0_word_length1))
                      then bind (write_cpu_tt
                                  (word_of_int len0_word_length8
                                    (Pos (Bit0 (Bit1 One)))))
                             (k_bind
                               (bind (set_exe_mode false)
                                 (k_bind
                                   (bind (set_err_mode true)
                                     (k_bind
                                       (bind (raise_trap Window_underflow)
 (k_bind (fail ()))))))))
                      else (if not (equal_worda len0_word_length32
                                     (bitAND_word len0_word_length32 addr
                                       (word_of_int len0_word_length32
 (Pos (Bit1 One))))
                                     (zero_word len0_word_length32))
                             then bind (write_cpu_tt
 (word_of_int len0_word_length8 (Pos (Bit1 (Bit1 One)))))
                                    (k_bind
                                      (bind (set_exe_mode false)
(k_bind
  (bind (set_err_mode true)
    (k_bind (bind (raise_trap Mem_address_not_aligned) (k_bind (fail ()))))))))
                             else bind (write_cpu npc_val PC)
                                    (k_bind
                                      (bind (write_cpu addr NPC)
(k_bind
  (bind (gets (fun _ ->
                update_PSR_rett new_cwp (one_word len0_word_length1) ps_val
                  psr_val))
    (fun new_psr_val ->
      bind (write_cpu new_psr_val PSR)
        (k_bind (return ()))))))))))))))))))))));;

let rec load_sub2 _A
  address asi rd curr_win word0 =
    bind (write_reg _A word0 curr_win
           (bitAND_word len0_word_length5 rd
             (word_of_int len0_word_length5
               (Pos (Bit0 (Bit1 (Bit1 (Bit1 One))))))))
      (k_bind
        (bind (gets (memory_read asi
                      (plus_word len0_word_length32 address
                        (word_of_int len0_word_length32
                          (Pos (Bit0 (Bit0 One)))))))
          (fun (result1, new_state1) ->
            (if is_none result1
              then bind (raise_trap Data_access_exception) (k_bind (return ()))
              else bind (gets (fun _ -> (let Some v = result1 in v)))
                     (fun word1 ->
                       bind (modify (fun _ -> new_state1))
                         (k_bind
                           (bind (write_reg _A word1 curr_win
                                   (bitOR_word len0_word_length5 rd
                                     (one_word len0_word_length5)))
                             (k_bind (return ())))))))));;

let rec ld_word0
  instr data_word address =
    (if member equal_sparc_operation (fst instr)
          (insert equal_sparc_operation (Load_store_type LDSB)
            (insert equal_sparc_operation (Load_store_type LDUB)
              (insert equal_sparc_operation (Load_store_type LDUBA)
                (insert equal_sparc_operation (Load_store_type LDSBA)
                  bot_set))))
      then (let byte =
              (if equal_inta
                    (uint len0_word_length2
                      (ucast len0_word_length32 len0_word_length2 address))
                    Zero_int
                then ucast len0_word_length32 len0_word_length8
                       (shiftr_word len0_word_length32 data_word
                         (nat_of_num (Bit0 (Bit0 (Bit0 (Bit1 One))))))
                else (if equal_inta
                           (uint len0_word_length2
                             (ucast len0_word_length32 len0_word_length2
                               address))
                           one_inta
                       then ucast len0_word_length32 len0_word_length8
                              (shiftr_word len0_word_length32 data_word
                                (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One))))))
                       else (if equal_inta
                                  (uint len0_word_length2
                                    (ucast len0_word_length32 len0_word_length2
                                      address))
                                  (Pos (Bit0 One))
                              then ucast len0_word_length32 len0_word_length8
                                     (shiftr_word len0_word_length32 data_word
                                       (nat_of_num (Bit0 (Bit0 (Bit0 One)))))
                              else ucast len0_word_length32 len0_word_length8
                                     data_word)))
              in
             (if equal_sparc_operationa (fst instr) (Load_store_type LDSB) ||
                   equal_sparc_operationa (fst instr) (Load_store_type LDSBA)
               then sign_ext8 byte else zero_ext8 byte))
      else (if equal_sparc_operationa (fst instr) (Load_store_type LDUH) ||
                 (equal_sparc_operationa (fst instr) (Load_store_type LDSH) ||
                   (equal_sparc_operationa (fst instr)
                      (Load_store_type LDSHA) ||
                     equal_sparc_operationa (fst instr)
                       (Load_store_type LDUHA)))
             then (let halfword =
                     (if equal_inta
                           (uint len0_word_length2
                             (ucast len0_word_length32 len0_word_length2
                               address))
                           Zero_int
                       then ucast len0_word_length32 len0_word_length16
                              (shiftr_word len0_word_length32 data_word
                                (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 One))))))
                       else ucast len0_word_length32 len0_word_length16
                              data_word)
                     in
                    (if equal_sparc_operationa (fst instr)
                          (Load_store_type LDSH) ||
                          equal_sparc_operationa (fst instr)
                            (Load_store_type LDSHA)
                      then sign_ext16 halfword else zero_ext16 halfword))
             else data_word));;

let rec load_sub3 _A
  instr curr_win rd asi address =
    bind (gets (memory_read asi address))
      (fun (result, new_state) ->
        (if is_none result
          then bind (raise_trap Data_access_exception) (k_bind (return ()))
          else bind (gets (fun _ -> (let Some v = result in v)))
                 (fun data_word ->
                   bind (modify (fun _ -> new_state))
                     (k_bind
                       (bind (gets (fun _ -> ld_word0 instr data_word address))
                         (fun word0 ->
                           (if not (equal_worda len0_word_length5 rd
                                     (zero_word len0_word_length5)) &&
                                 member equal_sparc_operation (fst instr)
                                   (insert equal_sparc_operation
                                     (Load_store_type LD)
                                     (insert equal_sparc_operation
                                       (Load_store_type LDA)
                                       (insert equal_sparc_operation
 (Load_store_type LDUH)
 (insert equal_sparc_operation (Load_store_type LDSB)
   (insert equal_sparc_operation (Load_store_type LDUB)
     (insert equal_sparc_operation (Load_store_type LDUBA)
       (insert equal_sparc_operation (Load_store_type LDSH)
         (insert equal_sparc_operation (Load_store_type LDSHA)
           (insert equal_sparc_operation (Load_store_type LDUHA)
             (insert equal_sparc_operation (Load_store_type LDSBA)
               bot_set))))))))))
                             then bind (write_reg _A word0 curr_win rd)
                                    (k_bind (return ()))
                             else load_sub2 _A address asi rd curr_win
                                    word0)))))));;

let rec ld_asi
  instr s_val =
    (if member equal_sparc_operation (fst instr)
          (insert equal_sparc_operation (Load_store_type LDD)
            (insert equal_sparc_operation (Load_store_type LD)
              (insert equal_sparc_operation (Load_store_type LDUH)
                (insert equal_sparc_operation (Load_store_type LDSB)
                  (insert equal_sparc_operation (Load_store_type LDUB)
                    (insert equal_sparc_operation (Load_store_type LDSH)
                      bot_set))))))
      then (if equal_worda len0_word_length1 s_val (zero_word len0_word_length1)
             then word_of_int len0_word_length8 (Pos (Bit0 (Bit1 (Bit0 One))))
             else word_of_int len0_word_length8 (Pos (Bit1 (Bit1 (Bit0 One)))))
      else get_operand_asi (nth (snd instr) (nat_of_num (Bit1 One))));;

let rec load_sub1 _A
  instr rd s_val =
    bind (get_curr_win _A ())
      (fun curr_win ->
        bind (gets (get_addr _A (snd instr)))
          (fun address ->
            bind (gets (fun _ -> ld_asi instr s_val))
              (fun asi ->
                (if (equal_sparc_operationa (fst instr) (Load_store_type LDD) ||
                      equal_sparc_operationa (fst instr)
                        (Load_store_type LDDA)) &&
                      not (equal_worda len0_word_length3
                            (ucast len0_word_length32 len0_word_length3 address)
                            (zero_word len0_word_length3)) ||
                      (member equal_sparc_operation (fst instr)
                         (insert equal_sparc_operation (Load_store_type LD)
                           (insert equal_sparc_operation (Load_store_type LDA)
                             bot_set)) &&
                         not (equal_worda len0_word_length2
                               (ucast len0_word_length32 len0_word_length2
                                 address)
                               (zero_word len0_word_length2)) ||
                        (equal_sparc_operationa (fst instr)
                           (Load_store_type LDUH) ||
                          (equal_sparc_operationa (fst instr)
                             (Load_store_type LDUHA) ||
                            (equal_sparc_operationa (fst instr)
                               (Load_store_type LDSH) ||
                              equal_sparc_operationa (fst instr)
                                (Load_store_type LDSHA)))) &&
                          not (equal_worda len0_word_length1
                                (ucast len0_word_length32 len0_word_length1
                                  address)
                                (zero_word len0_word_length1)))
                  then bind (raise_trap Mem_address_not_aligned)
                         (k_bind (return ()))
                  else load_sub3 _A instr curr_win rd asi address))));;

let rec load_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let flagi = get_operand_flag (nth op_list Zero_nat) in
     let rd =
       (if member equal_sparc_operation instr_name
             (insert equal_sparc_operation (Load_store_type LDUBA)
               (insert equal_sparc_operation (Load_store_type LDA)
                 (insert equal_sparc_operation (Load_store_type LDSBA)
                   (insert equal_sparc_operation (Load_store_type LDSHA)
                     (insert equal_sparc_operation (Load_store_type LDSHA)
                       (insert equal_sparc_operation (Load_store_type LDDA)
                         bot_set))))))
         then get_operand_w5 (nth op_list (nat_of_num (Bit0 (Bit0 One))))
         else get_operand_w5 (nth op_list (nat_of_num (Bit1 One))))
       in
      bind (gets (cpu_reg_val PSR))
        (fun psr_val ->
          bind (gets (fun _ -> get_S psr_val))
            (fun s_val ->
              (if member equal_sparc_operation instr_name
                    (insert equal_sparc_operation (Load_store_type LDA)
                      (insert equal_sparc_operation (Load_store_type LDUBA)
                        (insert equal_sparc_operation (Load_store_type LDSBA)
                          (insert equal_sparc_operation (Load_store_type LDSHA)
                            (insert equal_sparc_operation
                              (Load_store_type LDUHA)
                              (insert equal_sparc_operation
                                (Load_store_type LDDA) bot_set)))))) &&
                    equal_worda len0_word_length1 s_val
                      (zero_word len0_word_length1)
                then bind (raise_trap Privileged_instruction)
                       (k_bind (return ()))
                else (if member equal_sparc_operation instr_name
                           (insert equal_sparc_operation (Load_store_type LDA)
                             (insert equal_sparc_operation
                               (Load_store_type LDUBA)
                               (insert equal_sparc_operation
                                 (Load_store_type LDSBA)
                                 (insert equal_sparc_operation
                                   (Load_store_type LDSHA)
                                   (insert equal_sparc_operation
                                     (Load_store_type LDUHA)
                                     (insert equal_sparc_operation
                                       (Load_store_type LDDA) bot_set)))))) &&
                           equal_worda len0_word_length1 flagi
                             (one_word len0_word_length1)
                       then bind (raise_trap Illegal_instruction)
                              (k_bind (return ()))
                       else load_sub1 _A instr rd s_val)))));;

let rec jmpl_instr _A
  instr =
    (let op_list = snd instr in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (get_curr_win _A ())
        (fun curr_win ->
          bind (gets (get_addr _A op_list))
            (fun jmp_addr ->
              (if not (equal_worda len0_word_length32
                        (bitAND_word len0_word_length32 jmp_addr
                          (word_of_int len0_word_length32 (Pos (Bit1 One))))
                        (zero_word len0_word_length32))
                then bind (raise_trap Mem_address_not_aligned)
                       (k_bind (return ()))
                else bind (gets (fun s ->
                                  (if not
(equal_worda len0_word_length5 rd (zero_word len0_word_length5))
                                    then cpu_reg_val PC s
                                    else user_reg_val curr_win rd s)))
                       (fun rd_next_val ->
                         bind (write_reg _A rd_next_val curr_win rd)
                           (k_bind
                             (bind (gets (cpu_reg_val NPC))
                               (fun npc_val ->
                                 bind (write_cpu npc_val PC)
                                   (k_bind
                                     (bind (write_cpu jmp_addr NPC)
                                       (k_bind (return ()))))))))))));;

let rec get_operand_w30 (W30 r) = r;;

let rec call_instr _A
  instr =
    (let op_list = snd instr in
     let mem_addr =
       shiftl_word len0_word_length32
         (ucast len0_word_length30 len0_word_length32
           (get_operand_w30 (nth op_list Zero_nat)))
         (nat_of_num (Bit0 One))
       in
      bind (get_curr_win _A ())
        (fun curr_win ->
          bind (gets (cpu_reg_val PC))
            (fun pc_val ->
              bind (gets (cpu_reg_val NPC))
                (fun npc_val ->
                  bind (write_reg _A pc_val curr_win
                         (word_of_int len0_word_length5
                           (Pos (Bit1 (Bit1 (Bit1 One))))))
                    (k_bind
                      (bind (write_cpu npc_val PC)
                        (k_bind
                          (bind (write_cpu
                                  (plus_word len0_word_length32 pc_val mem_addr)
                                  NPC)
                            (k_bind (return ()))))))))));;

let rec less_eq_set _A
  a b = match a, b with
    Coset xs, Set ys ->
      (if null xs && null ys then false
        else failwith
               "subset_eq (List.coset _) (List.set _) requires type class instance card_UNIV"
               (fun _ -> less_eq_set _A (Coset xs) (Set ys)))
    | a, Coset ys -> list_all (fun y -> not (member _A y a)) ys
    | Set xs, b -> list_all (fun x -> member _A x b) xs;;

let rec equal_set _A a b = less_eq_set _A a b && less_eq_set _A b a;;

let rec sub_instr_sub1 _A
  instr_name result rs1_val operand2 =
    (if member equal_sparc_operation instr_name
          (insert equal_sparc_operation (Arith_type SUBcc)
            (insert equal_sparc_operation (Arith_type SUBXcc) bot_set))
      then bind (gets (cpu_reg_val PSR))
             (fun psr_val ->
               bind (gets (fun _ ->
                            ucast len0_word_length32 len0_word_length1
                              (shiftr_word len0_word_length32 result
                                (nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                 (fun result_31 ->
                   bind (gets (fun _ ->
                                ucast len0_word_length32 len0_word_length1
                                  (shiftr_word len0_word_length32 rs1_val
                                    (nat_of_num
                                      (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                     (fun rs1_val_31 ->
                       bind (gets (fun _ ->
                                    ucast len0_word_length32 len0_word_length1
                                      (shiftr_word len0_word_length32 operand2
(nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                         (fun operand2_31 ->
                           bind (gets (fun _ -> result_31))
                             (fun new_n_val ->
                               bind (gets (fun _ ->
    (if equal_worda len0_word_length32 result (zero_word len0_word_length32)
      then one_word len0_word_length1 else zero_word len0_word_length1)))
                                 (fun new_z_val ->
                                   bind (gets
  (fun _ ->
    bitOR_word len0_word_length1
      (bitAND_word len0_word_length1 rs1_val_31
        (bitAND_word len0_word_length1
          (bitNOT_word len0_word_length1 operand2_31)
          (bitNOT_word len0_word_length1 result_31)))
      (bitAND_word len0_word_length1 (bitNOT_word len0_word_length1 rs1_val_31)
        (bitAND_word len0_word_length1 operand2_31 result_31))))
                                     (fun new_v_val ->
                                       bind
 (gets (fun _ ->
         bitOR_word len0_word_length1
           (bitAND_word len0_word_length1
             (bitNOT_word len0_word_length1 rs1_val_31) operand2_31)
           (bitAND_word len0_word_length1 result_31
             (bitOR_word len0_word_length1
               (bitNOT_word len0_word_length1 rs1_val_31) operand2_31))))
 (fun new_c_val ->
   bind (gets (fun _ ->
                update_PSR_icc new_n_val new_z_val new_v_val new_c_val psr_val))
     (fun new_psr_val ->
       bind (write_cpu new_psr_val PSR) (k_bind (return ())))))))))))
      else return ());;

let rec sub_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let rs1 = get_operand_w5 (nth op_list one_nat) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (gets (get_operand2 _A op_list))
        (fun operand2 ->
          bind (get_curr_win _A ())
            (fun curr_win ->
              bind (gets (user_reg_val curr_win rs1))
                (fun rs1_val ->
                  bind (gets (cpu_reg_val PSR))
                    (fun psr_val ->
                      bind (gets (fun _ -> get_icc_C psr_val))
                        (fun c_val ->
                          bind (gets (fun _ ->
                                       (if equal_sparc_operationa instr_name
     (Arith_type SUB) ||
     equal_sparc_operationa instr_name (Arith_type SUBcc)
 then minus_word len0_word_length32 rs1_val operand2
 else minus_word len0_word_length32
        (minus_word len0_word_length32 rs1_val operand2)
        (ucast len0_word_length1 len0_word_length32 c_val))))
                            (fun result ->
                              bind (gets (user_reg_val curr_win rd))
                                (fun rd_val ->
                                  bind (gets
 (fun _ ->
   (if not (equal_worda len0_word_length5 rd (zero_word len0_word_length5))
     then result else rd_val)))
                                    (fun new_rd_val ->
                                      bind (write_reg _A new_rd_val curr_win rd)
(k_bind (sub_instr_sub1 _A instr_name result rs1_val operand2)))))))))));;

let rec nop_instr instr = return ();;

let rec mul_instr_sub1 _A
  instr_name result =
    (if member equal_sparc_operation instr_name
          (insert equal_sparc_operation (Arith_type SMULcc)
            (insert equal_sparc_operation (Arith_type UMULcc) bot_set))
      then bind (gets (cpu_reg_val PSR))
             (fun psr_val ->
               bind (gets (fun _ ->
                            ucast len0_word_length32 len0_word_length1
                              (shiftr_word len0_word_length32 result
                                (nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                 (fun new_n_val ->
                   bind (gets (fun _ ->
                                (if equal_worda len0_word_length32 result
                                      (zero_word len0_word_length32)
                                  then one_word len0_word_length1
                                  else zero_word len0_word_length1)))
                     (fun new_z_val ->
                       bind (gets (fun _ -> zero_word len0_word_length1))
                         (fun new_v_val ->
                           bind (gets (fun _ -> zero_word len0_word_length1))
                             (fun new_c_val ->
                               bind (gets (fun _ ->
    update_PSR_icc new_n_val new_z_val new_v_val new_c_val psr_val))
                                 (fun new_psr_val ->
                                   bind (write_cpu new_psr_val PSR)
                                     (k_bind (return ()))))))))
      else return ());;

let rec mul_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let rs1 = get_operand_w5 (nth op_list one_nat) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (gets (get_operand2 _A op_list))
        (fun operand2 ->
          bind (get_curr_win _A ())
            (fun curr_win ->
              bind (gets (user_reg_val curr_win rs1))
                (fun rs1_val ->
                  bind (gets (cpu_reg_val PSR))
                    (fun _ ->
                      bind (gets (fun _ ->
                                   (if member equal_sparc_operation instr_name
 (insert equal_sparc_operation (Arith_type UMUL)
   (insert equal_sparc_operation (Arith_type UMULcc) bot_set))
                                     then word_of_int len0_word_length64
    (times_inta (uint len0_word_length32 rs1_val)
      (uint len0_word_length32 operand2))
                                     else word_of_int len0_word_length64
    (times_inta (sint len_word_length32 rs1_val)
      (sint len_word_length32 operand2)))))
                        (fun result0 ->
                          bind (gets (fun _ ->
                                       ucast len0_word_length64
 len0_word_length32
 (shiftr_word len0_word_length64 result0
   (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))
                            (fun y_val ->
                              bind (write_cpu y_val Y)
                                (k_bind
                                  (bind (gets
  (fun _ -> ucast len0_word_length64 len0_word_length32 result0))
                                    (fun result ->
                                      bind (gets (user_reg_val curr_win rd))
(fun rd_val ->
  bind (gets (fun _ ->
               (if not (equal_worda len0_word_length5 rd
                         (zero_word len0_word_length5))
                 then result else rd_val)))
    (fun new_rd_val ->
      bind (write_reg _A new_rd_val curr_win rd)
        (k_bind (mul_instr_sub1 _A instr_name result))))))))))))));;

let rec div_comp_temp_64bit
  i y_rs1 operand2 =
    (if equal_sparc_operationa (fst i) (Arith_type UDIV) ||
          equal_sparc_operationa (fst i) (Arith_type UDIVcc)
      then word_of_int len0_word_length64
             (divide_int (uint len0_word_length64 y_rs1)
               (uint len0_word_length32 operand2))
      else (let sop1 = sint len_word_length64 y_rs1 in
            let sop2 = sint len_word_length32 operand2 in
            let pop1 = abs_int sop1 in
            let pop2 = abs_int sop2 in
             (if less_int Zero_int sop1 && less_int Zero_int sop2
               then word_of_int len0_word_length64 (divide_int sop1 sop2)
               else (if less_int Zero_int sop1 && less_int sop2 Zero_int
                      then word_of_int len0_word_length64
                             (uminus_int (divide_int sop1 pop2))
                      else (if less_int sop1 Zero_int && less_int Zero_int sop2
                             then word_of_int len0_word_length64
                                    (uminus_int (divide_int pop1 sop2))
                             else word_of_int len0_word_length64
                                    (divide_int pop1 pop2))))));;

let rec div_write_new_val _A
  i result temp_V =
    (if member equal_sparc_operation (fst i)
          (insert equal_sparc_operation (Arith_type UDIVcc)
            (insert equal_sparc_operation (Arith_type SDIVcc) bot_set))
      then bind (gets (cpu_reg_val PSR))
             (fun psr_val ->
               bind (gets (fun _ ->
                            ucast len0_word_length32 len0_word_length1
                              (shiftr_word len0_word_length32 result
                                (nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                 (fun new_n_val ->
                   bind (gets (fun _ ->
                                (if equal_worda len0_word_length32 result
                                      (zero_word len0_word_length32)
                                  then one_word len0_word_length1
                                  else zero_word len0_word_length1)))
                     (fun new_z_val ->
                       bind (gets (fun _ -> temp_V))
                         (fun new_v_val ->
                           bind (gets (fun _ -> zero_word len0_word_length1))
                             (fun new_c_val ->
                               bind (gets (fun _ ->
    update_PSR_icc new_n_val new_z_val new_v_val new_c_val psr_val))
                                 (fun new_psr_val ->
                                   bind (write_cpu new_psr_val PSR)
                                     (k_bind (return ()))))))))
      else return ());;

let rec div_comp_temp_V
  i w32 w33 =
    (if equal_sparc_operationa (fst i) (Arith_type UDIV) ||
          equal_sparc_operationa (fst i) (Arith_type UDIVcc)
      then (if equal_worda len0_word_length32 w32 (zero_word len0_word_length32)
             then zero_word len0_word_length1 else one_word len0_word_length1)
      else (if equal_worda len0_word_length33 w33
                 (zero_word len0_word_length33) ||
                 equal_worda len0_word_length33 w33
                   (word_of_int len0_word_length33
                     (Pos (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One))))))))))))))))))))))))))))))))))
             then zero_word len0_word_length1
             else one_word len0_word_length1));;

let rec div_comp_result
  i temp_V temp_64bit =
    (if equal_worda len0_word_length1 temp_V (one_word len0_word_length1)
      then (if equal_sparc_operationa (fst i) (Arith_type UDIV) ||
                 equal_sparc_operationa (fst i) (Arith_type UDIVcc)
             then word_of_int len0_word_length32
                    (Pos (Bit1 (Bit1 (Bit1 (Bit1
     (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
   (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
     (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One))))))))))))))))))))))))))))))))
             else (if member equal_sparc_operation (fst i)
                        (insert equal_sparc_operation (Arith_type SDIV)
                          (insert equal_sparc_operation (Arith_type SDIVcc)
                            bot_set))
                    then (if less_word len0_word_length64
                               (zero_word len0_word_length64) temp_64bit
                           then word_of_int len0_word_length32
                                  (Pos (Bit1
 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
     (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
   (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))
                           else word_of_int len0_word_length32
                                  (minus_int Zero_int
                                    (uint len0_word_length32
                                      (word_of_int len0_word_length32
(Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
     (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
   (Bit0 (Bit0 One))))))))))))))))))))))))))))))))))))
                    else ucast len0_word_length64 len0_word_length32
                           temp_64bit))
      else ucast len0_word_length64 len0_word_length32 temp_64bit);;

let rec div_comp _A
  instr rs1 rd operand2 =
    bind (get_curr_win _A ())
      (fun curr_win ->
        bind (gets (user_reg_val curr_win rs1))
          (fun rs1_val ->
            bind (gets (cpu_reg_val Y))
              (fun y_val ->
                bind (gets (fun _ ->
                             word_cat len0_word_length32 len0_word_length32
                               len0_word_length64 y_val rs1_val))
                  (fun y_rs1 ->
                    bind (gets (fun _ ->
                                 div_comp_temp_64bit instr y_rs1 operand2))
                      (fun temp_64bit ->
                        bind (gets (fun _ ->
                                     ucast len0_word_length64 len0_word_length32
                                       (shiftr_word len0_word_length64
 temp_64bit (nat_of_num (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))
                          (fun temp_high32 ->
                            bind (gets (fun _ ->
 ucast len0_word_length64 len0_word_length33
   (shiftr_word len0_word_length64 temp_64bit
     (nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                              (fun temp_high33 ->
                                bind (gets (fun _ ->
     div_comp_temp_V instr temp_high32 temp_high33))
                                  (fun temp_V ->
                                    bind (gets
   (fun _ -> div_comp_result instr temp_V temp_64bit))
                                      (fun result ->
bind (gets (user_reg_val curr_win rd))
  (fun rd_val ->
    bind (gets (fun _ ->
                 (if not (equal_worda len0_word_length5 rd
                           (zero_word len0_word_length5))
                   then result else rd_val)))
      (fun new_rd_val ->
        bind (write_reg _A new_rd_val curr_win rd)
          (k_bind (div_write_new_val _A instr result temp_V)))))))))))));;

let rec div_instr _A
  instr =
    (let _ = fst instr in
     let op_list = snd instr in
     let rs1 = get_operand_w5 (nth op_list one_nat) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (gets (get_operand2 _A op_list))
        (fun operand2 ->
          (if equal_inta (uint len0_word_length32 operand2) Zero_int
            then bind (raise_trap Division_by_zero) (k_bind (return ()))
            else div_comp _A instr rs1 rd operand2)));;

let rec add_instr_sub1 _A
  instr_name result rs1_val operand2 =
    (if member equal_sparc_operation instr_name
          (insert equal_sparc_operation (Arith_type ADDcc)
            (insert equal_sparc_operation (Arith_type ADDXcc) bot_set))
      then bind (gets (cpu_reg_val PSR))
             (fun psr_val ->
               bind (gets (fun _ ->
                            ucast len0_word_length32 len0_word_length1
                              (shiftr_word len0_word_length32 result
                                (nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                 (fun result_31 ->
                   bind (gets (fun _ ->
                                ucast len0_word_length32 len0_word_length1
                                  (shiftr_word len0_word_length32 rs1_val
                                    (nat_of_num
                                      (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                     (fun rs1_val_31 ->
                       bind (gets (fun _ ->
                                    ucast len0_word_length32 len0_word_length1
                                      (shiftr_word len0_word_length32 operand2
(nat_of_num (Bit1 (Bit1 (Bit1 (Bit1 One))))))))
                         (fun operand2_31 ->
                           bind (gets (fun _ -> result_31))
                             (fun new_n_val ->
                               bind (gets (fun _ ->
    (if equal_worda len0_word_length32 result (zero_word len0_word_length32)
      then one_word len0_word_length1 else zero_word len0_word_length1)))
                                 (fun new_z_val ->
                                   bind (gets
  (fun _ ->
    bitOR_word len0_word_length1
      (bitAND_word len0_word_length1 rs1_val_31
        (bitAND_word len0_word_length1 operand2_31
          (bitNOT_word len0_word_length1 result_31)))
      (bitAND_word len0_word_length1 (bitNOT_word len0_word_length1 rs1_val_31)
        (bitAND_word len0_word_length1
          (bitNOT_word len0_word_length1 operand2_31) result_31))))
                                     (fun new_v_val ->
                                       bind
 (gets (fun _ ->
         bitOR_word len0_word_length1
           (bitAND_word len0_word_length1 rs1_val_31 operand2_31)
           (bitAND_word len0_word_length1
             (bitNOT_word len0_word_length1 result_31)
             (bitOR_word len0_word_length1 rs1_val_31 operand2_31))))
 (fun new_c_val ->
   bind (gets (fun _ ->
                update_PSR_icc new_n_val new_z_val new_v_val new_c_val psr_val))
     (fun new_psr_val ->
       bind (write_cpu new_psr_val PSR) (k_bind (return ())))))))))))
      else return ());;

let rec add_instr _A
  instr =
    (let instr_name = fst instr in
     let op_list = snd instr in
     let rs1 = get_operand_w5 (nth op_list one_nat) in
     let rd = get_operand_w5 (nth op_list (nat_of_num (Bit1 One))) in
      bind (gets (get_operand2 _A op_list))
        (fun operand2 ->
          bind (get_curr_win _A ())
            (fun curr_win ->
              bind (gets (user_reg_val curr_win rs1))
                (fun rs1_val ->
                  bind (gets (cpu_reg_val PSR))
                    (fun psr_val ->
                      bind (gets (fun _ -> get_icc_C psr_val))
                        (fun c_val ->
                          bind (gets (fun _ ->
                                       (if equal_sparc_operationa instr_name
     (Arith_type ADD) ||
     equal_sparc_operationa instr_name (Arith_type ADDcc)
 then plus_word len0_word_length32 rs1_val operand2
 else plus_word len0_word_length32
        (plus_word len0_word_length32 rs1_val operand2)
        (ucast len0_word_length1 len0_word_length32 c_val))))
                            (fun result ->
                              bind (gets (user_reg_val curr_win rd))
                                (fun rd_val ->
                                  bind (gets
 (fun _ ->
   (if not (equal_worda len0_word_length5 rd (zero_word len0_word_length5))
     then result else rd_val)))
                                    (fun new_rd_val ->
                                      bind (write_reg _A new_rd_val curr_win rd)
(k_bind (add_instr_sub1 _A instr_name result rs1_val operand2)))))))))));;

let rec get_trap_set state = traps state;;

let rec dispatch_instruction _A
  instr =
    (let instr_name = fst instr in
      bind (gets get_trap_set)
        (fun traps ->
          (if equal_set equal_Trap traps bot_set
            then (if member equal_sparc_operation instr_name
                       (insert equal_sparc_operation (Load_store_type LDSB)
                         (insert equal_sparc_operation (Load_store_type LDUB)
                           (insert equal_sparc_operation (Load_store_type LDUBA)
                             (insert equal_sparc_operation
                               (Load_store_type LDUH)
                               (insert equal_sparc_operation
                                 (Load_store_type LD)
                                 (insert equal_sparc_operation
                                   (Load_store_type LDA)
                                   (insert equal_sparc_operation
                                     (Load_store_type LDD) bot_set)))))))
                   then load_instr _A instr
                   else (if member equal_sparc_operation instr_name
                              (insert equal_sparc_operation
                                (Load_store_type STB)
                                (insert equal_sparc_operation
                                  (Load_store_type STH)
                                  (insert equal_sparc_operation
                                    (Load_store_type ST)
                                    (insert equal_sparc_operation
                                      (Load_store_type STA)
                                      (insert equal_sparc_operation
(Load_store_type STD) bot_set)))))
                          then store_instr _A instr
                          else (if member equal_sparc_operation instr_name
                                     (insert equal_sparc_operation
                                       (Sethi_type SETHI) bot_set)
                                 then sethi_instr _A instr
                                 else (if member equal_sparc_operation
    instr_name (insert equal_sparc_operation (Nop_type NOP) bot_set)
then nop_instr instr
else (if member equal_sparc_operation instr_name
           (insert equal_sparc_operation (Logic_type ANDs)
             (insert equal_sparc_operation (Logic_type ANDcc)
               (insert equal_sparc_operation (Logic_type ANDN)
                 (insert equal_sparc_operation (Logic_type ANDNcc)
                   (insert equal_sparc_operation (Logic_type ORs)
                     (insert equal_sparc_operation (Logic_type ORcc)
                       (insert equal_sparc_operation (Logic_type ORN)
                         (insert equal_sparc_operation (Logic_type XORs)
                           (insert equal_sparc_operation (Logic_type XNOR)
                             bot_set)))))))))
       then logical_instr _A instr
       else (if member equal_sparc_operation instr_name
                  (insert equal_sparc_operation (Shift_type SLL)
                    (insert equal_sparc_operation (Shift_type SRL)
                      (insert equal_sparc_operation (Shift_type SRA) bot_set)))
              then shift_instr _A instr
              else (if member equal_sparc_operation instr_name
                         (insert equal_sparc_operation (Arith_type ADD)
                           (insert equal_sparc_operation (Arith_type ADDcc)
                             (insert equal_sparc_operation (Arith_type ADDX)
                               bot_set)))
                     then add_instr _A instr
                     else (if member equal_sparc_operation instr_name
                                (insert equal_sparc_operation (Arith_type SUB)
                                  (insert equal_sparc_operation
                                    (Arith_type SUBcc)
                                    (insert equal_sparc_operation
                                      (Arith_type SUBX) bot_set)))
                            then sub_instr _A instr
                            else (if member equal_sparc_operation instr_name
                                       (insert equal_sparc_operation
 (Arith_type UMUL)
 (insert equal_sparc_operation (Arith_type SMUL)
   (insert equal_sparc_operation (Arith_type SMULcc) bot_set)))
                                   then mul_instr _A instr
                                   else (if member equal_sparc_operation
      instr_name
      (insert equal_sparc_operation (Arith_type UDIV)
        (insert equal_sparc_operation (Arith_type UDIVcc)
          (insert equal_sparc_operation (Arith_type SDIV) bot_set)))
  then div_instr _A instr
  else (if member equal_sparc_operation instr_name
             (insert equal_sparc_operation (Ctrl_type SAVE)
               (insert equal_sparc_operation (Ctrl_type RESTORE) bot_set))
         then save_restore_instr _A instr
         else (if member equal_sparc_operation instr_name
                    (insert equal_sparc_operation (Call_type CALL) bot_set)
                then call_instr _A instr
                else (if member equal_sparc_operation instr_name
                           (insert equal_sparc_operation (Ctrl_type JMPL)
                             bot_set)
                       then jmpl_instr _A instr
                       else (if member equal_sparc_operation instr_name
                                  (insert equal_sparc_operation (Ctrl_type RETT)
                                    bot_set)
                              then rett_instr _A instr
                              else (if member equal_sparc_operation instr_name
 (insert equal_sparc_operation (Sreg_type RDY)
   (insert equal_sparc_operation (Sreg_type RDPSR)
     (insert equal_sparc_operation (Sreg_type RDWIM)
       (insert equal_sparc_operation (Sreg_type RDTBR) bot_set))))
                                     then read_state_reg_instr _A instr
                                     else (if member equal_sparc_operation
        instr_name
        (insert equal_sparc_operation (Sreg_type WRY)
          (insert equal_sparc_operation (Sreg_type WRPSR)
            (insert equal_sparc_operation (Sreg_type WRWIM)
              (insert equal_sparc_operation (Sreg_type WRTBR) bot_set))))
    then write_state_reg_instr _A instr
    else (if member equal_sparc_operation instr_name
               (insert equal_sparc_operation (Load_store_type FLUSH) bot_set)
           then flush_instr _A instr
           else (if member equal_sparc_operation instr_name
                      (insert equal_sparc_operation (Bicc_type BE)
                        (insert equal_sparc_operation (Bicc_type BNE)
                          (insert equal_sparc_operation (Bicc_type BGU)
                            (insert equal_sparc_operation (Bicc_type BLE)
                              (insert equal_sparc_operation (Bicc_type BL)
                                (insert equal_sparc_operation (Bicc_type BGE)
                                  (insert equal_sparc_operation (Bicc_type BNEG)
                                    (insert equal_sparc_operation (Bicc_type BG)
                                      (insert equal_sparc_operation
(Bicc_type BCS)
(insert equal_sparc_operation (Bicc_type BLEU)
  (insert equal_sparc_operation (Bicc_type BCC)
    (insert equal_sparc_operation (Bicc_type BA)
      (insert equal_sparc_operation (Bicc_type BN) bot_set)))))))))))))
                  then branch_instr instr
                  else (if member equal_sparc_operation instr_name
                             (insert equal_sparc_operation
                               (Load_store_type CASA)
                               (insert equal_sparc_operation
                                 (Load_store_type CASXA) bot_set))
                         then comp_swap_instr _A instr
                         else fail ())))))))))))))))))))
            else return ())));;

let rec fetch_instruction
  s = (let pc_val = cpu_reg_val PC s in
       let psr_val = cpu_reg_val PSR s in
       let s_val = get_S psr_val in
       let asi =
         (if equal_worda len0_word_length1 s_val (zero_word len0_word_length1)
           then word_of_int len0_word_length8 (Pos (Bit0 (Bit0 (Bit0 One))))
           else word_of_int len0_word_length8 (Pos (Bit1 (Bit0 (Bit0 One)))))
         in
        (if equal_inta
              (uint len0_word_length32
                (bitAND_word len0_word_length32
                  (word_of_int len0_word_length32 (Pos (Bit1 One))) pc_val))
              Zero_int
          then (let a = memory_read asi pc_val s in
                 (match a with (None, _) -> Inl [Fetch_instruction_error]
                   | (Some aa, _) -> Inr aa))
          else Inl [Fetch_instruction_error]));;

let rec execute_instr_sub1 _A
  instr =
    bind (gets (fun _ -> fst instr))
      (fun instr_name ->
        bind (gets get_trap_set)
          (fun traps2 ->
            (if equal_set equal_Trap traps2 bot_set &&
                  not (member equal_sparc_operation instr_name
                        (insert equal_sparc_operation (Call_type CALL)
                          (insert equal_sparc_operation (Ctrl_type RETT)
                            (insert equal_sparc_operation (Ctrl_type JMPL)
                              (insert equal_sparc_operation (Bicc_type BE)
                                (insert equal_sparc_operation (Bicc_type BNE)
                                  (insert equal_sparc_operation (Bicc_type BGU)
                                    (insert equal_sparc_operation
                                      (Bicc_type BLE)
                                      (insert equal_sparc_operation
(Bicc_type BL)
(insert equal_sparc_operation (Bicc_type BGE)
  (insert equal_sparc_operation (Bicc_type BNEG)
    (insert equal_sparc_operation (Bicc_type BG)
      (insert equal_sparc_operation (Bicc_type BCS)
        (insert equal_sparc_operation (Bicc_type BLEU)
          (insert equal_sparc_operation (Bicc_type BCC)
            (insert equal_sparc_operation (Bicc_type BA)
              (insert equal_sparc_operation (Bicc_type BN)
                bot_set)))))))))))))))))
              then bind (gets (cpu_reg_val NPC))
                     (fun npc_val ->
                       bind (write_cpu npc_val PC)
                         (k_bind
                           (bind (write_cpu
                                   (plus_word len0_word_length32 npc_val
                                     (word_of_int len0_word_length32
                                       (Pos (Bit0 (Bit0 One)))))
                                   NPC)
                             (k_bind (return ())))))
              else return ())));;

let rec delayed_pool_rm
  dw s =
    (let curr_pool = get_delayed_pool s in
     let (n, (_, _)) = dw in
      (if equal_inta n Zero_int
        then dwrite_update
               (fun _ ->
                 remove1
                   (equal_prod equal_int
                     (equal_prod (equal_word len0_word_length32)
                       equal_CPU_register))
                   dw curr_pool)
               s
        else s));;

let rec delayed_pool_rm_list
  x0 s = match x0, s with [], s -> s
    | x :: xs, s -> delayed_pool_rm_list xs (delayed_pool_rm x s);;

let rec delayed_pool_minus = function [] -> []
                             | x :: xs -> exe_pool x :: delayed_pool_minus xs;;

let rec get_delayed_0
  = function [] -> []
    | x :: xs ->
        (if equal_inta (fst x) Zero_int then x :: get_delayed_0 xs
          else get_delayed_0 xs);;

let rec get_delayed_write dwp = get_delayed_0 dwp;;

let rec delayed_write
  dw s =
    (let (n, (v, r)) = dw in
      (if equal_inta n Zero_int then cpu_reg_mod v r s else s));;

let rec delayed_write_all
  x0 s = match x0, s with [], s -> s
    | x :: xs, s -> delayed_write_all xs (delayed_write x s);;

let rec delayed_pool_write s = (let dwp0 = get_delayed_pool s in
                                let dwp1 = delayed_pool_minus dwp0 in
                                let wl = get_delayed_write dwp1 in
                                let s1 = delayed_write_all wl s in
                                let s2 = delayed_pool_rm_list wl s1 in
                                 s2);;

let rec update_PSR_exe_trap
  cwp_val et_val ps_val psr_val =
    (let tmp0 =
       bitAND_word len0_word_length32 psr_val
         (word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit0 (Bit0 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
(Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
    (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1 (Bit1
  (Bit1 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
       in
     let tmp1 =
       bitOR_word len0_word_length32 tmp0
         (ucast len0_word_length5 len0_word_length32 cwp_val)
       in
     let tmp2 =
       bitOR_word len0_word_length32 tmp1
         (shiftl_word len0_word_length32
           (ucast len0_word_length1 len0_word_length32 et_val)
           (nat_of_num (Bit1 (Bit0 One))))
       in
     let tmp3 =
       bitOR_word len0_word_length32 tmp2
         (shiftl_word len0_word_length32
           (ucast len0_word_length1 len0_word_length32 ps_val)
           (nat_of_num (Bit0 (Bit1 One))))
       in
      tmp3);;

let rec resett_update
  resetta
    (Sparc_state_var_ext
      (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
        atm_ldst_word, more))
    = Sparc_state_var_ext
        (annul, resetta resett, exe, reset, err, ticc, itrpt_lvl, st_bar,
          atm_ldst_byte, atm_ldst_word, more);;

let rec write_reset_trap b v = resett_update (fun _ -> b) v;;

let rec reset_trap_mod
  b s = state_var_update (fun _ -> write_reset_trap b (state_var s)) s;;

let rec set_reset_trap
  b = bind (modify (reset_trap_mod b)) (k_bind (return ()));;

let rec resett
  (Sparc_state_var_ext
    (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
      atm_ldst_word, more))
    = resett;;

let rec get_reset_trap v = resett v;;

let rec reset_trap_val state = get_reset_trap (state_var state);;

let rec exe_trap_wr_pc _A
  uu = bind (gets (cpu_reg_val PSR))
         (fun psr_val ->
           bind (gets (fun _ -> update_S (one_word len0_word_length1) psr_val))
             (fun new_psr_val ->
               bind (write_cpu new_psr_val PSR)
                 (k_bind
                   (bind (gets reset_trap_val)
                     (fun reset_trap ->
                       bind (gets (cpu_reg_val TBR))
                         (fun tbr_val ->
                           (if equal_bool reset_trap false
                             then bind (write_cpu tbr_val PC)
                                    (k_bind
                                      (bind
(write_cpu
  (plus_word len0_word_length32 tbr_val
    (word_of_int len0_word_length32 (Pos (Bit0 (Bit0 One)))))
  NPC)
(k_bind (return ()))))
                             else bind (write_cpu (zero_word len0_word_length32)
 PC)
                                    (k_bind
                                      (bind
(write_cpu (word_of_int len0_word_length32 (Pos (Bit0 (Bit0 One)))) NPC)
(k_bind (bind (set_reset_trap false) (k_bind (return ())))))))))))));;

let rec exe_trap_st_pc _A
  uu = bind (gets annul_val)
         (fun annul ->
           bind (gets (cpu_reg_val PC))
             (fun pc_val ->
               bind (gets (cpu_reg_val NPC))
                 (fun npc_val ->
                   bind (get_curr_win _A ())
                     (fun curr_win ->
                       (if equal_bool annul false
                         then bind (write_reg _A pc_val curr_win
                                     (word_of_int len0_word_length5
                                       (Pos (Bit1 (Bit0 (Bit0 (Bit0 One)))))))
                                (k_bind
                                  (bind (write_reg _A npc_val curr_win
  (word_of_int len0_word_length5 (Pos (Bit0 (Bit1 (Bit0 (Bit0 One)))))))
                                    (k_bind (return ()))))
                         else bind (write_reg _A npc_val curr_win
                                     (word_of_int len0_word_length5
                                       (Pos (Bit1 (Bit0 (Bit0 (Bit0 One)))))))
                                (k_bind
                                  (bind (write_reg _A
  (plus_word len0_word_length32 npc_val
    (word_of_int len0_word_length32 (Pos (Bit0 (Bit0 One)))))
  curr_win
  (word_of_int len0_word_length5 (Pos (Bit0 (Bit1 (Bit0 (Bit0 One)))))))
                                    (k_bind
                                      (bind (set_annul false)
(k_bind (return ())))))))))));;

let rec ticc
  (Sparc_state_var_ext
    (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
      atm_ldst_word, more))
    = ticc;;

let rec get_ticc_trap_type v = ticc v;;

let rec ticc_trap_type_val state = get_ticc_trap_type (state_var state);;

let rec emp_trap_set s = traps_update (fun _ -> bot_set) s;;

let rec select_trap
  uu = bind (gets get_trap_set)
         (fun traps ->
           bind (gets reset_trap_val)
             (fun rt_val ->
               bind (gets (cpu_reg_val PSR))
                 (fun psr_val ->
                   bind (gets (fun _ -> get_ET psr_val))
                     (fun et_val ->
                       bind (modify emp_trap_set)
                         (k_bind
                           (if equal_bool rt_val true then return ()
                             else (if equal_worda len0_word_length1 et_val
(zero_word len0_word_length1)
                                    then bind (set_err_mode true)
   (k_bind (bind (set_exe_mode false) (k_bind (fail ()))))
                                    else (if member equal_Trap Data_store_error
       traps
   then bind (write_cpu_tt
               (word_of_int len0_word_length8
                 (Pos (Bit1 (Bit1 (Bit0 (Bit1 (Bit0 One))))))))
          (k_bind (return ()))
   else (if member equal_Trap Instruction_access_error traps
          then bind (write_cpu_tt
                      (word_of_int len0_word_length8
                        (Pos (Bit1 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))
                 (k_bind (return ()))
          else (if member equal_Trap R_register_access_error traps
                 then bind (write_cpu_tt
                             (word_of_int len0_word_length8
                               (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One))))))))
                        (k_bind (return ()))
                 else (if member equal_Trap Instruction_access_exception traps
                        then bind (write_cpu_tt (one_word len0_word_length8))
                               (k_bind (return ()))
                        else (if member equal_Trap Privileged_instruction traps
                               then bind (write_cpu_tt
   (word_of_int len0_word_length8 (Pos (Bit1 One))))
                                      (k_bind (return ()))
                               else (if member equal_Trap Illegal_instruction
  traps
                                      then bind
     (write_cpu_tt (word_of_int len0_word_length8 (Pos (Bit0 One))))
     (k_bind (return ()))
                                      else (if member equal_Trap Fp_disabled
         traps
     then bind (write_cpu_tt
                 (word_of_int len0_word_length8 (Pos (Bit0 (Bit0 One)))))
            (k_bind (return ()))
     else (if member equal_Trap Cp_disabled traps
            then bind (write_cpu_tt
                        (word_of_int len0_word_length8
                          (Pos (Bit0 (Bit0 (Bit1 (Bit0 (Bit0 One))))))))
                   (k_bind (return ()))
            else (if member equal_Trap Unimplemented_FLUSH traps
                   then bind (write_cpu_tt
                               (word_of_int len0_word_length8
                                 (Pos (Bit1 (Bit0 (Bit1 (Bit0 (Bit0 One))))))))
                          (k_bind (return ()))
                   else (if member equal_Trap Window_overflow traps
                          then bind (write_cpu_tt
                                      (word_of_int len0_word_length8
(Pos (Bit1 (Bit0 One)))))
                                 (k_bind (return ()))
                          else (if member equal_Trap Window_underflow traps
                                 then bind
(write_cpu_tt (word_of_int len0_word_length8 (Pos (Bit0 (Bit1 One)))))
(k_bind (return ()))
                                 else (if member equal_Trap
    Mem_address_not_aligned traps
then bind (write_cpu_tt (word_of_int len0_word_length8 (Pos (Bit1 (Bit1 One)))))
       (k_bind (return ()))
else (if member equal_Trap Fp_exception traps
       then bind (write_cpu_tt
                   (word_of_int len0_word_length8
                     (Pos (Bit0 (Bit0 (Bit0 One))))))
              (k_bind (return ()))
       else (if member equal_Trap Cp_exception traps
              then bind (write_cpu_tt
                          (word_of_int len0_word_length8
                            (Pos (Bit0 (Bit0 (Bit0 (Bit1 (Bit0 One))))))))
                     (k_bind (return ()))
              else (if member equal_Trap Data_access_error traps
                     then bind (write_cpu_tt
                                 (word_of_int len0_word_length8
                                   (Pos (Bit1
  (Bit0 (Bit0 (Bit1 (Bit0 One))))))))
                            (k_bind (return ()))
                     else (if member equal_Trap Data_access_exception traps
                            then bind (write_cpu_tt
(word_of_int len0_word_length8 (Pos (Bit1 (Bit0 (Bit0 One))))))
                                   (k_bind (return ()))
                            else (if member equal_Trap Tag_overflow traps
                                   then bind
  (write_cpu_tt (word_of_int len0_word_length8 (Pos (Bit0 (Bit1 (Bit0 One))))))
  (k_bind (return ()))
                                   else (if member equal_Trap Division_by_zero
      traps
  then bind (write_cpu_tt
              (word_of_int len0_word_length8
                (Pos (Bit0 (Bit1 (Bit0 (Bit1 (Bit0 One))))))))
         (k_bind (return ()))
  else (if member equal_Trap Trap_instruction traps
         then bind (gets ticc_trap_type_val)
                (fun ticc_trap_type ->
                  bind (write_cpu_tt
                         (word_cat len0_word_length1 len0_word_length7
                           len0_word_length8 (one_word len0_word_length1)
                           ticc_trap_type))
                    (k_bind (return ())))
         else return ()))))))))))))))))))))))))));;

let rec err
  (Sparc_state_var_ext
    (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
      atm_ldst_word, more))
    = err;;

let rec get_err_mode v = err v;;

let rec err_mode_val state = get_err_mode (state_var state);;

let rec execute_trap _A
  uu = bind (select_trap ())
         (k_bind
           (bind (gets err_mode_val)
             (fun err_mode ->
               (if equal_bool err_mode true then return ()
                 else bind (gets (cpu_reg_val PSR))
                        (fun psr_val ->
                          bind (gets (fun _ ->
                                       ucast len0_word_length1 len0_word_length1
 (get_S psr_val)))
                            (fun s_val ->
                              bind (get_curr_win _A ())
                                (fun curr_win ->
                                  bind (gets
 (fun _ ->
   word_of_int len0_word_length5
     (modulo_int (minus_int (uint _A curr_win) one_inta) nwindows)))
                                    (fun new_cwp ->
                                      bind
(gets (fun _ ->
        update_PSR_exe_trap new_cwp (zero_word len0_word_length1) s_val
          psr_val))
(fun new_psr_val ->
  bind (write_cpu new_psr_val PSR)
    (k_bind
      (bind (exe_trap_st_pc _A ())
        (k_bind (bind (exe_trap_wr_pc _A ()) (k_bind (return ())))))))))))))));;

let rec exe
  (Sparc_state_var_ext
    (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
      atm_ldst_word, more))
    = exe;;

let rec get_exe_mode v = exe v;;

let rec exe_mode_val state = get_exe_mode (state_var state);;

let rec execute_instruction _A
  uu = bind (gets get_trap_set)
         (fun traps ->
           (if equal_set equal_Trap traps bot_set
             then bind (gets exe_mode_val)
                    (fun exe_mode ->
                      (if equal_bool exe_mode true
                        then bind (modify delayed_pool_write)
                               (k_bind
                                 (bind (gets fetch_instruction)
                                   (fun a ->
                                     (match a
                                       with Inl _ ->
 bind (raise_trap Instruction_access_exception) (k_bind (return ()))
                                       | Inr v1 ->
 bind (gets (fun _ -> decode_instruction v1))
   (fun aa ->
     (match aa with Inl _ -> fail ()
       | Inr v2 ->
         bind (gets (fun _ -> v2))
           (fun instr ->
             bind (gets annul_val)
               (fun annul ->
                 (if equal_bool annul false
                   then bind (dispatch_instruction _A instr)
                          (k_bind
                            (bind (execute_instr_sub1 _A instr)
                              (k_bind (return ()))))
                   else bind (set_annul false)
                          (k_bind
                            (bind (gets (cpu_reg_val NPC))
                              (fun npc_val ->
                                bind (write_cpu npc_val PC)
                                  (k_bind
                                    (bind (write_cpu
    (plus_word len0_word_length32 npc_val
      (word_of_int len0_word_length32 (Pos (Bit0 (Bit0 One)))))
    NPC)
                                      (k_bind (return ()))))))))))))))))
                        else return ()))
             else bind (execute_trap _A ()) (k_bind (return ()))));;

let rec seq_exec _A
  = function Zero_nat -> return ()
    | Suc v ->
        bind (execute_instruction _A ())
          (k_bind (seq_exec _A (minus_nat (Suc v) one_nat)));;

let rec emp_mem asi add = None;;

let emp_trap : trap set = bot_set;;

let init_mmu : unit mMU_state_ext = mmu_setup;;

let rec emp_bbyte add = false;;

let rec emp_bword add = false;;

let emp_cpu_cache : unit cpu_cache_ext
  = Cpu_cache_ext (empty_cache, empty_cache, ());;

let rec emp_user_reg ws w5 = zero_word len0_word_length32;;

let rec emp_sys_reg r = zero_word len0_word_length32;;

let emp_dw_pool : (int * (word_length32 word * cPU_register)) list = [];;

let rec emp_cpu_reg r = zero_word len0_word_length32;;

let init_svar : unit sparc_state_var_ext
  = Sparc_state_var_ext
      (false, false, true, false, false, zero_word len0_word_length7,
        zero_word len0_word_length3, false, emp_bbyte, emp_bword, ());;

let emp_state : (word_length5, unit) sparc_state_ext
  = Sparc_state_ext
      (emp_cpu_reg, emp_user_reg, emp_sys_reg, emp_mem, init_mmu, emp_cpu_cache,
        emp_dw_pool, init_svar, emp_trap, false, ());;

let rec reset_update
  reseta
    (Sparc_state_var_ext
      (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
        atm_ldst_word, more))
    = Sparc_state_var_ext
        (annul, resett, exe, reseta reset, err, ticc, itrpt_lvl, st_bar,
          atm_ldst_byte, atm_ldst_word, more);;

let rec write_reset_mode b v = reset_update (fun _ -> b) v;;

let rec reset_mode_mod
  b s = state_var_update (fun _ -> write_reset_mode b (state_var s)) s;;

let rec reset
  (Sparc_state_var_ext
    (annul, resett, exe, reset, err, ticc, itrpt_lvl, st_bar, atm_ldst_byte,
      atm_ldst_word, more))
    = reset;;

let rec get_reset_mode v = reset v;;

let rec reset_mode_val state = get_reset_mode (state_var state);;

let init_state0 : (word_length5, unit) sparc_state_ext
  = (let a =
       cpu_reg_mod
         (word_of_int len0_word_length32
           (Pos (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
  (Bit1 (Bit1 (Bit1 (Bit0 (Bit0 (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0
    (Bit0 (Bit0 (Bit0 (Bit0 (Bit1 (Bit1 (Bit0
  (Bit0 (Bit1 (Bit1 (Bit1 One)))))))))))))))))))))))))))))))))
         PSR emp_state
       in
      cpu_reg_mod (word_of_int len0_word_length32 (Pos (Bit0 One))) TBR a);;

let rec seq_exec_leon3 x = seq_exec len0_word_length5 x;;

end;; (*struct Sparc_seq*)
